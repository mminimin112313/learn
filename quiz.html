<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Quiz Obsidian (v12.1 - High Contrast Fix)</title>

  <!-- Fonts: Inter (Requested), Nanum for fallback -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600&family=Nanum+Gothic:wght@300;400;700&family=Nanum+Myeongjo:wght@400;700&display=swap" rel="stylesheet">

  <!-- Dependencies -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <!-- Viewer Mode Dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { 
      getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
      GoogleAuthProvider, signInWithPopup, signOut
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { 
      getFirestore, doc, getDoc, getDocs, addDoc, setDoc, updateDoc, deleteDoc, 
      onSnapshot, collection, query, where, writeBatch, setLogLevel
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    window.firebase = {
      app: { initializeApp },
      auth: { 
        getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
        GoogleAuthProvider, signInWithPopup, signOut 
      },
      firestore: { 
        getFirestore, doc, getDoc, getDocs, addDoc, setDoc, updateDoc, deleteDoc, 
        onSnapshot, collection, query, where, writeBatch, setLogLevel
      }
    };
  </script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyBR_9ivOtQRIW_KIQRYBxJ_nFtYL7GYZwg",
      authDomain: "quiz-436ac.firebaseapp.com",
      projectId: "quiz-436ac",
      storageBucket: "quiz-436ac.firebasestorage.app",
      messagingSenderId: "131117093431",
      appId: "1:131117093431:web:56e1beff4c63d35b5b25b2"
    };
    const appId = "my-unique-app-id";
    window.__firebase_config = JSON.stringify(firebaseConfig);
    window.__app_id = appId;
  </script>
  
  <!-- High Contrast Obsidian Styles -->
  <style>
    :root {
        /* Palette Definition */
        --obsidian-black: #000000;
        --obsidian-dark: #050505;
        --obsidian-panel: #0a0a0a;
        --obsidian-border: #333333;
        
        /* Glassmorphism Variables */
        --glass-bg: rgba(20, 20, 20, 0.65);
        --glass-border: 1px solid rgba(255, 255, 255, 0.15);
        --glass-highlight: 1px solid rgba(255, 255, 255, 0.3);
        --glass-blur: blur(12px);
        
        /* Typography */
        --font-main: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        --text-primary: #eeeeee;
        --text-secondary: #a0a0a0;
        --text-tertiary: #666666;
        
        /* Engagement / Accents */
        --accent-gradient: linear-gradient(135deg, #ffffff 0%, #b0b0b0 100%);
        --accent-hover: linear-gradient(135deg, #ffffff 0%, #e0e0e0 100%);
        --accent-text: #000000;
        --danger-color: #ff4d4d;
    }

    body {
      font-family: var(--font-main);
      font-weight: 300; /* Thin Typography */
      margin: 0;
      background-color: var(--obsidian-black);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      letter-spacing: -0.01em;
    }

    /* Scrollbars */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: #555; }

    /* Layout Structure */
    .vsc-sidebar-container {
      display: flex;
      flex-direction: row;
      width: auto;
      height: 100vh;
      background-color: var(--obsidian-black);
    }

    /* Activity Bar (Leftmost Slim Bar) */
    .vsc-activity-bar {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 12px 0;
      background-color: var(--obsidian-black);
      border-right: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0;
      width: 56px;
      z-index: 10;
    }
    .vsc-activity-item {
      background: transparent;
      border: none;
      color: var(--text-tertiary);
      padding: 12px;
      margin: 4px 0;
      cursor: pointer;
      font-size: 22px;
      transition: all 0.2s ease;
      display: flex;
      justify-content: center;
      position: relative;
    }
    .vsc-activity-item:hover { color: var(--text-primary); }
    .vsc-activity-item[data-active='true'] {
      color: #fff;
    }
    .vsc-activity-item[data-active='true']::before {
        content: '';
        position: absolute;
        left: 0;
        top: 12px;
        bottom: 12px;
        width: 3px;
        background: white;
        border-radius: 0 2px 2px 0;
        box-shadow: 0 0 8px rgba(255,255,255,0.5);
    }

    /* Sidebar View (File Explorer etc) */
    .vsc-sidebar-view {
      flex-grow: 1;
      background-color: var(--obsidian-panel);
      color: var(--text-primary);
      width: 300px;
      min-width: 300px;
      border-right: 1px solid rgba(255,255,255,0.08);
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      display: flex;
      flex-direction: column;
    }
    .vsc-sidebar-view[data-visible='false'] {
      width: 0;
      min-width: 0;
      opacity: 0;
      border-right: none;
    }

    /* Glassmorphism Headers */
    .view-header, .vsc-view-pane-header {
      margin: 0;
      color: var(--text-primary);
      font-size: 0.9rem;
      font-weight: 500;
      padding: 16px;
      border-bottom: var(--glass-border);
      background: rgba(255, 255, 255, 0.02);
      backdrop-filter: var(--glass-blur);
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .view-header-icon {
        background: transparent; 
        border: 1px solid transparent; 
        color: var(--text-secondary); 
        cursor: pointer;
        padding: 4px; 
        border-radius: 4px;
        transition: all 0.2s;
    }
    .view-header-icon:hover { 
        background-color: rgba(255,255,255,0.1); 
        color: white; 
        border-color: rgba(255,255,255,0.2);
    }

    /* Content Areas */
    .vsc-view-content, .view-content-scroll, .vsc-view-pane-content {
        flex-grow: 1;
        overflow-y: auto;
        background-color: transparent;
    }
    .view-padding { padding: 16px; }
    
    /* Panes */
    .vsc-view-panes { height: 100%; }
    .vsc-view-pane { display: flex; flex-direction: column; flex: 1; overflow: hidden; }

    /* Main Content Editor Area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background-color: var(--obsidian-dark);
      position: relative;
    }

    /* Editor Header (Tabs area) */
    .main-editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 20px;
        background-color: rgba(0,0,0,0.6);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(255,255,255,0.08);
        height: 50px;
    }
    .main-editor-title { font-size: 0.9rem; font-weight: 400; letter-spacing: 0.02em; }

    /* Toggle Group - Glass Style */
    .editor-toggle-group {
        display: inline-flex;
        border: 1px solid rgba(255,255,255,0.15);
        border-radius: 6px;
        padding: 2px;
        background: rgba(0,0,0,0.3);
    }
    .editor-toggle-btn {
        background: transparent;
        color: var(--text-secondary);
        padding: 4px 12px;
        border: none;
        cursor: pointer;
        font-size: 0.8rem;
        border-radius: 4px;
        font-weight: 400;
        transition: all 0.2s;
    }
    .editor-toggle-btn.active {
        background-color: rgba(255,255,255,0.1);
        color: white;
        font-weight: 500;
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    
    /* Primary Action Button (White Gradient) */
    .main-editor-action-btn, .form-button, .modal-button-primary {
        background: var(--accent-gradient);
        color: var(--accent-text);
        padding: 6px 16px;
        border: 1px solid white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 600;
        box-shadow: 0 0 10px rgba(255,255,255,0.1);
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 0.03em;
    }
    .main-editor-action-btn:hover, .form-button:hover, .modal-button-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 0 15px rgba(255,255,255,0.3);
        background: var(--accent-hover);
    }
    .main-editor-action-btn:disabled, .form-button:disabled {
        background: #333;
        color: #666;
        border-color: #444;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
    }

    .main-editor {
      flex-grow: 1;
      background-color: var(--obsidian-dark);
      color: #e0e0e0;
      border: none;
      outline: none;
      padding: 40px;
      font-family: 'Nanum Gothic', sans-serif;
      font-size: 15px;
      line-height: 1.8;
      resize: none;
      font-weight: 300;
    }
    .main-editor-placeholder {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: var(--text-secondary);
      font-weight: 200;
    }
    
    /* Form Elements (Glassmorphism Inputs) */
    .form-group { margin-bottom: 20px; }
    .form-label {
        display: block;
        font-size: 0.8rem;
        margin-bottom: 8px;
        color: var(--text-secondary);
        font-weight: 400;
        text-transform: uppercase;
    }
    .form-input, .form-textarea, .form-select {
      width: 100%;
      padding: 10px 12px;
      box-sizing: border-box;
      border: var(--glass-border);
      background-color: rgba(0,0,0,0.3);
      color: white;
      border-radius: 4px;
      font-family: var(--font-main);
      font-weight: 300;
      transition: border-color 0.2s;
    }
    .form-input:focus, .form-textarea:focus, .form-select:focus {
        outline: none;
        border-color: rgba(255,255,255,0.5);
        background-color: rgba(0,0,0,0.5);
    }
    
    /* List Items (Cards) */
    .list-item {
      padding: 14px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid transparent;
      border-radius: 6px;
      margin-bottom: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .list-item:hover {
      background: rgba(255, 255, 255, 0.07);
      border-color: rgba(255, 255, 255, 0.2);
      transform: translateX(2px);
    }
    .list-item-title { font-weight: 500; color: white; margin-bottom: 4px; }
    .list-item-sub { font-size: 0.8rem; color: var(--text-secondary); font-weight: 300; }
    
    .list-item-badge {
        font-size: 0.7rem;
        padding: 2px 8px;
        border-radius: 12px;
        background-color: #333;
        color: #ccc;
        border: 1px solid #555;
    }
    .list-item-badge.success { background-color: rgba(76, 175, 80, 0.2); color: #81c784; border-color: #81c784; }
    .list-item-badge.error { background-color: rgba(244, 67, 54, 0.2); color: #e57373; border-color: #e57373; }

    /* Modals - Solid Border Glassmorphism */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .modal-container {
      background-color: rgba(15, 15, 15, 0.9);
      backdrop-filter: blur(24px);
      color: var(--text-primary);
      border: var(--glass-highlight);
      border-radius: 12px;
      width: 90%;
      max-width: 700px;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 50px -10px rgba(0,0,0,0.8);
    }
    .modal-header {
      padding: 20px 24px;
      border-bottom: var(--glass-border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 { font-weight: 300; font-size: 1.4rem; letter-spacing: 0.05em; }
    .modal-body { padding: 24px; overflow-y: auto; }
    .modal-footer {
      padding: 16px 24px;
      border-top: var(--glass-border);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      background: rgba(0,0,0,0.2);
    }
    .modal-button-secondary {
      background: transparent;
      color: var(--text-primary);
      border: 1px solid rgba(255,255,255,0.2);
      padding: 6px 16px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 300;
    }
    .modal-button-secondary:hover { border-color: white; background: rgba(255,255,255,0.05); }

    /* Settings Nav */
    .settings-nav { width: 180px; border-right: var(--glass-border); padding: 20px 0; }
    .settings-nav-item {
        padding: 12px 24px; cursor: pointer; font-size: 0.9rem; font-weight: 300;
        color: var(--text-secondary); border-left: 2px solid transparent;
    }
    .settings-nav-item:hover { color: white; background: rgba(255,255,255,0.03); }
    .settings-nav-item[data-active='true'] {
        color: white; border-left-color: white; background: linear-gradient(90deg, rgba(255,255,255,0.05), transparent); font-weight: 500;
    }

    /* File Tree */
    .file-tree-node {
        color: var(--text-secondary);
        border: 1px solid transparent;
        margin: 1px 0;
        border-radius: 4px;
        transition: all 0.15s;
    }
    .file-tree-node:hover {
        background-color: rgba(255,255,255,0.05);
        color: white;
    }
    .file-tree-node[data-active='true'] {
        background-color: rgba(255,255,255,0.1);
        border: var(--glass-border);
        color: white;
    }
    .file-tree-node-icon { opacity: 0.7; }

    /* Viewer Mode Typography Override */
    .prose-readable-wrapper { padding: 40px; }
    .prose-dark-theme {
        --text-primary: #f0f0f0;
        --text-secondary: #b0b0b0;
        --border-color: #333;
        --accent-primary: #ffffff;
        --bg-tertiary: rgba(255,255,255,0.05);
    }
    .prose-readable h1, .prose-readable h2, .prose-readable h3 {
        font-family: 'Inter', sans-serif;
        font-weight: 500;
        color: white;
    }
    .prose-readable p {
        font-family: 'Inter', sans-serif;
        font-weight: 300;
        font-size: 1.05rem;
        line-height: 1.8;
    }
    .prose-readable blockquote {
        border-left-color: white;
        background: rgba(255,255,255,0.03);
        font-style: italic;
    }
    .prose-readable code {
        background: rgba(255,255,255,0.1);
        color: #fff;
        border: 1px solid rgba(255,255,255,0.2);
    }
    .prose-readable a {
        color: white;
        border-bottom: 1px solid rgba(255,255,255,0.5);
    }
    .prose-readable a:hover {
        background: white;
        color: black;
    }

    /* Spinner */
    .spinner { border-color: rgba(255,255,255,0.1); border-top-color: white; }
    
    /* Context Menu */
    .context-menu {
        background: rgba(10, 10, 10, 0.95);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255,255,255,0.2);
        box-shadow: 0 10px 30px rgba(0,0,0,0.8);
    }
    .context-menu-item:hover { background: rgba(255,255,255,0.1); color: white; }

    /* Quiz UI Specifics */
    .quiz-question-card {
        background: rgba(255,255,255,0.02);
        border: 1px solid rgba(255,255,255,0.1);
        padding: 20px;
        border-radius: 8px;
    }
    .quiz-option-label {
        background: rgba(0,0,0,0.4);
        border: 1px solid rgba(255,255,255,0.1);
        transition: all 0.2s;
    }
    .quiz-option-label:hover {
        background: rgba(255,255,255,0.05);
        border-color: rgba(255,255,255,0.3);
    }
    input[type="radio"] { accent-color: white; }

  </style>
</head>
<body>
  
  <div id="root"></div>
  <input type="file" id="file-upload-input" style="display: none" multiple accept=".txt,.md,.zip" />
  <input type="file" id="project-import-input" style="display: none" accept=".json" />

  <!-- React Application Script -->
  <script type="module">
    const { useState, useEffect, useCallback, useMemo, createContext, useContext, useRef } = React;
    const { createRoot } = ReactDOM;
    const e = React.createElement;

    const { app, auth, firestore } = window.firebase;
    const { initializeApp } = app;
    const { 
        getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
        GoogleAuthProvider, signInWithPopup, signOut
    } = auth;
    const { 
        getFirestore, doc, getDoc, getDocs, addDoc, setDoc, updateDoc, deleteDoc, 
        onSnapshot, collection, query, where, writeBatch, setLogLevel
    } = firestore;

    /* --- Data Hooks & Logic --- */
    const ToastContext = createContext(null);
    const useToast = () => useContext(ToastContext);
    const AppContext = createContext(null);
    
    const FootnoteManager = {
        footnotes: {},
        footnoteOrder: [],
        clear() { this.footnotes = {}; this.footnoteOrder = []; },
        addDefinition(key, content) {
            const lowerKey = key.toLowerCase();
            if (!this.footnotes[lowerKey]) {
                this.footnotes[lowerKey] = { text: content.trim(), html: window.marked.parseInline(content.trim()) };
            }
        },
        addReference(key) {
            const lowerKey = key.toLowerCase();
            if (this.footnoteOrder.indexOf(lowerKey) === -1) this.footnoteOrder.push(lowerKey);
        },
        getNote(key) { return this.footnotes[key.toLowerCase()]; },
        getOrder() { return this.footnoteOrder; },
        extractAndClean(markdown) {
            this.clear(); 
            const footnoteDefRegex = /^\[\^(.+?)\]:\s*([\s\S]*?)(?=\n\[\^|$)/gm;
            return markdown.replace(footnoteDefRegex, (match, name, content) => {
                this.addDefinition(name, content);
                return '';
            });
        }
    };

    const parseMarkdownWithExtensions = (markdownText) => {
        if (typeof markdownText !== 'string') return '';
        if (!window.marked) return markdownText;
        const isolatedParser = new window.marked.Marked();
        const mathExtension = {
            name: 'math', level: 'inline', 
            start(src) { return src.indexOf('$'); },
            tokenizer(src) {
                const blockRule = /^\$\$([\s\S]+?)\$\$/;
                let match = blockRule.exec(src);
                if (match) return { type: 'math', raw: match[0], text: match[1], displayMode: true };
                if (!src.startsWith('$$')) {
                    const inlineRule = /^\$((?:[^$]|\\[$])+?)\$/;
                    match = inlineRule.exec(src);
                    if (match) return { type: 'math', raw: match[0], text: match[1], displayMode: false };
                }
            },
            renderer(token) { return token.raw; }
        };
        const highlightExtension = {
            name: 'highlight', level: 'inline',
            start(src) { return src.indexOf('=='); },
            tokenizer(src) {
                const rule = /^==(.+?)==/;
                const match = rule.exec(src);
                if (match) return { type: 'highlight', raw: match[0], text: this.lexer.inlineTokens(match[1].trim()) };
            },
            renderer(token) { return `<mark>${this.parser.parseInline(token.text)}</mark>`; },
        };
        const footnoteRefExtension = {
            name: 'footnoteRef', level: 'inline',
            start(src) { return src.indexOf('[^'); },
            tokenizer(src) {
                const rule = /^\[\^((?:[^\]\\]|\\.)+)\](?!:)/;
                const match = rule.exec(src);
                if (match) {
                    FootnoteManager.addReference(match[1]);
                    return { type: 'footnoteRef', raw: match[0], name: match[1] };
                }
            },
            renderer(token) {
                const name = token.name;
                const order = FootnoteManager.getOrder();
                const note = FootnoteManager.getNote(name);
                const index = order.indexOf(name.toLowerCase()) + 1;
                const finalIndex = index > 0 ? index : '?';
                return `<sup id="fnref:${name}" class="footnote-ref"><a href="#fn:${name}" data-footnote-key="${name}">${finalIndex}</a></sup>`;
            }
        };
        isolatedParser.use({ gfm: true, breaks: true, extensions: [mathExtension, highlightExtension, footnoteRefExtension] });
        return isolatedParser.parse(markdownText);
    };

    const applyPostRenderEffects = (element) => {
        if (!element) return;
        // Bold fix
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, (node) => {
            const parentName = node.parentNode.nodeName.toLowerCase();
            return ['code', 'pre', 'script', 'style', 'a', 'strong', 'em', 'sup', 'mark'].includes(parentName) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
        });
        const nodesToProcess = [];
        while (walker.nextNode()) nodesToProcess.push(walker.currentNode);
        nodesToProcess.forEach(textNode => {
            if (textNode.textContent.includes('**')) {
                const fragment = document.createDocumentFragment();
                let currentText = textNode.textContent;
                let lastIndex = 0;
                currentText.replace(/\*\*(.*?)\*\*/g, (match, content, offset) => {
                    if (offset > lastIndex) fragment.appendChild(document.createTextNode(currentText.substring(lastIndex, offset)));
                    const strong = document.createElement('strong');
                    strong.textContent = content;
                    fragment.appendChild(strong);
                    lastIndex = offset + match.length;
                });
                if (lastIndex < currentText.length) fragment.appendChild(document.createTextNode(currentText.substring(lastIndex)));
                textNode.parentNode.replaceChild(fragment, textNode);
            }
        });
        // KaTeX
        if (window.renderMathInElement) {
            try {
                window.renderMathInElement(element, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ]
                });
            } catch (e) { console.error(e); }
        }
    };

    /* --- API & Worker Logic --- */
    const QUIZ_SCHEMA = { type: "OBJECT", properties: { title: { type: "STRING" }, questions: { type: "ARRAY", items: { type: "OBJECT", properties: { questionType: { type: "STRING" }, questionText: { type: "STRING" }, options: { type: "ARRAY", items: { "type": "STRING" }, nullable: true }, correctAnswerIndex: { type: "NUMBER", nullable: true }, gradingCriteria: { type: "STRING", nullable: true } }, required: ["questionType", "questionText"] } }, required: ["title", "questions"] }};
    const GRADING_SCHEMA = { type: "OBJECT", properties: { isCorrect: { type: "BOOLEAN" }, feedback: { type: "STRING" } }, required: ["isCorrect", "feedback"] };
    
    class ApiError extends Error { constructor(message, status) { super(message); this.name = 'ApiError'; this.status = status; } }
    const fetchWithRetry = async (url, options, retries = 3, delay = 1000) => {
      for (let i = 0; i < retries; i++) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            if (response.status === 429) throw new ApiError('Rate limit', response.status);
            throw new ApiError(`HTTP error! ${response.status}`, response.status);
          }
          return response.json();
        } catch (error) {
          if (error.status === 429 && i < retries - 1) await new Promise(res => setTimeout(res, delay * Math.pow(2, i))); else throw error;
        }
      }
      throw new Error('API failed');
    };

    const generateQuizWithAi = async (sourceText, options, settings) => {
      const { numQuestions, difficulty, questionType } = options;
      const apiKey = settings?.apiKeys?.[0]?.key || "";
      const model = settings?.modelName || "gemini-2.5-flash";
      if (!apiKey) throw new ApiError('API Key Missing', 401);
      
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      let systemPrompt = settings.quizSystemPrompt || "Generate a quiz based on the text.";
      systemPrompt = systemPrompt.replace('{{DIFFICULTY}}', difficulty).replace('{{QUESTION_TYPE}}', questionType).replace('{{NUM_QUESTIONS}}', numQuestions);
      
      const payload = {
        contents: [{ role: "user", parts: [{ text: `--- SOURCE ---\n${sourceText}` }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: { responseMimeType: "application/json", responseSchema: QUIZ_SCHEMA, temperature: 0.3 }
      };

      const result = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      return JSON.parse(result.candidates?.[0]?.content?.parts?.[0]?.text);
    };

    const gradeAnswerWithAi = async (qText, uAnswer, criteria, settings) => {
      const apiKey = settings?.apiKeys?.[0]?.key || "";
      const model = settings?.modelName || "gemini-2.5-flash";
      if (!apiKey) throw new ApiError('API Key Missing', 401);
      
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      const payload = {
        contents: [{ role: "user", parts: [{ text: `Q: ${qText}\nCriteria: ${criteria}\nAnswer: ${uAnswer}` }] }],
        systemInstruction: { parts: [{ text: settings.gradingSystemPrompt || "Grade this." }] },
        generationConfig: { responseMimeType: "application/json", responseSchema: GRADING_SCHEMA, temperature: 0.1 }
      };

      const result = await fetchWithRetry(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
      return JSON.parse(result.candidates?.[0]?.content?.parts?.[0]?.text);
    };

    // Fixed worker script construction with explicit semicolons
    const workerScript = `
      const fetchWithRetry = ${fetchWithRetry.toString()};
      ${ApiError.toString()}
      const generateQuizWithAi = ${generateQuizWithAi.toString()};
      const QUIZ_SCHEMA = ${JSON.stringify(QUIZ_SCHEMA)};
      const gradeAnswerWithAi = ${gradeAnswerWithAi.toString()};
      const GRADING_SCHEMA = ${JSON.stringify(GRADING_SCHEMA)};

      const handleAsyncGrading = async (attempt, settings) => {
          const results = JSON.parse(attempt.answers);
          const newResults = await Promise.all(results.map(async (r) => {
              if (r.isCorrect !== null) return r;
              try {
                  const grade = await gradeAnswerWithAi(r.questionText, r.selectedAnswer, r.gradingCriteria, settings);
                  return { ...r, isCorrect: grade.isCorrect, feedback: grade.feedback };
              } catch (e) { return { ...r, isCorrect: false, feedback: "Error: " + e.message }; }
          }));
          const newScore = newResults.filter(r => r.isCorrect).length;
          return { ...attempt, score: newScore, answers: JSON.stringify(newResults) };
      };

      self.onmessage = async (e) => {
        const { id, taskType, sourceText, options, settings, attempt } = e.data;
        try {
          if (taskType === 'grade') {
            const updatedAttempt = await handleAsyncGrading(attempt, settings);
            self.postMessage({ status: 'success', taskId: id, taskType, updatedAttempt, options: { quizTitle: attempt.quizTitle } });
          } else {
            const quizData = await generateQuizWithAi(sourceText, options, settings);
            self.postMessage({ status: 'success', taskId: id, taskType, quizData, options });
          }
        } catch (error) { self.postMessage({ status: 'error', taskId: id, taskType, error: error.message }); }
      };
    `;
    const workerUrl = URL.createObjectURL(new Blob([workerScript], { type: 'application/javascript' }));

    const DEFAULT_SETTINGS = {
        apiKeys: [{ key: "", rpm: 60 }], defaultDifficulty: "Medium", defaultQuestionType: "MultipleChoice", defaultNumQuestions: 10, modelName: "gemini-2.5-flash",
        quizSystemPrompt: "You are an expert quiz creator. Generate a {{DIFFICULTY}} quiz with {{NUM_QUESTIONS}} {{QUESTION_TYPE}} questions based on the source text.",
        gradingSystemPrompt: "You are a grader. Grade the answer strictly based on the criteria."
    };

    const useFileSystem = (files, db, userId, appId) => {
        const getCollectionRef = (n) => collection(db, `artifacts/${appId}/users/${userId}/${n}`);
        const fileActions = useMemo(() => {
          if (!db || !userId) return {};
          return {
            create: async (pid, type, name, content = '') => {
              const newFile = { name: name || (type === 'folder' ? 'Folder' : 'New File'), type, parentId: pid, content: type === 'file' ? content : null, metadata: { notes: '' }, createdAt: new Date().toISOString(), userId };
              const ref = await addDoc(getCollectionRef('files'), newFile);
              return { ...newFile, id: ref.id };
            },
            rename: async (fid, name) => updateDoc(doc(db, `artifacts/${appId}/users/${userId}/files`, fid), { name }),
            remove: async (fid, type) => deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/files`, fid)),
            updateContent: async (fid, content) => updateDoc(doc(db, `artifacts/${appId}/users/${userId}/files`, fid), { content }),
            move: async (fid, pid) => updateDoc(doc(db, `artifacts/${appId}/users/${userId}/files`, fid), { parentId: pid }),
            updateMetadata: async (fid, meta) => updateDoc(doc(db, `artifacts/${appId}/users/${userId}/files`, fid), { metadata: meta })
          };
        }, [db, userId, appId]);

        const fileTree = useMemo(() => {
          const map = {}; const roots = [];
          files.forEach(f => map[f.id] = { ...f, children: [] });
          Object.values(map).forEach(n => {
             if(n.parentId === 'root') roots.push(n);
             else if(map[n.parentId]) map[n.parentId].children.push(n);
          });
          const sortFn = (a,b) => (a.type === b.type ? a.name.localeCompare(b.name) : (a.type === 'folder' ? -1 : 1));
          const sortNode = (list) => { list.sort(sortFn); list.forEach(c => sortNode(c.children)); };
          sortNode(roots);
          return roots;
        }, [files]);
        return { fileTree, fileActions };
    };

    /* --- Components --- */
    const ToastProvider = ({ children }) => {
        const [toasts, setToasts] = useState([]);
        const show = useCallback((message, type = 'info') => {
            const id = crypto.randomUUID();
            setToasts(prev => [...prev, { id, message, type }]);
            setTimeout(() => setToasts(prev => prev.filter(t => t.id !== id)), 3000);
        }, []);
        return e(ToastContext.Provider, { value: { show } }, children, e('div', { className: 'toast-container' }, toasts.map(t => e('div', { key: t.id, className: `toast-item ${t.type}` }, t.message))));
    };

    const Spinner = () => e('div', { className: 'spinner-overlay' }, e('div', { className: 'spinner' }));

    const ReactVscodeSidebar = ({ items = [], onActiveChange, activeId, isVisible, children }) => {
      const activityBarTop = e('div', null, items.filter(i => !i.isBottom).map(i => e('button', { key: i.id, className: 'vsc-activity-item', onClick: () => onActiveChange(i.id), 'data-active': isVisible && i.id === activeId }, i.icon)));
      const activityBarBottom = e('div', null, items.filter(i => i.isBottom).map(i => e('button', { key: i.id, className: 'vsc-activity-item', onClick: () => onActiveChange(i.id), 'data-active': isVisible && i.id === activeId }, i.icon)));
      const activeView = React.Children.toArray(children).find(c => c.props.viewId === activeId);
      return e('div', { className: 'vsc-sidebar-container' }, 
        e('div', { className: 'vsc-activity-bar' }, activityBarTop, activityBarBottom), 
        e('div', { className: 'vsc-sidebar-view', 'data-visible': isVisible }, isVisible && activeView ? e('div', { className: 'vsc-view-content', key: activeId }, activeView) : null)
      );
    };

    const FileNode = ({ node, depth, onContextMenu }) => {
        const { activeEditorFile, editingNodeId, setEditingNodeId, fileActions } = useContext(AppContext);
        const [isOpen, setIsOpen] = useState(true);
        const [editName, setEditName] = useState(node.name);
        const isEditing = editingNodeId === node.id;
        
        const handleRename = (e) => { e.preventDefault(); if(editName.trim()) fileActions.rename(node.id, editName); setEditingNodeId(null); };
        
        return e(React.Fragment, null,
            e('div', { 
                className: 'file-tree-node', style: { paddingLeft: `${depth * 12 + 8}px`, display: 'flex', alignItems: 'center' },
                onClick: (e) => { e.stopPropagation(); node.type === 'folder' ? setIsOpen(!isOpen) : fileActions && useContext(AppContext).setActiveEditorFile(node); },
                onContextMenu: (e) => onContextMenu(e, node), 'data-active': activeEditorFile?.id === node.id
              },
              e('span', { className: 'file-tree-node-icon mr-1' }, node.type === 'folder' ? (isOpen ? 'ðŸ“‚' : 'ðŸ“') : 'ðŸ“„'),
              isEditing 
                ? e('form', { onSubmit: handleRename }, e('input', { className: 'form-input !p-0 !h-6 text-sm', value: editName, onChange: e => setEditName(e.target.value), onBlur: handleRename, autoFocus: true, onClick: e => e.stopPropagation() }))
                : e('span', { className: 'truncate' }, node.name)
            ),
            isOpen && node.children.map(child => e(FileNode, { key: child.id, node: child, depth: depth + 1, onContextMenu }))
        );
    };

    const FileManagerView = ({ viewId }) => {
        const { fileTree, fileActions, userId, setActiveEditorFile } = useContext(AppContext);
        const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, node: null });
        
        const handleContextMenu = (e, node) => {
            if(!userId) return;
            e.preventDefault(); e.stopPropagation();
            setContextMenu({ visible: true, x: e.clientX, y: e.clientY, node });
        };
        
        useEffect(() => { window.addEventListener('click', () => setContextMenu({ visible: false })); }, []);

        return e('div', { viewId, className: 'vsc-view-panes' },
            e('div', { className: 'vsc-view-pane' },
                e('div', { className: 'view-header' }, 'Files', 
                    userId && e('div', { className: 'flex gap-1' },
                        e('button', { className: 'view-header-icon', onClick: () => fileActions.create('root', 'folder') }, '+ðŸ“‚'),
                        e('button', { className: 'view-header-icon', onClick: () => fileActions.create('root', 'file') }, '+ðŸ“„')
                    )
                ),
                e('div', { className: 'vsc-view-pane-content' },
                    !userId && e('p', { className: 'p-4 text-sm text-gray-500 text-center' }, 'Login to access files'),
                    userId && fileTree.map(node => e(FileNode, { key: node.id, node, depth: 0, onContextMenu })),
                    userId && contextMenu.visible && e('div', { className: 'context-menu', style: { position: 'fixed', top: contextMenu.y, left: contextMenu.x, zIndex: 1000 } },
                         e('div', { className: 'context-menu-item p-2 cursor-pointer', onClick: () => fileActions.remove(contextMenu.node.id, contextMenu.node.type) }, 'Delete')
                    )
                )
            )
        );
    };

    const MarkdownViewer = ({ markdownText }) => {
        const viewerRef = useRef(null);
        const { contentHtml, footnotesHtml } = useMemo(() => {
            if (!markdownText) return { contentHtml: '', footnotesHtml: '' };
            const cleaned = FootnoteManager.extractAndClean(markdownText);
            let html = parseMarkdownWithExtensions(cleaned);
            let fnHtml = '';
            const fnOrder = FootnoteManager.getOrder();
            if (fnOrder.length > 0) {
                fnHtml += '<hr class="footnote-divider"><section class="footnotes"><ol>';
                fnOrder.forEach(name => {
                    const note = FootnoteManager.getNote(name);
                    if(note) fnHtml += `<li id="fn:${name}"><p>${note.html} <a href="#fnref:${name}" class="footnote-backref">â†©</a></p></li>`;
                });
                fnHtml += '</ol></section>';
            }
            return { contentHtml: window.DOMPurify.sanitize(html), footnotesHtml: window.DOMPurify.sanitize(fnHtml) };
        }, [markdownText]);
        
        useEffect(() => { if (viewerRef.current) applyPostRenderEffects(viewerRef.current); }, [contentHtml]);
        return e('div', { ref: viewerRef, className: 'prose-readable-wrapper prose-dark-theme' }, e('div', { className: 'prose-readable', dangerouslySetInnerHTML: { __html: contentHtml + footnotesHtml } }));
    };

    const MainContentEditor = () => {
        const { activeEditorFile, fileActions, dispatchTask, quizOptions, userId, handleGoogleSignIn } = useContext(AppContext);
        const [content, setContent] = useState("");
        const [mode, setMode] = useState('edit');
        const toast = useToast();
        
        useEffect(() => { setContent(activeEditorFile?.content || ""); setMode('edit'); }, [activeEditorFile]);
        useEffect(() => { 
            const timer = setTimeout(() => {
                if(activeEditorFile && content !== activeEditorFile.content) fileActions.updateContent(activeEditorFile.id, content);
            }, 1000);
            return () => clearTimeout(timer);
        }, [content, activeEditorFile]);

        if (!userId) return e('div', { className: 'main-editor-placeholder' }, e('p', { className: 'mb-4' }, 'Authentication Required'), e('button', { className: 'form-button', onClick: handleGoogleSignIn }, 'Sign In with Google'));
        if (!activeEditorFile) return e('div', { className: 'main-editor-placeholder' }, 'Select a file from the explorer');

        return e('div', { className: 'flex flex-col h-full' },
            e('div', { className: 'main-editor-header' },
                e('span', { className: 'main-editor-title' }, activeEditorFile.name),
                e('div', { className: 'editor-toggle-group mx-4' },
                    e('button', { className: `editor-toggle-btn ${mode==='edit'?'active':''}`, onClick: ()=>setMode('edit') }, 'EDIT'),
                    e('button', { className: `editor-toggle-btn ${mode==='view'?'active':''}`, onClick: ()=>setMode('view') }, 'PREVIEW')
                ),
                e('button', { className: 'main-editor-action-btn', onClick: () => dispatchTask({ taskType: 'generate', sourceText: content, options: { ...quizOptions, fileId: activeEditorFile.id, sourceFileName: activeEditorFile.name } }) }, 'Generate Quiz')
            ),
            mode === 'view' 
              ? e('div', { className: 'flex-1 overflow-auto bg-black' }, e(MarkdownViewer, { markdownText: content }))
              : e('textarea', { className: 'main-editor', value: content, onChange: e => setContent(e.target.value), spellCheck: false })
        );
    };

    const QuizGeneratorView = ({ viewId }) => {
        const { quizOptions, setQuizOptions } = useContext(AppContext);
        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, 'Generation Options'),
            e('div', { className: 'view-content-scroll p-4' },
                e('div', { className: 'form-group' }, e('label', { className: 'form-label' }, 'Question Count'), e('input', { type: 'number', className: 'form-input', value: quizOptions.numQuestions, onChange: e => setQuizOptions(o => ({...o, numQuestions: parseInt(e.target.value)})) })),
                e('div', { className: 'form-group' }, e('label', { className: 'form-label' }, 'Difficulty'), e('select', { className: 'form-select', value: quizOptions.difficulty, onChange: e => setQuizOptions(o => ({...o, difficulty: e.target.value})) }, e('option', { value: 'Easy' }, 'Easy'), e('option', { value: 'Medium' }, 'Medium'), e('option', { value: 'Hard' }, 'Hard'))),
                e('div', { className: 'form-group' }, e('label', { className: 'form-label' }, 'Type'), e('select', { className: 'form-select', value: quizOptions.questionType, onChange: e => setQuizOptions(o => ({...o, questionType: e.target.value})) }, e('option', { value: 'MultipleChoice' }, 'Multiple Choice'), e('option', { value: 'Essay' }, 'Essay')))
            )
        );
    };

    const QuizHistoryView = ({ viewId }) => {
        const { attempts, quizzes, setModalContent, dispatchGradingTask, userSettings, userId } = useContext(AppContext);
        if(!userId) return e('div', { viewId, className: 'p-4 text-center text-gray-500' }, 'Please Login');
        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, 'History'),
            e('div', { className: 'view-content-scroll p-4' },
                attempts.map(a => e('div', { 
                    key: a.id, className: 'list-item',
                    onClick: () => setModalContent(e(QuizResult, { attempt: a, onClose: () => setModalContent(null), dispatchGradingTask, userSettings }))
                }, e('div', { className: 'list-item-title' }, a.quizTitle), e('div', { className: 'list-item-sub' }, `Score: ${a.score}/${a.total}`)))
            )
        );
    };
    
    const QuizResult = ({ attempt, onClose, dispatchGradingTask, userSettings }) => {
        const results = JSON.parse(attempt.answers);
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', onClick: e => e.stopPropagation() },
                e('div', { className: 'modal-header' }, e('h2', null, 'Result: ' + attempt.quizTitle)),
                e('div', { className: 'modal-body' },
                    e('h3', { className: 'text-2xl font-light text-center mb-6' }, `${attempt.score} / ${attempt.total}`),
                    results.map((r, i) => e('div', { key: i, className: 'quiz-question-card mb-4' },
                        e('p', { className: 'font-medium mb-2' }, `${i+1}. ${r.questionText}`),
                        r.isCorrect === null 
                            ? e('p', { className: 'text-yellow-500 text-sm' }, 'Pending AI Grading...')
                            : e('div', null, 
                                e('p', { className: r.isCorrect ? 'text-green-400' : 'text-red-400' }, r.isCorrect ? 'Correct' : 'Incorrect'),
                                r.feedback && e('p', { className: 'text-sm text-gray-400 mt-1 bg-black bg-opacity-30 p-2 rounded' }, `AI: ${r.feedback}`)
                            )
                    ))
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: onClose }, 'Close'),
                    results.some(r => r.isCorrect === null) && e('button', { className: 'modal-button-primary', onClick: () => { dispatchGradingTask(attempt); onClose(); } }, 'Grade with AI')
                )
            )
        );
    };
    
    const TaskMonitorView = ({ viewId }) => {
        const { taskQueue } = useContext(AppContext);
        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, 'Background Tasks'),
            e('div', { className: 'view-content-scroll p-4' },
                taskQueue.map(t => e('div', { key: t.id, className: 'list-item' },
                    e('div', { className: 'list-item-title' }, t.taskType),
                    e('div', { className: 'list-item-sub' }, t.status === 'processing' ? 'Processing...' : t.status)
                ))
            )
        );
    };
    
    const SettingsModal = ({ onClose }) => {
        const { userSettings, saveSettings } = useContext(AppContext);
        const [key, setKey] = useState(userSettings?.apiKeys?.[0]?.key || "");
        const [model, setModel] = useState(userSettings?.modelName || "gemini-2.5-flash");
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', onClick: e => e.stopPropagation() },
                e('div', { className: 'modal-header' }, e('h2', null, 'Settings')),
                e('div', { className: 'modal-body' },
                    e('div', { className: 'form-group' }, e('label', { className: 'form-label' }, 'Gemini API Key'), e('input', { className: 'form-input', type: 'password', value: key, onChange: e => setKey(e.target.value) })),
                    e('div', { className: 'form-group' }, e('label', { className: 'form-label' }, 'Model Name'), e('input', { className: 'form-input', value: model, onChange: e => setModel(e.target.value) }))
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: onClose }, 'Cancel'),
                    e('button', { className: 'modal-button-primary', onClick: () => { saveSettings({ ...userSettings, apiKeys: [{ key, rpm: 60 }], modelName: model }); onClose(); } }, 'Save')
                )
            )
        );
    };

    const App = () => {
        const [db, setDb] = useState(null);
        const [auth, setAuth] = useState(null);
        const [userId, setUserId] = useState(null);
        const [userSettings, setUserSettings] = useState(DEFAULT_SETTINGS);
        const [files, setFiles] = useState([]);
        const [quizzes, setQuizzes] = useState([]);
        const [attempts, setAttempts] = useState([]);
        const [taskQueue, setTaskQueue] = useState([]);
        const [activeViewId, setActiveViewId] = useState('files');
        const [activeEditorFile, setActiveEditorFile] = useState(null);
        const [modalContent, setModalContent] = useState(null);
        const [editingNodeId, setEditingNodeId] = useState(null);
        const [quizOptions, setQuizOptions] = useState({ numQuestions: 5, difficulty: 'Medium', questionType: 'MultipleChoice' });
        
        const quizWorker = useMemo(() => new Worker(workerUrl), []);

        useEffect(() => {
            try {
                const c = JSON.parse(window.__firebase_config);
                const app = initializeApp(c);
                setDb(getFirestore(app));
                setAuth(getAuth(app));
                onAuthStateChanged(getAuth(app), u => setUserId(u ? u.uid : null));
            } catch(e) { console.error(e); }
        }, []);

        useEffect(() => {
            if(!db || !userId) return;
            const unsubF = onSnapshot(query(collection(db, `artifacts/${window.__app_id}/users/${userId}/files`)), s => setFiles(s.docs.map(d => ({id:d.id, ...d.data()}))));
            const unsubQ = onSnapshot(query(collection(db, `artifacts/${window.__app_id}/users/${userId}/quizzes`)), s => setQuizzes(s.docs.map(d => ({id:d.id, ...d.data()}))));
            const unsubA = onSnapshot(query(collection(db, `artifacts/${window.__app_id}/users/${userId}/quizAttempts`)), s => setAttempts(s.docs.map(d => ({id:d.id, ...d.data()}))));
            const unsubS = onSnapshot(doc(db, `artifacts/${window.__app_id}/users/${userId}/settings/userConfig`), s => s.exists() && setUserSettings(s.data()));
            return () => { unsubF(); unsubQ(); unsubA(); unsubS(); };
        }, [db, userId]);

        useEffect(() => {
            quizWorker.onmessage = (e) => {
                const { status, taskId, taskType, quizData, updatedAttempt } = e.data;
                setTaskQueue(q => q.map(t => t.id === taskId ? { ...t, status } : t));
                if(status === 'success' && taskType === 'generate') addDoc(collection(db, `artifacts/${window.__app_id}/users/${userId}/quizzes`), { ...quizData, userId, createdAt: new Date().toISOString() });
                if(status === 'success' && taskType === 'grade') updateDoc(doc(db, `artifacts/${window.__app_id}/users/${userId}/quizAttempts`, updatedAttempt.id), updatedAttempt);
            };
        }, [quizWorker, db, userId]);

        // Destructure custom hook results at the top level of the component
        const { fileTree, fileActions } = useFileSystem(files, db, userId, window.__app_id);

        const contextValue = {
            db, userId, 
            fileTree, 
            fileActions,
            activeEditorFile, setActiveEditorFile, dispatchTask: (data) => {
                const id = crypto.randomUUID();
                setTaskQueue(p => [{...data, id, status: 'processing'}, ...p]);
                quizWorker.postMessage({ ...data, id, settings: userSettings });
            },
            quizOptions, setQuizOptions, attempts, quizzes, setModalContent, userSettings,
            saveSettings: (s) => setDoc(doc(db, `artifacts/${window.__app_id}/users/${userId}/settings/userConfig`), s, {merge: true}),
            handleGoogleSignIn: () => signInWithPopup(auth, new GoogleAuthProvider()),
            handleSignOut: () => signOut(auth),
            editingNodeId, setEditingNodeId,
            dispatchGradingTask: (a) => {
                const id = crypto.randomUUID();
                setTaskQueue(p => [{taskType: 'grade', id, status: 'processing'}, ...p]);
                quizWorker.postMessage({ taskType: 'grade', id, attempt: a, settings: userSettings });
            }
        };

        const sidebarItems = [
            { id: 'files', icon: 'ðŸ“‚' }, { id: 'search', icon: 'ðŸ”' }, { id: 'quiz-generator', icon: 'âœ¨' },
            { id: 'history', icon: 'ðŸ“š' }, { id: 'tasks', icon: 'ðŸ“Š' }, { id: 'settings', icon: 'âš™ï¸', isBottom: true },
            { id: 'user', icon: 'ðŸ‘¤', isBottom: true }
        ];
        
        const handleActiveChange = (id) => {
            if (id === 'settings') setModalContent(e(SettingsModal, { onClose: () => setModalContent(null) }));
            else if (id === 'user' && userId) signOut(auth);
            else setActiveViewId(id);
        };

        return e(AppContext.Provider, { value: contextValue },
            e('div', { className: 'flex h-screen' },
                e(ReactVscodeSidebar, { items: sidebarItems, onActiveChange: handleActiveChange, activeId: activeViewId, isVisible: true },
                    e(FileManagerView, { viewId: 'files' }),
                    e(QuizGeneratorView, { viewId: 'quiz-generator' }),
                    e(QuizHistoryView, { viewId: 'history' }),
                    e(TaskMonitorView, { viewId: 'tasks' })
                ),
                e('div', { className: 'main-content' }, e(MainContentEditor)),
                modalContent
            )
        );
    };

    createRoot(document.getElementById('root')).render(e(ToastProvider, null, e(App)));
  </script>
</body>
</html>
