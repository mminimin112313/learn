<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- (v12.0) 타이틀 업데이트: 뷰어 모드 통합 -->
  <title>AI 퀴즈 VSCode (v12.0 - 뷰어 모드)</title>

  <!-- 1. 의존성 로드: React, Tailwind, JSZip, Firebase -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <!-- (v12.0) 뷰어 모드 의존성 추가 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

  <!-- 
    (v11.1) Firebase SDK 추가 (Google Auth 포함)
  -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { 
      getAuth, 
      signInAnonymously, 
      signInWithCustomToken, 
      onAuthStateChanged,
      GoogleAuthProvider,  // (v11.1) Google Auth Provider 추가
      signInWithPopup,     // (v11.1) 팝업 로그인 추가
      signOut              // (v11.1) 로그아웃 추가
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { 
      getFirestore, 
      doc, 
      getDoc, 
      getDocs,
      addDoc, 
      setDoc, 
      updateDoc, 
      deleteDoc, 
      onSnapshot, 
      collection, 
      query, 
      where, 
      writeBatch,
      setLogLevel
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // 전역 변수로 Firebase 모듈 할당
    window.firebase = {
      app: { initializeApp },
      auth: { 
        getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
        GoogleAuthProvider, signInWithPopup, signOut // (v11.1) 추가
      },
      firestore: { 
        getFirestore, doc, getDoc, getDocs, addDoc, setDoc, updateDoc, deleteDoc, 
        onSnapshot, collection, query, where, writeBatch, setLogLevel
      }
    };
  </script>

  <script>
    // 1. Firebase 프로젝트 설정 (Firebase 콘솔에서 복사)
    // 이 정보는 공개되어도 안전합니다. (보안은 '보안 규칙'으로 강제)
    const firebaseConfig = {
  apiKey: "AIzaSyBR_9ivOtQRIW_KIQRYBxJ_nFtYL7GYZwg",
  authDomain: "quiz-436ac.firebaseapp.com",
  projectId: "quiz-436ac",
  storageBucket: "quiz-436ac.firebasestorage.app",
  messagingSenderId: "131117093431",
  appId: "1:131117093431:web:56e1beff4c63d35b5b25b2"
};

    
    // 2. 앱 ID (데이터 분리용)
    const appId = "my-unique-app-id"; // (예: "ai-quiz-project")

    // 3. (선택) 커스텀 인증 토큰 (서버에서 발급받아야 함)
    // const initialAuthToken = "eyJhbGciOi...YOUR_CUSTOM_TOKEN";

    // --- 앱에서 사용할 전역 변수로 설정 ---
    window.__firebase_config = JSON.stringify(firebaseConfig);
    window.__app_id = appId;
    // if (initialAuthToken) {
    //   window.__initial_auth_token = initialAuthToken;
    // }
  </script>
  
  <!-- 2. 스타일 -->
  <style>
    /* (v12.0) 나눔고딕, 나눔명조 웹 폰트 불러오기 */
    @import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&family=Nanum+Myeongjo:wght@400;700;800&display=swap');

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
        Helvetica, Arial, sans-serif;
      margin: 0;
      background-color: #1e1e1e;
      color: #cccccc;
      height: 100vh;
      overflow: hidden;
    }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #252526; }
    ::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #5a5a5a; }
    .vsc-sidebar-container {
      display: flex;
      flex-direction: row;
      width: auto;
      height: 100vh;
    }
    .vsc-activity-bar {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 8px 0;
      background-color: #333333;
      color: white;
      flex-shrink: 0;
      width: 52px;
    }
    .vsc-activity-item {
      background-color: transparent;
      border: none;
      color: #b0b0b0;
      padding: 12px;
      margin: 2px 4px;
      cursor: pointer;
      font-size: 24px;
      line-height: 1;
      border-radius: 4px;
      transition: background-color 0.2s, color 0.2s;
    }
    .vsc-activity-item:hover { background-color: #404040; }
    .vsc-activity-item[data-active='true'] {
      color: #ffffff;
      background-color: #4a4a4a;
    }
    .vsc-sidebar-view {
      flex-grow: 1;
      overflow-y: auto;
      background-color: #252526;
      color: #cccccc;
      width: 300px;
      min-width: 300px;
      border-right: 1px solid #444;
      transition: min-width 0.2s ease-out, width 0.2s ease-out;
      overflow: hidden;
    }
    .vsc-sidebar-view[data-visible='false'] {
      width: 0px;
      min-width: 0px;
      border-right: none;
    }
    .vsc-view-content {
      height: 100%;
      min-width: 300px;
      display: flex;
      flex-direction: column;
    }
    .view-padding {
        padding: 16px;
    }
    .view-header {
      margin-top: 0;
      color: #cccccc;
      font-size: 1.1rem;
      font-weight: 600;
      padding: 12px 16px;
      border-bottom: 1px solid #444;
      flex-shrink: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .view-header-icon {
        background: none; border: none; color: #b0b0b0; cursor: pointer;
        padding: 4px; border-radius: 4px;
    }
    .view-header-icon:hover { background-color: #4a4a4a; color: white; }
    .view-content-scroll {
        flex-grow: 1;
        overflow-y: auto;
        padding: 16px;
    }
    .view-content-full {
        flex-grow: 1;
        overflow-y: auto;
    }
    .vsc-view-panes {
        display: flex;
        flex-direction: column;
        height: 100%;
    }
    .vsc-view-pane {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    .vsc-view-pane-header {
        padding: 4px 12px;
        background-color: #333;
        font-size: 0.9rem;
        font-weight: 500;
        border-top: 1px solid #444;
        border-bottom: 1px solid #444;
    }
    .vsc-view-pane-content {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
    }
    .vsc-view-pane-content.full {
        padding: 0;
    }
    .vsc-view-pane-content.full[data-drag-over='true'] {
        background-color: #0e639c;
    }
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .main-editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background-color: #252526;
        border-bottom: 1px solid #444;
        flex-shrink: 0;
    }
    .main-editor-title {
        font-size: 0.9rem;
    }
    /* (v12.0) 편집/보기 토글 버튼 스타일 */
    .editor-toggle-group {
        display: inline-flex;
        border: 1px solid #444;
        border-radius: 4px;
        overflow: hidden;
    }
    .editor-toggle-btn {
        background-color: #333;
        color: #b0b0b0;
        padding: 4px 10px;
        border: none;
        cursor: pointer;
        font-size: 0.85rem;
        transition: background-color 0.2s, color 0.2s;
    }
    .editor-toggle-btn:not(:last-child) {
        border-right: 1px solid #444;
    }
    .editor-toggle-btn.active {
        background-color: #4a4a4a;
        color: #ffffff;
    }
    .editor-toggle-btn:hover:not(.active) {
        background-color: #404040;
    }

    .main-editor-action-btn {
        background-color: #0e639c;
        color: white;
        padding: 4px 10px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
    }
    .main-editor-action-btn:hover { background-color: #1177bb; }
    .main-editor-action-btn:disabled { background-color: #555; cursor: not-allowed; }
    
    .main-editor {
      flex-grow: 1;
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: none;
      outline: none;
      padding: 20px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      line-height: 1.5;
      resize: none;
    }
    /* (v12.0) 뷰어 래퍼 스타일 */
    .prose-readable-wrapper {
        flex-grow: 1;
        overflow-y: auto;
        padding: 20px;
    }

    .main-editor.\!p-4 {
        padding: 1rem;
    }
    .main-editor-placeholder {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: #6a6a6a;
      font-size: 1.2rem;
    }
    .main-editor-footer {
        padding: 4px 12px;
        background-color: #252526;
        border-top: 1px solid #444;
        flex-shrink: 0;
        font-size: 0.8rem;
        color: #a0a0a0;
        text-align: right;
        min-height: 26px;
    }
    .form-group { margin-bottom: 16px; }
    .form-label {
        display: block;
        font-size: 0.9rem;
        margin-bottom: 6px;
        color: #a0a0a0;
        font-weight: 500;
    }
    .form-input, .form-textarea, .form-select {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      border: 1px solid #444;
      background-color: #3c3c3c;
      color: #cccccc;
      border-radius: 4px;
    }
    .form-textarea {
        font-family: 'Courier New', Courier, monospace;
    }
    .form-input.\!p-0.\!text-sm {
        padding: 0;
        font-size: 0.875rem;
    }
    .form-select {
        appearance: none;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239ca3af' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 0.5rem center;
        background-size: 1.2em 1.2em;
        padding-right: 2.5rem;
    }
    .form-checkbox-label {
        display: flex;
        align-items: center;
        font-size: 0.9rem;
        color: #cccccc;
        cursor: pointer;
    }
    .form-checkbox {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        background-color: #3c3c3c;
        border: 1px solid #444;
        border-radius: 3px;
    }
    .form-button {
      background-color: #0e639c;
      color: white;
      width: 100%;
      padding: 10px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      font-weight: 600;
    }
    .form-button:hover { background-color: #1177bb; }
    .form-button:disabled { background-color: #555; cursor: not-allowed; }
    .list-item {
      padding: 10px;
      background-color: #3c3c3c;
      border-radius: 4px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .list-item:hover { background-color: #4a4a4a; }
    .list-item-title { font-weight: 600; }
    .list-item-sub { font-size: 0.8rem; color: #a0a0a0; }
    .list-item-badge {
        font-size: 0.8rem;
        padding: 2px 6px;
        border-radius: 10px;
        background-color: #4a90e2;
        color: white;
    }
    .list-item-badge.success { background-color: #4CAF50; }
    .list-item-badge.error { background-color: #f44336; }
    .quiz-question-card { margin-bottom: 1.5rem; }
    .quiz-question-text { font-weight: 600; font-size: 1.1rem; margin-bottom: 0.75rem; }
    .quiz-option-label {
        display: block;
        padding: 10px;
        background-color: #3c3c3c;
        border-radius: 4px;
        margin-bottom: 8px;
        cursor: pointer;
    }
    .quiz-option-label:hover { background-color: #4a4a4a; }
    .quiz-option-label input { margin-right: 10px; }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .modal-container {
      background-color: #2d2d2d;
      color: #cccccc;
      border-radius: 8px;
      width: 90%;
      max-width: 700px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .modal-header {
      padding: 16px 24px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 { margin: 0; font-size: 1.2rem; }
    .modal-close-btn {
      background: none; border: none; color: #a0a0a0; font-size: 1.5rem;
      cursor: pointer; padding: 0; line-height: 1;
    }
    .modal-body {
      padding: 0;
      overflow-y: auto;
      display: flex;
      flex-grow: 1;
    }
    .modal-footer {
      padding: 16px 24px;
      border-top: 1px solid #444;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }
    .modal-button {
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }
    .modal-button-primary {
      background-color: #0e639c; color: white; border: none;
    }
    .modal-button-primary:hover { background-color: #1177bb; }
    .modal-button-secondary {
      background-color: #4a4a4a; color: #cccccc; border: none;
    }
    .modal-button-secondary:hover { background-color: #5a5a5a; }
    .settings-nav {
      width: 200px;
      flex-shrink: 0;
      padding: 24px 0;
      border-right: 1px solid #444;
    }
    .settings-nav-item {
      padding: 10px 24px;
      cursor: pointer;
      font-size: 0.9rem;
      border-left: 3px solid transparent;
    }
    .settings-nav-item:hover { background-color: #3c3c3c; }
    .settings-nav-item[data-active='true'] {
      background-color: #3c3c3c;
      border-left-color: #0e639c;
      color: white;
    }
    .settings-content {
      padding: 24px;
      flex-grow: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    .api-key-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        background-color: #3c3c3c;
        border-radius: 4px;
        margin-bottom: 8px;
    }
    .api-key-delete-btn {
        background: #f44336; color: white; border: none;
        border-radius: 4px; padding: 4px 8px; font-size: 0.8rem;
        cursor: pointer;
    }
    .quiz-result-body { padding: 24px; }
    .quiz-result-score { font-size: 2rem; font-weight: bold; text-align: center; }
    .result-question {
        padding: 12px;
        border-radius: 4px;
        margin-bottom: 8px;
    }
    .result-question-correct { background-color: #3a4a3a; }
    .result-question-incorrect { background-color: #5a3a3a; }
    .bg-gray-700 { background-color: #3c3c3c; } 
    .result-question-text { font-weight: 600; margin-bottom: 4px; }
    .result-answer { font-size: 0.9rem; }
    .result-answer.correct { color: #81c784; }
    .result-answer.yours { color: #ffb74d; }
    .bg-gray-800 { background-color: #252526; }
    .text-blue-300 { color: #9cdcfe; }
    .file-manager-container {
        height: 100%;
        font-size: 14px;
    }
    .file-tree-list { padding: 8px; }
    .file-tree-node {
        display: flex;
        align-items: center;
        padding: 4px 8px;
        cursor: pointer;
        border-radius: 4px;
    }
    .file-tree-node:hover { background-color: #3c3c3c; }
    .file-tree-node[data-active='true'] { background-color: #094771; }
    .file-tree-node[data-drag-over='true'] {
        background-color: #0e639c;
    }
    .file-tree-node-icon { margin-right: 6px; }
    .context-menu {
      position: fixed;
      z-index: 1000;
      background-color: #252526;
      border: 1px solid #37373d;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      padding: 4px 0;
      min-width: 150px;
    }
    .context-menu-item {
      padding: 6px 12px;
      font-size: 0.9rem;
      cursor: pointer;
    }
    .context-menu-item:hover {
      background-color: #094771;
    }
    .context-menu-item-delete {
      color: #f48771;
    }
    .context-menu-divider {
      border-top: 1px solid #37373d;
      margin: 4px 0;
    }
    .spinner-overlay {
      position: absolute; inset: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex; justify-content: center; align-items: center;
      z-index: 50;
    }
    .spinner-overlay.\!relative { position: relative; }
    .spinner-overlay.\!h-10 { height: 2.5rem; }
    .spinner-overlay.\!bg-transparent { background-color: transparent; }
    .spinner {
      border: 4px solid #f3f3f3; border-top: 4px solid #0e639c;
      border-radius: 50%; width: 40px; height: 40px;
      animation: spin 1s linear infinite;
    }
    .spinner.\!w-6 { width: 1.5rem; }
    .spinner.\!h-6 { height: 1.5rem; }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1001;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .toast-item {
      padding: 12px 16px;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: toast-fade-in 0.3s ease-out;
    }
    .toast-item.success {
      background-color: #4CAF50;
    }
    .toast-item.error {
      background-color: #f44336;
    }
    .toast-item.info {
      background-color: #0e639c;
    }
    @keyframes toast-fade-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    .bg-gray-600 { background-color: #4a4a4a; }
    .text-gray-400 { color: #a0a0a0; }


    /* ================================================================== */
    /* ▼▼▼ (v12.0) 뷰어 모드 타이포그래피 스타일 (다크 모드 최적화) ▼▼▼ */
    /* ================================================================== */

    .prose-readable-wrapper {
        /* KaTeX 폰트가 깨지지 않도록 기본 폰트 재정의 */
        font-family: 'Nanum Myeongjo', serif;
    }

    /* --- 다크 모드용 뷰어 스타일 --- */
    .prose-dark-theme {
        --text-primary: #ffffff;
        --text-secondary: #cccccc;
        --text-tertiary: #94a3b8; 
        --border-color: #334155;
        --accent-primary: #9cdcfe;
        --accent-primary-hover: #0e639c;
        --bg-tertiary: #252526;
        --bg-hover: #334155;
    }

    /* --- 전체적인 텍스트 렌더링 최적화 --- */
    .prose-readable {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        font-feature-settings: "kern" on, "liga" on;
        text-rendering: optimizeLegibility;
        max-width: 800px; /* 읽기 편한 최대 너비 설정 */
        margin-left: auto;
        margin-right: auto;
    }

    /* --- 제목 (Headings) --- */
    .prose-readable h1,
    .prose-readable h2,
    .prose-readable h3,
    .prose-readable h4 {
        font-family: 'Nanum Gothic', sans-serif;
        color: var(--text-primary);
        margin-top: 2em;
        margin-bottom: 0.7em;
        letter-spacing: -0.025em;
        word-break: keep-all;
    }
    .prose-readable h1 {
        font-size: 2.2em; font-weight: 800; padding-bottom: 0.4em;
        border-bottom: 2px solid var(--border-color);
    }
    .prose-readable h2 {
        font-size: 1.7em; font-weight: 700; padding-bottom: 0.4em;
        border-bottom: 1px solid var(--border-color);
    }
    .prose-readable h3 { font-size: 1.4em; font-weight: 700; border: none; }
    .prose-readable h4 { font-size: 1.2em; font-weight: 700; color: var(--text-secondary); }

    /* --- 본문 (Paragraphs) --- */
    .prose-readable p {
        font-family: 'Nanum Myeongjo', serif;
        color: var(--text-secondary);
        font-size: 1.1em; /* 폰트 크기 살짝 키움 */
        line-height: 1.85;
        letter-spacing: -0.015em;
        word-spacing: 0.05em;
        text-align: justify;
        word-break: keep-all;
        margin-bottom: 1.2em;
    }

    /* --- 강조 (Strong) --- */
    .prose-readable strong {
        color: var(--text-primary);
        font-weight: 700;
    }

    /* --- 링크 (Links) --- */
    .prose-readable a {
        color: var(--accent-primary);
        text-decoration: none;
        border-bottom: 1px solid var(--accent-primary);
        font-weight: 600;
        transition: all 0.2s ease-in-out;
    }
    .prose-readable a:hover {
        color: white;
        background-color: var(--accent-primary-hover);
        border-bottom-color: transparent;
    }

    /* --- 인용문 (Blockquotes) --- */
    .prose-readable blockquote {
        border-left: 3px solid var(--accent-primary);
        padding: 0.5em 1.2em;
        margin: 1.5em 0;
        color: var(--text-tertiary);
        background-color: var(--bg-tertiary);
        font-style: normal;
    }
    .prose-readable blockquote p { font-size: 1em; line-height: 1.7; }

    /* --- 코드 (Code) & 테이블 (Table) --- */
    .prose-readable code {
        background-color: var(--bg-hover);
        color: var(--accent-primary);
        padding: 0.2em 0.5em;
        margin: 0 0.1em;
        font-size: 85%;
        border-radius: 6px;
        font-family: 'D2Coding', 'Courier New', Courier, monospace;
    }
    .prose-readable table {
        width: 100%; border-collapse: collapse; margin: 2em 0;
        font-size: 0.9em; border: 1px solid var(--border-color);
    }
    .prose-readable th, .prose-readable td {
        border: 1px solid var(--border-color); padding: 0.8em 1em; text-align: left;
    }
    .prose-readable th {
        font-family: 'Nanum Gothic', sans-serif; font-weight: 700;
        background-color: var(--bg-tertiary);
    }

    /* --- 목록 (Lists) --- */
    .prose-readable ul, .prose-readable ol {
        list-style-position: outside; padding-left: 2em; margin-bottom: 1.2em;
    }
    .prose-readable ul { list-style-type: disc; }
    .prose-readable ol { list-style-type: decimal; }
    .prose-readable li { margin-bottom: 0.8em; padding-left: 0.5em; }
    .prose-readable li > p { margin-top: 0; margin-bottom: 0; }
    .prose-readable li ul, .prose-readable li ol { margin-top: 0.8em; }
        
    /* --- 하이라이트 (Highlights) --- */
    .prose-readable mark {
        background-color: rgba(250, 204, 21, 0.4);
        color: inherit;
    }
    /* 다크모드에선 하이라이트 배경을 더 선명하게 */
    .prose-dark-theme .prose-readable mark {
        background-color: rgba(234, 179, 8, 0.5);
    }

    /* --- 각주 (Footnotes) --- */
    .prose-readable .footnote-ref {
        font-size: 0.8em; vertical-align: super; line-height: 0;
    }
    .prose-readable .footnote-ref a {
        border: none !important; background-color: transparent !important;
        text-decoration: none !important; font-weight: normal;
        color: var(--accent-primary);
        padding: 0.1em 0.2em; margin: 0 0.1em; border-radius: 4px;
        cursor: help; transition: background-color 0.2s, color 0.2s;
    }
    .prose-readable .footnote-ref a:hover {
        background-color: var(--accent-primary-hover) !important;
        color: white !important;
    }
    .prose-readable .footnote-divider {
        margin-top: 4em; border-color: var(--border-color);
    }
    .prose-readable .footnotes {
        margin-top: 2em; font-size: 0.9em; color: var(--text-tertiary);
    }
    .prose-readable .footnotes li {
        display: flex; align-items: baseline; margin-bottom: 0.8em; line-height: 1.6;
    }
    .prose-readable .footnotes li p {
        font-size: 1em; line-height: inherit; display: inline;
    }
    .prose-readable .footnote-backref {
        font-size: 1.1em; text-decoration: none; margin-left: 0.5em;
        border: none !important; background: none !important; padding: 0 4px;
    }
    .prose-readable .footnote-backref:hover {
        background-color: var(--bg-hover) !important;
        border-radius: 4px;
    }

  </style>
</head>
<body>
  
  <div id="root"></div>
  <input type="file" id="file-upload-input" style="display: none" multiple accept=".txt,.md,.zip" />
  <input type="file" id="project-import-input" style="display: none" accept=".json" />


  <!-- 3. React 애플리케이션 스크립트 -->
  <script type="module">
    const { 
      useState, 
      useEffect, 
      useCallback, 
      useMemo,
      createContext,
      useContext,
      useRef // (v11.1) 추가
    } = React;
    const { createRoot } = ReactDOM;
    const e = React.createElement;

    // (v11.1) Firebase 모듈 전역 접근 (Google Auth 포함)
    const { app, auth, firestore } = window.firebase;
    const { initializeApp } = app;
    const { 
        getAuth, 
        signInAnonymously, 
        signInWithCustomToken, 
        onAuthStateChanged,
        GoogleAuthProvider, 
        signInWithPopup, 
        signOut
    } = auth;
    const { 
        getFirestore, doc, getDoc, getDocs, addDoc, setDoc, updateDoc, deleteDoc, 
        onSnapshot, collection, query, where, writeBatch, setLogLevel
    } = firestore;

    const ToastContext = createContext(null);
    const useToast = () => useContext(ToastContext);
    
    const AppContext = createContext(null);
    
    // --- (v12.0) 뷰어 모드 로직 (From index (1).html) ---

    const FootnoteManager = {
        footnotes: {},
        footnoteOrder: [],
        
        clear() {
            this.footnotes = {};
            this.footnoteOrder = [];
        },
    
        addDefinition(key, content) {
            const lowerKey = key.toLowerCase();
            if (!this.footnotes[lowerKey]) {
                const trimmedContent = content.trim().replace(/\n/g, ' ');
                // marked.parseInline 사용 (window.marked)
                const inlineHtml = window.marked.parseInline(trimmedContent);
                this.footnotes[lowerKey] = {
                    text: trimmedContent,
                    html: inlineHtml
                };
            }
        },
    
        addReference(key) {
            const lowerKey = key.toLowerCase();
            if (this.footnoteOrder.indexOf(lowerKey) === -1) {
                this.footnoteOrder.push(lowerKey);
            }
        },
        
        getNote(key) {
            return this.footnotes[key.toLowerCase()];
        },
        
        getOrder() {
            return this.footnoteOrder;
        },
    
        extractAndClean(markdown) {
            // 렌더링 파이프라인의 일부이므로, 매번 clear()를 호출해야 함
            this.clear(); 
            const footnoteDefRegex = /^\[\^(.+?)\]:\s*([\s\S]*?)(?=\n\[\^|$)/gm;
    
            const cleanedMarkdown = markdown.replace(footnoteDefRegex, (match, name, content) => {
                this.addDefinition(name, content);
                return ''; // 원본 텍스트에서 각주 정의 부분 제거
            });
            
            return cleanedMarkdown;
        }
    };

    /**
     * (v12.0) 1차 파싱 (Markdown -> HTML)
     * marked.js에 커스텀 확장(수학, 하이라이트, 각주 참조)을 추가하여 Markdown을 HTML로 변환합니다.
     */
    const parseMarkdownWithExtensions = (markdownText) => {
        if (typeof markdownText !== 'string') return '';
        if (!window.marked) {
            console.error("marked.js가 로드되지 않았습니다.");
            return markdownText; // fallback
        }

        const isolatedParser = new window.marked.Marked();
        
        const mathExtension = {
            name: 'math',
            level: 'inline', 
            start(src) { return src.indexOf('$'); },
            tokenizer(src) {
                const blockRule = /^\$\$([\s\S]+?)\$\$/;
                let match = blockRule.exec(src);
                if (match) {
                    return { type: 'math', raw: match[0], text: match[1], displayMode: true };
                }
                if (!src.startsWith('$$')) {
                    const inlineRule = /^\$((?:[^$]|\\[$])+?)\$/;
                    match = inlineRule.exec(src);
                    if (match) {
                        return { type: 'math', raw: match[0], text: match[1], displayMode: false };
                    }
                }
            },
            renderer(token) {
                return token.raw; // KaTeX가 처리할 수 있도록 원본 보존
            }
        };

        const highlightExtension = {
            name: 'highlight',
            level: 'inline',
            start(src) { return src.indexOf('=='); },
            tokenizer(src) {
                const rule = /^==(.+?)==/;
                const match = rule.exec(src);
                if (match) {
                    return { type: 'highlight', raw: match[0], text: this.lexer.inlineTokens(match[1].trim()) };
                }
            },
            renderer(token) { return `<mark>${this.parser.parseInline(token.text)}</mark>`; },
        };

        const footnoteRefExtension = {
            name: 'footnoteRef',
            level: 'inline',
            start(src) { return src.indexOf('[^'); },
            tokenizer(src) {
                const rule = /^\[\^((?:[^\]\\]|\\.)+)\](?!:)/; // :가 뒤따르지 않는 참조만
                const match = rule.exec(src);
                if (match) {
                    FootnoteManager.addReference(match[1]);
                    return { type: 'footnoteRef', raw: match[0], name: match[1] };
                }
            },
            renderer(token) {
                const name = token.name;
                const order = FootnoteManager.getOrder();
                const note = FootnoteManager.getNote(name);
                const index = order.indexOf(name.toLowerCase()) + 1;
                const finalIndex = index > 0 ? index : '?';
                let tooltipContent = note ? (note.text || '').replace(/"/g, '&quot;').replace(/\n/g, ' ') : '각주 내용을 찾을 수 없습니다.';
                
                return `<sup id="fnref:${name}" class="footnote-ref"><a href="#fn:${name}" data-footnote-key="${name}" title="${tooltipContent}">${finalIndex}</a></sup>`;
            }
        };
        
        isolatedParser.use({ gfm: true, breaks: true, extensions: [mathExtension, highlightExtension, footnoteRefExtension] });

        return isolatedParser.parse(markdownText);
    };

    /**
     * (v12.0) 2차 후처리 (DOM)
     * 1차 파싱된 HTML이 DOM에 삽입된 후, 수동으로 **bold**를 처리하고 KaTeX 렌더링을 실행합니다.
     */
    const applyPostRenderEffects = (element) => {
        if (!element) return;
        
        // 1단계: **bold** 처리를 DOM에 직접 적용
        const processTextNode = (textNode) => {
            const fragment = document.createDocumentFragment();
            let currentText = textNode.textContent;
            let lastIndex = 0;
            currentText.replace(/\*\*(.*?)\*\*/g, (match, content, offset) => {
                if (offset > lastIndex) fragment.appendChild(document.createTextNode(currentText.substring(lastIndex, offset)));
                const strong = document.createElement('strong');
                strong.textContent = content;
                fragment.appendChild(strong);
                lastIndex = offset + match.length;
            });
            if (lastIndex < currentText.length) fragment.appendChild(document.createTextNode(currentText.substring(lastIndex)));
            return fragment;
        };

        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, (node) => {
            const parentName = node.parentNode.nodeName.toLowerCase();
            // KaTeX, 코드, 링크, 이미 렌더링된 태그 등은 제외
            return ['code', 'pre', 'script', 'style', 'a', 'strong', 'em', 'sup', 'mark', 'span', 'textarea', 'input'].includes(parentName) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
        });

        const nodesToProcess = [];
        while (walker.nextNode()) nodesToProcess.push(walker.currentNode);

        nodesToProcess.forEach(textNode => {
            if (textNode.textContent.includes('**')) {
                const newContent = processTextNode(textNode);
                if (textNode.parentNode) {
                    textNode.parentNode.replaceChild(newContent, textNode);
                }
            }
        });
        
        // 2단계: KaTeX 렌더링 실행
        if (window.renderMathInElement) {
            try {
                window.renderMathInElement(element, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ]
                });
            } catch (e) {
                console.error("KaTeX 렌더링 실패:", e);
            }
        }
    };


    // --- 1. AI Gemini API 호출 (v10.1과 동일) ---

    const QUIZ_SCHEMA = {
      type: "OBJECT",
      properties: {
        title: { type: "STRING" },
        questions: {
          type: "ARRAY",
          items: {
            type: "OBJECT",
            properties: {
              questionType: { type: "STRING" },
              questionText: { type: "STRING" },
              options: { type: "ARRAY", items: { "type": "STRING" }, nullable: true },
              correctAnswerIndex: { type: "NUMBER", nullable: true },
              gradingCriteria: { type: "STRING", nullable: true },
            },
            required: ["questionType", "questionText"]
          }
        }
      },
      required: ["title", "questions"]
    };
    
    const GRADING_SCHEMA = {
      type: "OBJECT",
      properties: {
        isCorrect: { type: "BOOLEAN", description: "채점 기준에 따라 정답이면 true, 오답이면 false" },
        feedback: { type: "STRING", description: "사용자의 답변에 대한 구체적인 첨삭 내용" }
      },
      required: ["isCorrect", "feedback"]
    };
    
    class ApiError extends Error {
      constructor(message, status) { super(message); this.name = 'ApiError'; this.status = status; }
    }
    const fetchWithRetry = async (url, options, retries = 3, delay = 1000) => {
      for (let i = 0; i < retries; i++) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            if (response.status === 429) throw new ApiError('Rate limit exceeded', response.status);
            throw new ApiError(`HTTP error! status: ${response.status}`, response.status);
          }
          return response.json();
        } catch (error) {
          if (error.status === 429 && i < retries - 1) {
            await new Promise(res => setTimeout(res, delay * Math.pow(2, i)));
          } else { throw error; }
        }
      }
      throw new Error('API call failed after all retries');
    };
    
    const generateQuizWithAi = async (sourceText, options, settings) => {
      const { numQuestions, difficulty, questionType, includeSnippets, provideAnswerKey, customInstructions } = options;
      const apiKeys = settings?.apiKeys || [{ key: "", rpm: 60 }]; 
      const keyIndex = Date.now() % apiKeys.length; 
      const selectedKey = apiKeys[keyIndex];
      const apiKey = selectedKey.key.trim() ? selectedKey.key.trim() : "";
      const model = settings?.modelName || DEFAULT_SETTINGS.modelName; // (v12.0) DEFAULT_SETTINGS.modelName 사용
      
      if (!apiKey) {
          throw new ApiError('API 키가 설정되지 않았습니다. [설정(⚙️) > API Keys]에서 유효한 키를 추가하십시오.', 401); 
      }

      // (v12.0) CORS 오류 수정: generativelace -> generativelanguage
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      
      let systemPrompt = settings.quizSystemPrompt || DEFAULT_SETTINGS.quizSystemPrompt;
      
      systemPrompt = systemPrompt
          .replace('{{DIFFICULTY}}', difficulty)
          .replace('{{QUESTION_TYPE}}', questionType)
          .replace('{{INCLUDE_SNIPPETS}}', includeSnippets ? "Include relevant code snippets from the text if applicable." : "")
          .replace('{{PROVIDE_ANSWER_KEY}}', provideAnswerKey ? "Ensure correct answers are provided." : "")
          .replace('{{CUSTOM_INSTRUCTIONS}}', customInstructions ? `Additional Instructions: ${customInstructions}` : "")
          .replace('{{NUM_QUESTIONS}}', numQuestions);
          
      const userQuery = `--- SOURCE TEXT ---
${sourceText}
--- END SOURCE TEXT ---
`;

      const payload = {
        contents: [{ role: "user", parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: QUIZ_SCHEMA,
          temperature: 0.3,
        }
      };

      try {
        const result = await fetchWithRetry(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const candidate = result.candidates?.[0];
        if (candidate && candidate.content?.parts?.[0]?.text) {
          return JSON.parse(candidate.content.parts[0].text);
        } else {
          const errorReason = candidate?.finishReason || "Unknown error";
          throw new Error(`AI가 유효한 퀴즈를 생성하지 못했습니다. (Reason: ${errorReason})`);
        }
      } catch (error) {
        console.error("AI 퀴즈 생성 오류:", error);
        throw new Error(`AI 퀴즈 생성 실패: ${error.message}`);
      }
    };
    
    const gradeAnswerWithAi = async (questionText, userAnswer, gradingCriteria, settings) => {
      const apiKeys = settings?.apiKeys || [{ key: "", rpm: 60 }]; 
      const keyIndex = Date.now() % apiKeys.length; 
      const selectedKey = apiKeys[keyIndex];
      const apiKey = selectedKey.key.trim() ? selectedKey.key.trim() : "";
      const model = settings?.modelName || DEFAULT_SETTINGS.modelName; // (v12.0) DEFAULT_SETTINGS.modelName 사용

      if (!apiKey) {
        throw new ApiError('API 키가 설정되지 않았습니다. [설정(⚙️) > API Keys]에서 유효한 키를 추가하십시오.', 401);
      }
      
      // (v12.0) CORS 오류 수정: generativelace -> generativelanguage
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      
      const systemPrompt = settings.gradingSystemPrompt || DEFAULT_SETTINGS.gradingSystemPrompt;
      
      const userQuery = `--- QUESTION ---
${questionText}

--- GRADING CRITERIA (Rubric) ---
${gradingCriteria}

--- USER'S ANSWER ---
${userAnswer}
--- END OF DATA ---

Please grade the "USER'S ANSWER" based *only* on the "GRADING CRITERIA" and provide feedback.
`;

      const payload = {
        contents: [{ role: "user", parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: GRADING_SCHEMA,
          temperature: 0.1
        }
      };

      try {
        const result = await fetchWithRetry(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const candidate = result.candidates?.[0];
        if (candidate && candidate.content?.parts?.[0]?.text) {
          return JSON.parse(candidate.content.parts[0].text);
        } else {
          const errorReason = candidate?.finishReason || "Unknown error";
          throw new Error(`AI가 채점을 생성하지 못했습니다. (Reason: ${errorReason})`);
        }
      } catch (error) {
        console.error("AI 채점 오류:", error);
        throw new Error(`AI 채점 실패: ${error.message}`);
      }
    };
    
    // --- 2. Web Worker (v10.1과 동일) ---
    const workerScript = `
      const fetchWithRetry = ${fetchWithRetry.toString()};
      ${ApiError.toString()}
      const generateQuizWithAi = ${generateQuizWithAi.toString()};
      const QUIZ_SCHEMA = ${JSON.stringify(QUIZ_SCHEMA)};
      
      const gradeAnswerWithAi = ${gradeAnswerWithAi.toString()};
      const GRADING_SCHEMA = ${JSON.stringify(GRADING_SCHEMA)};

      const handleAsyncGrading = async (attempt, settings, DEFAULT_SETTINGS) => {
          const results = JSON.parse(attempt.answers);
          
          const gradingPromises = results.map(async (originalResult) => {
              if (originalResult.isCorrect !== null) {
                  return originalResult;
              }
              try {
                  const gradeData = await gradeAnswerWithAi(
                      originalResult.questionText,
                      originalResult.selectedAnswer,
                      originalResult.gradingCriteria,
                      { ...DEFAULT_SETTINGS, ...settings }
                  );
                  return {
                      ...originalResult,
                      isCorrect: gradeData.isCorrect,
                      feedback: gradeData.feedback
                  };
              } catch (error) {
                  console.error("AI 개별 채점 오류 (Worker):", error);
                  return {
                      ...originalResult,
                      isCorrect: false,
                      feedback: \`AI 채점 실패: \${error.message}\`
                  };
              }
          });

          const newResults = await Promise.all(gradingPromises);
          
          let newScore = 0;
          newResults.forEach(r => {
              if (r.isCorrect === true) newScore++;
          });

          const updatedAttempt = {
              ...attempt,
              score: newScore,
              answers: JSON.stringify(newResults)
          };
          
          return updatedAttempt;
      };

      self.onmessage = async (e) => {
        const { id: taskId, taskType, sourceText, options, settings, DEFAULT_SETTINGS, attempt } = e.data;
        
        try {
          if (taskType === 'grade') {
            const updatedAttempt = await handleAsyncGrading(attempt, settings, DEFAULT_SETTINGS);
            self.postMessage({ 
                status: 'success', 
                taskId, 
                taskType, 
                updatedAttempt,
                options: { quizTitle: attempt.quizTitle }
            });
            
          } else {
            const quizData = await generateQuizWithAi(sourceText, options, { ...DEFAULT_SETTINGS, ...settings });
            self.postMessage({ 
                status: 'success', 
                taskId, 
                taskType, 
                quizData, 
                options: e.data.options 
            });
          }
        } catch (error) {
          self.postMessage({ status: 'error', taskId, taskType, error: error.message });
        }
      };
    `;
    const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);
    
    
    // --- 3. 기본 설정 및 훅 (v12.0) ---

    const DEFAULT_SETTINGS = {
        apiKeys: [{ key: "", rpm: 60 }],
        defaultDifficulty: "Medium",
        defaultQuestionType: "MultipleChoice",
        defaultNumQuestions: 10,
        modelName: "gemini-2.5-flash", // (v12.0) 기본 모델 설정
        quizSystemPrompt: `You are an expert quiz generation AI. You must generate a {{NUM_QUESTIONS}}-question quiz based *only* on the provided source text.
- Difficulty: {{DIFFICULTY}}
- Requested Question Type: {{QUESTION_TYPE}}
- Adhere strictly to the provided JSON schema.
- You MUST set 'questionType' for each question (e.g., "MultipleChoice" or "ShortAnswer", "Essay" etc.).
- For "MultipleChoice" questions, provide 'options' (array) and 'correctAnswerIndex' (number).
- For subjective questions (like "ShortAnswer", "Essay", "CaseStudy"), DO NOT provide 'correctAnswerIndex' or 'options'.
- Instead, for subjective questions, you MUST provide detailed 'gradingCriteria' (string). This criteria is a rubric for another AI to use for grading. (예: "정확한 용어 'TDD' 언급 시 1점, '테스트 우선 작성'의 개념 설명 시 1점")
- {{INCLUDE_SNIPPETS}}
- {{PROVIDE_ANSWER_KEY}}
- {{CUSTOM_INSTRUCTIONS}}`,
        gradingSystemPrompt: `You are a fair and meticulous AI teaching assistant. Your task is to grade a user's answer based *only* on the provided grading criteria (rubric).
- Evaluate the "USER'S ANSWER" strictly against the "GRADING CRITERIA".
- Determine if the answer is correct (true) or incorrect (false).
- Provide concise, constructive feedback (첨삭) in Korean, explaining *why* the answer is correct or incorrect based on the criteria.
- Adhere strictly to the JSON output schema.`
    };

    const QUESTION_TYPE_MAP = {
      "MultipleChoice": "객관식 (선택형)",
      "ShortAnswer": "주관식 (단답형)",
      "Essay": "서술형",
      "TrueFalse": "진위형 (O/X)",
      "FillInTheBlank": "빈칸 채우기",
      "CaseStudy": "사례 연구",
      "Matching": "연결형",
      "Sequencing": "순서 맞추기",
      "CodeSnippet": "코드 분석"
    };

    // (v11.0) Firebase Firestore 기반 파일 시스템 훅
    // 근거: Axiom of SOLID Architecture - 데이터 로직을 훅으로 분리
    const useFileSystem = (files, db, userId, appId) => {
        
        const getCollectionRef = (collectionName) => {
            return collection(db, `artifacts/${appId}/users/${userId}/${collectionName}`);
        };

        const fileActions = useMemo(() => {
          // (v11.1) userId가 null이면 fileActions는 빈 객체를 반환
          if (!db || !userId) return {};

          const recursiveDelete = async (parentId) => {
              // Firestore에서 parentId로 자식 쿼리
              const childrenQuery = query(getCollectionRef('files'), where("parentId", "==", parentId));
              const querySnapshot = await getDocs(childrenQuery);
              
              const batch = writeBatch(db);
              
              for (const docSnap of querySnapshot.docs) {
                  const child = { id: docSnap.id, ...docSnap.data() };
                  if (child.type === 'folder') {
                      // 재귀적으로 자식 폴더 삭제
                      await recursiveDelete(child.id);
                  }
                  // 현재 파일/폴더를 배치에 추가
                  batch.delete(doc(db, `artifacts/${appId}/users/${userId}/files`, child.id));
              }
              // batch 커밋은 recursiveDelete를 호출한 곳에서 수행
              // 여기서는 자식 삭제만 담당
              await batch.commit();
          };
          
          const move = async (fileId, newParentId) => {
              if (fileId === newParentId) return;
              
              const fileRef = doc(db, `artifacts/${appId}/users/${userId}/files`, fileId);
              const fileDoc = await getDoc(fileRef);

              if(fileDoc.exists() && fileDoc.data().parentId !== newParentId) { 
                  await updateDoc(fileRef, { parentId: newParentId });
                  // onSnapshot이 자동으로 refetch 수행
              }
          };

          return {
            create: async (parentId, type, name, content = '') => {
              const docName = name || (type === 'folder' ? 'New Folder' : 'new-file.txt');
              const newFile = {
                // id는 Firestore가 자동 생성
                name: docName,
                type,
                parentId,
                content: type === 'file' ? content : null,
                metadata: { notes: '' }, 
                createdAt: new Date().toISOString(),
                userId: userId // (v11.0) 데이터 소유권 명시
              };
              const docRef = await addDoc(getCollectionRef('files'), newFile);
              return { ...newFile, id: docRef.id };
            },
            rename: async (fileId, newName) => {
              const fileRef = doc(db, `artifacts/${appId}/users/${userId}/files`, fileId);
              await updateDoc(fileRef, { name: newName });
            },
            remove: async (fileId, type) => {
              if (type === 'folder') {
                  // 폴더의 모든 하위 항목 재귀적 삭제
                  await recursiveDelete(fileId);
              }
              // 자기 자신 삭제
              const fileRef = doc(db, `artifacts/${appId}/users/${userId}/files`, fileId);
              await deleteDoc(fileRef);
            },
            updateContent: async (fileId, newContent) => {
              const fileRef = doc(db, `artifacts/${appId}/users/${userId}/files`, fileId);
              await updateDoc(fileRef, { content: newContent });
            },
            move: move,
            updateMetadata: async (fileId, newMetadata) => {
                const fileRef = doc(db, `artifacts/${appId}/users/${userId}/files`, fileId);
                const fileDoc = await getDoc(fileRef);
                if (fileDoc.exists()) {
                    const oldMetadata = fileDoc.data().metadata || { notes: '' };
                    await updateDoc(fileRef, {
                        metadata: { ...oldMetadata, ...newMetadata }
                    });
                }
            }
          };
        }, [db, userId, appId]);

        const fileTree = useMemo(() => {
          const map = {};
          const roots = [];
          files.forEach(file => {
            map[file.id] = { ...file, children: [] };
          });
          Object.values(map).forEach(node => {
            if (node.parentId === 'root') {
              roots.push(node);
            } else if (map[node.parentId]) {
              map[node.parentId].children.push(node);
            }
          });
          // 이름순으로 정렬 (폴더 우선)
          const sortFn = (a, b) => {
              if (a.type === 'folder' && b.type !== 'folder') return -1;
              if (a.type !== 'folder' && b.type === 'folder') return 1;
              return a.name.localeCompare(b.name);
          };
          roots.sort(sortFn);
          Object.values(map).forEach(node => {
              if(node.children) node.children.sort(sortFn);
          });
          return roots;
        }, [files]);

        return { fileTree, fileActions };
    };
    
    // Debounce 훅
    const useDebounce = (value, delay) => {
        const [debouncedValue, setDebouncedValue] = useState(value);
        useEffect(() => {
            const handler = setTimeout(() => { setDebouncedValue(value); }, delay);
            return () => clearTimeout(handler);
        }, [value, delay]);
        return debouncedValue;
    };


    // --- 4. UI 컴포넌트 ---
    
    /* 토스트 시스템 */
    const ToastProvider = ({ children }) => {
        const [toasts, setToasts] = useState([]);
        const show = useCallback((message, type = 'info') => {
            const id = crypto.randomUUID();
            setToasts(prev => [...prev, { id, message, type }]);
            setTimeout(() => {
                setToasts(prev => prev.filter(t => t.id !== id));
            }, 3000);
        }, []);
        const value = useMemo(() => ({ show }), [show]);
        return e(ToastContext.Provider, { value },
            children,
            e(ToastContainer, { toasts })
        );
    };
    const ToastContainer = ({ toasts }) => {
        return e('div', { className: 'toast-container' },
            toasts.map(toast => e('div', { 
                key: toast.id, 
                className: `toast-item ${toast.type}` 
            }, toast.message))
        );
    };


    const Spinner = () => e(
      'div', { className: 'spinner-overlay' },
      e('div', { className: 'spinner' })
    );

    // 셸
    const ReactVscodeSidebar = ({ items = [], onActiveChange, activeId, isVisible, children }) => {
      const activityBarTop = e('div', null,
        items.filter(item => item.isBottom !== true).map((item) => e('button', {
          key: item.id, className: 'vsc-activity-item',
          onClick: () => onActiveChange(item.id),
          'data-active': isVisible && item.id === activeId, 'aria-label': item.label
        }, item.icon))
      );
      const activityBarBottom = e('div', null,
        items.filter(item => item.isBottom === true).map((item) => e('button', {
          key: item.id, className: 'vsc-activity-item',
          onClick: () => onActiveChange(item.id),
          'data-active': isVisible && item.id === activeId, 'aria-label': item.label
        }, item.icon))
      );
      const activeView = React.Children.toArray(children).find(
        (child) => child.props.viewId === activeId
      );
      const sidebarView = e('div', { 
          className: 'vsc-sidebar-view',
          'data-visible': isVisible
        },
        isVisible && activeView ? e('div', { className: 'vsc-view-content', key: activeId }, activeView) : null
      );
      return e('div', { className: 'vsc-sidebar-container' }, 
        e('div', { className: 'vsc-activity-bar' }, activityBarTop, activityBarBottom), 
        sidebarView
      );
    };
    
    // 컨텍스트 메뉴
    const ContextMenu = ({ menuData, handlers, onClose }) => {
        if (!menuData.visible) return null;
        const { node } = menuData;
        const isFolder = node?.type === 'folder';
        const isRoot = !node;

        const handleAction = (action) => {
            onClose();
            action();
        };

        const MenuItem = ({ label, onClick, disabled = false, isDelete = false }) => e(
            'li', {
                className: `context-menu-item ${isDelete ? 'context-menu-item-delete' : ''}`,
                onClick: (e) => { e.stopPropagation(); if (!disabled) handleAction(onClick); }
            }, label
        );

        return e('div', {
            className: 'context-menu',
            style: { top: menuData.y, left: menuData.x },
            onClick: (e) => e.stopPropagation()
        },
            e('ul', { className: 'py-1' },
                !isRoot && e(React.Fragment, null,
                    e(MenuItem, { label: '이름 바꾸기', onClick: handlers.onRename }),
                    e(MenuItem, { label: '삭제', onClick: handlers.onDelete, isDelete: true }),
                    e('hr', { className: 'context-menu-divider' })
                ),
                (isRoot || isFolder) && e(React.Fragment, null,
                    e(MenuItem, { label: '새 파일', onClick: handlers.onCreateFile }),
                    e(MenuItem, { label: '새 폴더', onClick: handlers.onCreateFolder })
                ),
                !isRoot && !isFolder && e(React.Fragment, null,
                    e('hr', { className: 'context-menu-divider' }),
                    e(MenuItem, { label: '✨ 퀴즈 생성', onClick: handlers.onGenerateQuiz })
                )
            )
        );
    };

    // (v11.1) 파일 관리자 (Google Auth)
    const FileManagerView = ({ viewId }) => {
        const { 
            files, fileTree, fileActions, setActiveEditorFile, activeEditorFile,
            db, userId, appId, setEditingNodeId,
            quizzes, attempts, setModalContent,
            handleQuizSubmit,
            userSettings,
            dispatchGradingTask,
            dispatchTask, 
            quizOptions 
        } = useContext(AppContext);
        
        const toast = useToast();
        
        const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, node: null });
        const [isRootDragOver, setIsRootDragOver] = useState(false);
        const [activeLowerPaneTab, setActiveLowerPaneTab] = useState('quizzes');
        
        const fileQuizzes = useMemo(() => 
            activeEditorFile ? quizzes.filter(q => q.fileId === activeEditorFile.id) : [],
        [quizzes, activeEditorFile]);
        
        const fileAttempts = useMemo(() =>
            activeEditorFile ? attempts.filter(a => a.fileId === activeEditorFile.id) : [],
        [attempts, activeEditorFile]);
        
        
        /* (v11.0) 파일 업로드/프로젝트 임포트/익스포트 핸들러 (Firebase) */
        const handleFileUpload = useCallback(async (event) => {
            if (!userId) { // (v11.1) 로그인 확인
                toast.show('❌ 로그인이 필요합니다.', 'error');
                return;
            }
            const files = event.target.files;
            if (!files.length) return;
            toast.show('파일 업로드 시작...', 'info');
            
            for (const file of files) {
                const fileName = file.name;
                const fileExt = fileName.split('.').pop().toLowerCase();
                if (['txt', 'md'].includes(fileExt)) {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        await fileActions.create('root', 'file', fileName, e.target.result);
                    };
                    reader.readAsText(file);
                } else if (fileExt === 'zip') {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const zip = await JSZip.loadAsync(e.target.result);
                            const zipRootFolder = await fileActions.create('root', 'folder', fileName.replace(/\.zip$/i, ''));
                            
                            const createdFolderIds = new Map();
                            createdFolderIds.set('root', zipRootFolder.id);
                            
                            const allFolderPaths = new Set();
                            Object.keys(zip.files).forEach(p => {
                                if (zip.files[p].dir) {
                                    allFolderPaths.add(p);
                                } else {
                                    const parts = p.split('/');
                                    parts.pop();
                                    let currentPath = '';
                                    for (const part of parts) {
                                        if (!part) continue;
                                        currentPath += part + '/';
                                        allFolderPaths.add(currentPath);
                                    }
                                }
                            });
                            
                            const sortedFolderPaths = Array.from(allFolderPaths)
                                .filter(p => p && !p.startsWith('__MACOSX/'))
                                .sort((a, b) => a.split('/').length - b.split('/').length);
                                
                            for (const folderPath of sortedFolderPaths) {
                                const parts = folderPath.replace(/\/$/, '').split('/');
                                const folderName = parts[parts.length - 1];
                                const parentPath = parts.slice(0, -1).join('/') + (parts.length > 1 ? '/' : '');
                                const parentFolderId = createdFolderIds.get(parentPath || 'root');
                                if (parentFolderId && folderName && !createdFolderIds.has(folderPath)) {
                                    const newFolder = await fileActions.create(parentFolderId, 'folder', folderName);
                                    createdFolderIds.set(folderPath, newFolder.id);
                                }
                            }
                            
                            for (const [relativePath, zipEntry] of Object.entries(zip.files)) {
                                if (!zipEntry.dir && !zipEntry.name.startsWith('__MACOSX/') && zipEntry.name) {
                                    const parts = zipEntry.name.split('/');
                                    const fileName = parts.pop();
                                    const parentPath = parts.join('/') + (parts.length > 0 ? '/' : '');
                                    const parentFolderId = createdFolderIds.get(parentPath || 'root');
                                    if (parentFolderId && fileName) {
                                        const content = await zipEntry.async('string');
                                        await fileActions.create(parentFolderId, 'file', fileName, content);
                                    }
                                }
                            }
                        } catch (err) {
                            console.error("ZIP processing failed:", err);
                            toast.show(`❌ ZIP 파일 처리 실패: ${err.message}`, 'error');
                        }
                    };
                    reader.readAsArrayBuffer(file);
                }
            }
            
            toast.show('✅ 파일 업로드 완료.', 'success');
            event.target.value = null;
        }, [fileActions, toast, userId]);
        
        const getCollectionRef = (collectionName) => {
            return collection(db, `artifacts/${appId}/users/${userId}/${collectionName}`);
        };

        const handleImportProject = useCallback((event) => {
            if (!userId) { // (v11.1) 로그인 확인
                toast.show('❌ 로그인이 필요합니다.', 'error');
                return;
            }
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                if (!window.confirm("현재 프로젝트를 덮어쓰시겠습니까? 모든 현재 데이터가 삭제됩니다.")) return;
                
                try {
                    toast.show('가져오기 시작... (데이터 삭제 중)', 'info');
                    const data = JSON.parse(e.target.result);
                    
                    // 1. Clear all existing data for this user
                    const collections = ['files', 'quizzes', 'quizAttempts'];
                    for (const collName of collections) {
                        const collRef = getCollectionRef(collName);
                        const qSnapshot = await getDocs(collRef);
                        const batch = writeBatch(db);
                        qSnapshot.docs.forEach(docSnap => batch.delete(docSnap.ref));
                        await batch.commit();
                    }
                    
                    toast.show('데이터 삭제 완료. 가져오기 진행 중...', 'info');

                    // 2. Import new data
                    const importBatch = writeBatch(db);
                    (data.files || []).forEach(file => {
                        const docRef = doc(getCollectionRef('files'), file.id);
                        importBatch.set(docRef, { ...file, userId });
                    });
                    (data.quizzes || []).forEach(quiz => {
                        const docRef = doc(getCollectionRef('quizzes'), quiz.id);
                        importBatch.set(docRef, { ...quiz, userId });
                    });
                    (data.attempts || []).forEach(attempt => {
                        const docRef = doc(getCollectionRef('quizAttempts'), attempt.id);
                        importBatch.set(docRef, { ...attempt, userId });
                    });
                    
                    await importBatch.commit();
                    
                    // 3. Import settings
                    if (data.settings) {
                        const settingsRef = doc(db, `artifacts/${appId}/users/${userId}/settings/userConfig`);
                        await setDoc(settingsRef, data.settings);
                    }
                    
                    toast.show('✅ 프로젝트를 성공적으로 가져왔습니다.', 'success');
                    // onSnapshot이 자동으로 UI를 업데이트합니다.
                } catch (err) {
                    console.error("Import failed:", err);
                    toast.show(`❌ 가져오기 실패: ${err.message}`, 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }, [db, userId, appId, toast]);
        
        const handleExportProject = useCallback(async () => {
            if (!userId) { // (v11.1) 로그인 확인
                toast.show('❌ 로그인이 필요합니다.', 'error');
                return;
            }
            try {
                const [filesSnap, quizzesSnap, attemptsSnap, settingsDoc] = await Promise.all([
                    getDocs(getCollectionRef('files')),
                    getDocs(getCollectionRef('quizzes')),
                    getDocs(getCollectionRef('quizAttempts')),
                    getDoc(doc(db, `artifacts/${appId}/users/${userId}/settings/userConfig`))
                ]);
                
                const data = {
                    files: filesSnap.docs.map(d => ({ id: d.id, ...d.data() })),
                    quizzes: quizzesSnap.docs.map(d => ({ id: d.id, ...d.data() })),
                    attempts: attemptsSnap.docs.map(d => ({ id: d.id, ...d.data() })),
                    settings: settingsDoc.exists() ? settingsDoc.data() : null
                };
                
                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ai-quiz-app-export.json';
                a.click();
                URL.revokeObjectURL(url);
                toast.show('✅ 프로젝트를 내보냈습니다.', 'success');
            } catch (err) {
                console.error("Export failed:", err);
                toast.show(`❌ 내보내기 실패: ${err.message}`, 'error');
            }
        }, [db, userId, appId, toast]);
        
        useEffect(() => {
            const handleClick = () => setContextMenu({ visible: false });
            window.addEventListener('click', handleClick);
            const fileUploadInput = document.getElementById('file-upload-input');
            const projectImportInput = document.getElementById('project-import-input');
            fileUploadInput.addEventListener('change', handleFileUpload);
            projectImportInput.addEventListener('change', handleImportProject);
            return () => {
                window.removeEventListener('click', handleClick);
                fileUploadInput.removeEventListener('change', handleFileUpload);
                projectImportInput.removeEventListener('change', handleImportProject);
            };
        }, [handleFileUpload, handleImportProject]);
        
        const handleContextMenu = (e, node) => {
            if (!userId) return; // (v11.1) 로그인하지 않으면 컨텍스트 메뉴 없음
            e.preventDefault();
            e.stopPropagation();
            setContextMenu({ visible: true, x: e.clientX, y: e.clientY, node: node });
        };
        
        // FileNode
        const FileNode = ({ node, depth, onContextMenu }) => {
            const { activeEditorFile, editingNodeId, setEditingNodeId, fileActions } = useContext(AppContext);
            const [isOpen, setIsOpen] = useState(true);
            const [editName, setEditName] = useState(node.name);
            const [isDragOver, setIsDragOver] = useState(false);
            const isEditing = editingNodeId === node.id;
            useEffect(() => {
                if (isEditing) setEditName(node.name);
            }, [isEditing, node.name]);
            const handleToggle = (e) => {
                e.stopPropagation();
                if (node.type === 'folder') setIsOpen(!isOpen);
                else setActiveEditorFile(files.find(f => f.id === node.id));
            };
            const handleRenameSubmit = async (e) => {
                e.stopPropagation(); e.preventDefault();
                if (editName.trim() && editName.trim() !== node.name) {
                    await fileActions.rename(node.id, editName.trim());
                }
                setEditingNodeId(null);
            };
            const handleDragStart = (e) => {
                e.stopPropagation();
                e.dataTransfer.setData('fileId', node.id);
                e.dataTransfer.effectAllowed = 'move';
            };
            const handleDragOver = (e) => {
                e.preventDefault(); e.stopPropagation();
                if (node.type === 'folder') {
                    setIsDragOver(true);
                    e.dataTransfer.dropEffect = 'move';
                } else {
                    e.dataTransfer.dropEffect = 'none';
                }
            };
            const handleDragLeave = (e) => {
                e.preventDefault(); e.stopPropagation();
                setIsDragOver(false);
            };
            const handleDrop = async (e) => {
                e.preventDefault(); e.stopPropagation();
                setIsDragOver(false);
                if (node.type === 'folder') {
                    const fileId = e.dataTransfer.getData('fileId');
                    if (fileId && fileId !== node.id) {
                        await fileActions.move(fileId, node.id);
                    }
                }
            };
            return e(React.Fragment, null,
                e('div', { 
                    className: 'file-tree-node',
                    style: { paddingLeft: `${depth * 16 + 8}px` },
                    onClick: handleToggle,
                    onContextMenu: (e) => onContextMenu(e, node),
                    'data-active': activeEditorFile?.id === node.id,
                    draggable: true,
                    onDragStart: handleDragStart,
                    onDragOver: handleDragOver,
                    onDragLeave: handleDragLeave,
                    onDrop: handleDrop,
                    'data-drag-over': isDragOver
                  },
                  e('span', { className: 'file-tree-node-icon' }, 
                    node.type === 'folder' ? (isOpen ? '▼' : '►') : '📄'
                  ),
                  isEditing
                    ? e('form', { onSubmit: handleRenameSubmit, className: 'flex-1 ml-1' },
                        e('input', {
                            key: node.id, type: 'text', value: editName,
                            onChange: (ev) => setEditName(ev.target.value),
                            onBlur: handleRenameSubmit,
                            onClick: (e) => e.stopPropagation(), autoFocus: true,
                            className: 'form-input !p-0 !text-sm'
                        })
                      )
                    : e('span', { className: 'ml-1' }, node.name)
                ),
                isOpen && node.children && node.children.map(child => 
                    e(FileNode, { 
                        key: child.id, 
                        node: child, 
                        depth: depth + 1, 
                        onContextMenu: onContextMenu
                    })
                )
            );
        };
        
        // (v11.0) contextMenuHandlers (Firebase)
        const contextMenuHandlers = useMemo(() => {
            if (!userId) return {}; // (v11.1) 로그인하지 않으면 핸들러 없음
            const { node } = contextMenu;
            const parentId = (node && node.type === 'folder') ? node.id : (node ? node.parentId : 'root');
            
            return {
                onRename: () => { if (node) setEditingNodeId(node.id); },
                onDelete: async () => {
                    if (node && window.confirm(`'${node.name}'을(를) 삭제하시겠습니까? (하위 항목 포함)`)) {
                        await fileActions.remove(node.id, node.type);
                        if (activeEditorFile?.id === node.id) setActiveEditorFile(null);
                    }
                },
                onCreateFile: () => fileActions.create(parentId, 'file'),
                onCreateFolder: () => fileActions.create(parentId, 'folder'),
                onGenerateQuiz: async () => {
                    if (node && node.type === 'file') {
                        // (v11.0) Firestore에서 최신 파일 내용 가져오기
                        const fileRef = doc(db, `artifacts/${appId}/users/${userId}/files`, node.id);
                        const fileSnap = await getDoc(fileRef);
                        const file = { id: fileSnap.id, ...fileSnap.data() };
                        
                        if (!file.content || !file.content.trim()) {
                            toast.show('❌ 파일에 원문이 없습니다. 파일을 열어 내용을 추가하세요.', 'error');
                            return;
                        }
                        if(activeEditorFile?.id !== file.id) {
                            setActiveEditorFile(file);
                        }
                        dispatchTask({
                            taskType: 'generate',
                            sourceText: file.content,
                            options: {
                                ...quizOptions,
                                fileId: file.id,
                                sourceFileName: file.name
                            }
                        });
                    }
                }
            };
        }, [contextMenu, fileActions, setEditingNodeId, activeEditorFile, db, userId, appId, dispatchTask, quizOptions, toast, setActiveEditorFile]);
        
        // 루트 DnD 핸들러
        const handleRootDragOver = (e) => {
            if (!userId) return; // (v11.1)
            e.preventDefault();
            e.stopPropagation();
            setIsRootDragOver(true);
            e.dataTransfer.dropEffect = 'move';
        };
        const handleRootDragLeave = (e) => {
            if (!userId) return; // (v11.1)
            e.preventDefault();
            e.stopPropagation();
            setIsRootDragOver(false);
        };
        const handleRootDrop = async (e) => {
            if (!userId) return; // (v11.1)
            e.preventDefault();
            e.stopPropagation();
            setIsRootDragOver(false);
            const fileId = e.dataTransfer.getData('fileId');
            if (fileId) {
                await fileActions.move(fileId, 'root');
            }
        };

        return e('div', { 
            viewId, 
            className: 'flex flex-col h-full vsc-view-panes',
            onContextMenu: (e) => handleContextMenu(e, null)
           },
            // 상단: 파일 트리
            e('div', { className: 'vsc-view-pane' },
                e('div', { className: 'view-header' },
                    e('h3', { className: 'border-b-0 p-0 m-0' }, '파일 탐색기'),
                    // (v11.1) 로그인 상태일 때만 버튼 활성화
                    userId && e('div', { className: 'flex gap-1' },
                        e('button', { title: "새 폴더", className: 'view-header-icon', onClick: () => contextMenuHandlers.onCreateFolder() }, '📁+'),
                        e('button', { title: "파일 업로드", className: 'view-header-icon', onClick: () => document.getElementById('file-upload-input').click() }, '⬆️'),
                        e('button', { title: "내보내기", className: 'view-header-icon', onClick: handleExportProject }, '💾'),
                        e('button', { title: "가져오기", className: 'view-header-icon', onClick: () => document.getElementById('project-import-input').click() }, '📥')
                    )
                ),
                e('div', { 
                    className: 'vsc-view-pane-content full',
                    onDragOver: handleRootDragOver,
                    onDragLeave: handleRootDragLeave,
                    onDrop: handleRootDrop,
                    'data-drag-over': isRootDragOver
                }, 
                    !userId && e('p', { className: 'p-4 text-sm text-gray-400 text-center' }, 'Google 계정(👤)으로 로그인하여 파일 탐색기를 활성화하세요.'),
                    userId && fileTree.length === 0 && e('p', { className: 'p-4 text-sm text-gray-400 text-center' }, '파일이 없습니다. 새 파일/폴더를 만들거나 업로드하세요.'),
                    userId && e('div', { className: 'file-tree-list' },
                        fileTree.map(node => e(FileNode, { 
                            key: node.id, 
                            node: node, 
                            depth: 0, 
                            onContextMenu: handleContextMenu
                        }))
                    )
                )
            ),
            
            // 하단: 파일 상세 (탭 뷰)
            userId && activeEditorFile && e('div', { className: 'vsc-view-pane' },
                e('div', { className: 'vsc-view-pane-header flex justify-between' }, 
                    e('div', { className: 'flex' },
                        e('button', {
                            className: `px-3 py-1 text-xs ${activeLowerPaneTab === 'quizzes' ? 'text-white bg-gray-600' : 'text-gray-400'}`,
                            onClick: () => setActiveLowerPaneTab('quizzes')
                        }, '퀴즈/기록'),
                        e('button', {
                            className: `px-3 py-1 text-xs ${activeLowerPaneTab === 'notes' ? 'text-white bg-gray-600' : 'text-gray-400'}`,
                            onClick: () => setActiveLowerPaneTab('notes')
                        }, '메모')
                    )
                ),
                e('div', { className: `vsc-view-pane-content ${activeLowerPaneTab === 'notes' ? 'full' : ''}` },
                    activeLowerPaneTab === 'quizzes' && e('div', null,
                        e('h4', { className: 'text-md font-semibold mt-0 mb-2' }, '생성된 퀴즈'),
                        fileQuizzes.length === 0 && e('p', { className: 'text-sm text-gray-400' }, '이 파일로 생성된 퀴즈가 없습니다.'),
                        fileQuizzes.map(quiz => e('div', { 
                            key: quiz.id, className: 'list-item',
                            onClick: () => setModalContent(e(QuizTaker, { 
                                quiz, 
                                onClose: () => setModalContent(null),
                                onQuizSubmit: handleQuizSubmit 
                            }))
                        }, e('div', { className: 'list-item-title' }, quiz.title))),
                        
                        e('h4', { className: 'text-md font-semibold mt-4 mb-2' }, '풀이 기록'),
                        fileAttempts.length === 0 && e('p', { className: 'text-sm text-gray-400' }, '이 파일의 퀴즈 풀이 기록이 없습니다.'),
                        fileAttempts.map(attempt => e('div', { 
                            key: attempt.id, className: 'list-item',
                            onClick: () => setModalContent(e(QuizResult, { 
                                attempt, 
                                quiz: quizzes.find(q => q.id === attempt.quizId), 
                                onClose: () => setModalContent(null),
                                userSettings,
                                dispatchGradingTask
                            }))
                        }, e('div', { className: 'list-item-title' }, `${attempt.quizTitle} (${attempt.score}/${attempt.total})`)))
                    ),
                    activeLowerPaneTab === 'notes' && e(FileNotesEditor, {
                        activeFile: activeEditorFile,
                        fileActions: fileActions
                    })
                )
            ),
            
            e(ContextMenu, {
                menuData: contextMenu,
                onClose: () => setContextMenu({ visible: false }),
                handlers: contextMenuHandlers
            })
        );
    };

    // 뷰 2: 퀴즈 생성기
    const QuizGeneratorView = ({ viewId }) => {
      const { quizOptions, setQuizOptions } = useContext(AppContext);

      const handleSubmit = (e) => { e.preventDefault(); };
      
      return e('form', { viewId, onSubmit: handleSubmit, className: 'flex flex-col h-full' },
        e('h3', { className: 'view-header' }, '퀴즈 옵션'),
        e('div', { className: 'view-content-scroll' },
          e('div', { className: 'grid grid-cols-2 gap-4' },
            e('div', { className: 'form-group' },
              e('label', { htmlFor: 'num-questions', className: 'form-label' }, '질문 수'),
              e('input', {
                id: 'num-questions', type: 'number', className: 'form-input',
                value: quizOptions.numQuestions, 
                onChange: (ev) => setQuizOptions(o => ({...o, numQuestions: parseInt(ev.target.value, 10)}))
              })
            ),
            e('div', { className: 'form-group' },
              e('label', { htmlFor: 'difficulty', className: 'form-label' }, '난이도'),
              e('select', { 
                  id: 'difficulty', className: 'form-select',
                  value: quizOptions.difficulty, 
                  onChange: (ev) => setQuizOptions(o => ({...o, difficulty: ev.target.value}))
                },
                e('option', { value: 'Easy' }, '쉬움'),
                e('option', { value: 'Medium' }, '보통'),
                e('option', { value: 'Hard' }, '어려움')
              )
            )
          ),
          e('div', { className: 'form-group' },
            e('label', { htmlFor: 'question-type', className: 'form-label' }, '질문 유형'),
            e('select', {
                id: 'question-type', className: 'form-select',
                value: quizOptions.questionType, 
                onChange: (ev) => setQuizOptions(o => ({...o, questionType: ev.target.value}))
              },
              Object.entries(QUESTION_TYPE_MAP).map(([value, label]) => 
                  e('option', { key: value, value: value }, label)
              )
            )
          ),
          e('div', { className: 'form-group' },
            e('label', { className: 'form-label' }, '추가 지침 (선택 사항)'),
            e('input', {
              type: 'text', className: 'form-input',
              value: quizOptions.customInstructions, 
              onChange: (ev) => setQuizOptions(o => ({...o, customInstructions: ev.target.value})),
              placeholder: '예: 코드 예제에 집중하세요'
            })
          ),
          e('div', { className: 'form-group space-y-2' },
            e('label', { className: 'form-checkbox-label' },
              e('input', {
                type: 'checkbox', className: 'form-checkbox',
                checked: quizOptions.includeSnippets, 
                onChange: (ev) => setQuizOptions(o => ({...o, includeSnippets: ev.target.checked}))
              }),
              '코드 스니펫 포함'
            ),
            e('label', { className: 'form-checkbox-label' },
              e('input', {
                type: 'checkbox', className: 'form-checkbox',
                checked: quizOptions.provideAnswerKey, 
                onChange: (ev) => setQuizOptions(o => ({...o, provideAnswerKey: ev.target.checked}))
              }),
              '정답 키 제공'
            )
          )
        )
      );
    };
    
    // 뷰 3: 퀴즈 기록
    const QuizHistoryView = ({ viewId }) => {
      const { quizzes, attempts, setModalContent, userSettings, dispatchGradingTask, userId } = useContext(AppContext);
      
      const showAttemptResult = (attempt) => {
          setModalContent(e(QuizResult, { 
              attempt, 
              quiz: quizzes.find(q => q.id === attempt.quizId),
              onClose: () => setModalContent(null),
              userSettings,
              dispatchGradingTask
          }));
      };
      
      return e('div', { viewId, className: 'flex flex-col h-full' },
        e('h3', { className: 'view-header' }, '전체 풀이 기록'),
        e('div', { className: 'view-content-scroll' },
          !userId && e('p', { className: 'p-4 text-sm text-gray-400 text-center' }, '로그인(👤)하여 풀이 기록을 확인하세요.'),
          userId && attempts.length === 0 && e('p', { className: 'text-sm text-gray-400' }, '풀이 기록이 없습니다.'),
          userId && [...attempts].sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))
          .map(attempt => e('div', { 
              key: attempt.id, 
              className: 'list-item',
              onClick: () => showAttemptResult(attempt)
            },
            e('div', { className: 'list-item-title' }, attempt.quizTitle),
            e('div', { className: 'flex justify-between' },
                e('span', { className: 'list-item-sub' }, `점수: ${attempt.score} / ${attempt.total}`),
                e('span', { className: 'list-item-sub' }, 
                    new Date(attempt.completedAt).toLocaleDateString()
                )
            )
          ))
        )
      );
    };
    
    // 뷰 4: 작업 모니터
    const TaskMonitorView = ({ viewId }) => {
        const { taskQueue, userId } = useContext(AppContext);
        
        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, '작업 모니터'),
            e('div', { className: 'view-content-scroll' },
                !userId && e('p', { className: 'p-4 text-sm text-gray-400 text-center' }, '로그인(👤)하여 작업을 확인하세요.'),
                userId && taskQueue.length === 0 && e('p', { className: 'text-sm text-gray-400' }, '활성 작업이 없습니다.'),
                userId && taskQueue.map(task => e('div', { key: task.id, className: 'list-item' },
                    e('div', { className: 'list-item-title' }, 
                      task.taskType === 'grade' 
                        ? `[채점] ${task.options.quizTitle}` 
                        : `[생성] ${task.options.sourceFileName}`
                    ),
                    e('div', { className: 'flex justify-between items-center' },
                        e('span', { className: 'list-item-sub' }, 
                          task.taskType === 'grade'
                            ? `퀴즈 채점 작업`
                            : `유형: ${QUESTION_TYPE_MAP[task.options.questionType] || task.options.questionType} (${task.options.numQuestions} 문제)`
                        ),
                        task.status === 'processing' && e('span', { className: 'list-item-badge' }, '처리 중...'),
                        task.status === 'success' && e('span', { className: 'list-item-badge success' }, '완료'),
                        task.status === 'error' && e('span', { className: 'list-item-badge error' }, '오류')
                    )
                ))
            )
        );
    };

    // (v12.0) 뷰어 모드 컴포넌트
    const MarkdownViewer = ({ markdownText }) => {
        const viewerRef = useRef(null);

        // 1. 1차 파싱 (Markdown -> HTML)
        const { contentHtml, footnotesHtml } = useMemo(() => {
            if (!markdownText) return { contentHtml: '', footnotesHtml: '' };

            const cleanedText = FootnoteManager.extractAndClean(markdownText);
            let contentHtml = parseMarkdownWithExtensions(cleanedText);
            
            let footnotesHtml = '';
            const footnoteOrder = FootnoteManager.getOrder();
            if (footnoteOrder.length > 0) {
                footnotesHtml += '<hr class="footnote-divider"><section class="footnotes"><ol>';
                footnoteOrder.forEach(name => {
                    const note = FootnoteManager.getNote(name);
                    if (note) {
                        const backRef = `<a href="#fnref:${name}" class="footnote-backref" role="doc-backlink">↩</a>`;
                        footnotesHtml += `<li id="fn:${name}"><p class="mr-2 font-mono text-xs text-slate-500">[${name}]:</p><div class="flex-1">${note.html}${backRef}</div></li>`;
                    }
                });
                footnotesHtml += '</ol></section>';
            }
            
            // DOMPurify로 정화
            const sanitizedContent = window.DOMPurify.sanitize(contentHtml, {
                ALLOWED_TAGS: ['strong', 'em', 'p', 'br', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'a', 'code', 'pre', 'blockquote', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'mark', 'sup', 'hr'],
                ALLOWED_ATTR: ['href', 'title', 'id', 'class', 'data-footnote-key']
            });
            const sanitizedFootnotes = window.DOMPurify.sanitize(footnotesHtml, {
                ALLOWED_TAGS: ['strong', 'em', 'p', 'br', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'a', 'code', 'pre', 'blockquote', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'mark', 'sup', 'hr', 'section', 'div'],
                ALLOWED_ATTR: ['href', 'title', 'id', 'class', 'role', 'data-footnote-key']
            });

            return { contentHtml: sanitizedContent, footnotesHtml: sanitizedFootnotes };
        }, [markdownText]);

        // 2. 2차 후처리 (DOM 렌더링 후)
        useEffect(() => {
            if (viewerRef.current) {
                applyPostRenderEffects(viewerRef.current);
            }
        }, [contentHtml, footnotesHtml]); // HTML이 변경될 때마다 후처리 실행

        return e('div', { 
                ref: viewerRef, 
                className: 'prose-readable-wrapper prose-dark-theme' 
            },
            e('div', {
                className: 'prose-readable',
                dangerouslySetInnerHTML: { __html: contentHtml + footnotesHtml }
            })
        );
    };


    // (v12.0) 메인 컨텐츠 에디터 (뷰어 모드 토글 추가)
    const MainContentEditor = () => {
        const { 
            activeEditorFile, fileActions, 
            dispatchTask, quizOptions,
            userId,             // (v11.1) 로그인 상태 확인용
            handleGoogleSignIn  // (v11.1) 로그인 함수
        } = useContext(AppContext);
        
        const [content, setContent] = useState("");
        const [saveStatus, setSaveStatus] = useState('saved');
        const [isViewerMode, setIsViewerMode] = useState(false); // (v12.0) 뷰어 모드 상태
        
        const toast = useToast();
        
        useEffect(() => {
            if (activeEditorFile) {
                setContent(activeEditorFile.content || "");
                setSaveStatus('saved');
            } else {
                setContent("");
                setSaveStatus('saved');
            }
            setIsViewerMode(false); // 파일 변경 시 항상 편집 모드로
        }, [activeEditorFile]);
        
        const debouncedContent = useDebounce(content, 1000);
        
        useEffect(() => {
            // (v11.1) fileActions가 비어있을 수 있으므로 확인
            if (saveStatus === 'editing' && activeEditorFile && fileActions.updateContent && debouncedContent !== activeEditorFile.content) {
                setSaveStatus('saving');
                fileActions.updateContent(activeEditorFile.id, debouncedContent)
                    .then(() => {
                        setSaveStatus('saved');
                    })
                    .catch((err) => {
                         console.error("저장 실패:", err);
                         toast.show("❌ 파일 저장 실패.", 'error');
                         setSaveStatus('editing'); 
                    });
            } else if (saveStatus === 'editing' && activeEditorFile && debouncedContent === activeEditorFile.content) {
                setSaveStatus('saved');
            }
        }, [debouncedContent, activeEditorFile, fileActions, toast, saveStatus]);

        const handleGenerateQuiz = () => {
            if (!activeEditorFile) return;
            if (!content.trim()) {
                toast.show("❌ 파일에 원문이 없습니다.", 'error');
                return;
            }
            dispatchTask({
                taskType: 'generate',
                sourceText: content, 
                options: {
                    ...quizOptions,
                    fileId: activeEditorFile.id,
                    sourceFileName: activeEditorFile.name
                }
            });
        };
        
        const statusMessages = {
          'saved': '저장됨',
          'editing': '수정 중...',
          'saving': '저장 중...'
        };
        
        // (v11.1) 로그인 상태가 아니면 로그인 버튼 표시
        if (!userId) {
            return e('div', { className: 'main-editor-placeholder flex-col' },
                e('p', { className: 'mb-4' }, 'Google 계정(👤)으로 로그인하여 작업을 시작하세요.'),
                e('button', {
                    className: 'form-button !w-auto px-6',
                    onClick: handleGoogleSignIn
                }, 'Google 계정으로 로그인')
            );
        }

        if (!activeEditorFile) {
            return e('div', { className: 'main-editor-placeholder' }, '파일 탐색기(📄)에서 파일을 선택하세요.');
        }

        return e('div', { className: 'flex flex-col h-full' },
            e('div', { className: 'main-editor-header' },
                e('span', { className: 'main-editor-title' }, activeEditorFile.name),
                
                // (v12.0) 편집/보기 토글 버튼
                e('div', { className: 'editor-toggle-group' },
                    e('button', {
                        className: `editor-toggle-btn ${!isViewerMode ? 'active' : ''}`,
                        onClick: () => setIsViewerMode(false)
                    }, '편집'),
                    e('button', {
                        className: `editor-toggle-btn ${isViewerMode ? 'active' : ''}`,
                        onClick: () => setIsViewerMode(true)
                    }, '보기')
                ),
                
                e('button', { 
                    className: 'main-editor-action-btn',
                    onClick: handleGenerateQuiz,
                    disabled: saveStatus !== 'saved' || !content.trim()
                }, '✨ 퀴즈 생성')
            ),

            // (v12.0) 조건부 렌더링
            isViewerMode
                ? e(MarkdownViewer, { markdownText: content })
                : e('textarea', {
                    key: activeEditorFile.id,
                    className: 'main-editor',
                    value: content,
                    onChange: (ev) => {
                        setContent(ev.target.value);
                        setSaveStatus('editing');
                    }
                  }),

            e('div', { className: 'main-editor-footer' }, statusMessages[saveStatus])
        );
    };
    
    // 뷰 6: 설정 모달 (v12.0)
    const SettingsModal = ({ onClose }) => {
        const { userSettings, saveSettings } = useContext(AppContext);
        const [activeTab, setActiveTab] = useState('Quiz Defaults');
        
        const [apiKeys, setApiKeys] = useState([]);
        const [newApiKey, setNewApiKey] = useState("");
        const [quizSystemPrompt, setQuizSystemPrompt] = useState("");
        const [gradingSystemPrompt, setGradingSystemPrompt] = useState("");
        const [defaultSettings, setDefaultSettings] = useState({});
        const [modelName, setModelName] = useState(""); // (v12.0) 모델명 상태

        useEffect(() => {
            if (userSettings) {
                setApiKeys(userSettings.apiKeys || DEFAULT_SETTINGS.apiKeys);
                setQuizSystemPrompt(userSettings.quizSystemPrompt || DEFAULT_SETTINGS.quizSystemPrompt);
                setGradingSystemPrompt(userSettings.gradingSystemPrompt || DEFAULT_SETTINGS.gradingSystemPrompt);
                setModelName(userSettings.modelName || DEFAULT_SETTINGS.modelName); // (v12.0) 모델명 로드
                setDefaultSettings({
                    defaultDifficulty: userSettings.defaultDifficulty || DEFAULT_SETTINGS.defaultDifficulty,
                    defaultQuestionType: userSettings.defaultQuestionType || DEFAULT_SETTINGS.defaultQuestionType,
                    defaultNumQuestions: userSettings.defaultNumQuestions || DEFAULT_SETTINGS.defaultNumQuestions
                });
            }
        }, [userSettings]);
        
        const handleAddApiKey = () => {
            if (newApiKey.trim()) {
                setApiKeys([...apiKeys, { key: newApiKey.trim(), rpm: 60 }]);
                setNewApiKey("");
            }
        };
        
        const handleRemoveApiKey = (index) => {
            setApiKeys(apiKeys.filter((_, i) => i !== index));
        };
        
        const handleDefaultChange = (key, value) => {
            setDefaultSettings(prev => ({...prev, [key]: value}));
        };

        const handleSave = () => {
            saveSettings({
                apiKeys,
                ...defaultSettings,
                quizSystemPrompt,
                gradingSystemPrompt,
                modelName: modelName // (v12.0) 모델명 저장
            });
            onClose();
        };

        const renderTabContent = () => {
            if (activeTab === 'API Keys') {
                return e('div', null,
                    e('h3', { className: 'text-lg font-semibold mb-4' }, 'API Configuration'),
                    
                    // (v12.0) 모델 이름 설정 UI 추가
                    e('div', { className: 'form-group' },
                        e('label', { htmlFor: 'model-name-input', className: 'form-label' }, 'Gemini Model Name'),
                        e('input', { 
                            id: 'model-name-input', type: 'text', className: 'form-input',
                            value: modelName, 
                            onChange: (ev) => setModelName(ev.target.value),
                            placeholder: 'e.g., gemini-2.5-flash'
                        }),
                        e('p', { className: 'text-xs text-gray-400 mt-1' }, '사용할 Gemini 모델 ID를 입력하세요.')
                    ),

                    e('div', { className: 'form-group' },
                        e('label', { htmlFor: 'api-key-input', className: 'form-label' }, 'New API Key'),
                        e('div', { className: 'flex gap-2' },
                            e('input', { 
                                id: 'api-key-input', type: 'password', className: 'form-input flex-grow',
                                value: newApiKey, onChange: (ev) => setNewApiKey(ev.target.value)
                            }),
                            e('button', { type: 'button', onClick: handleAddApiKey, className: 'modal-button-secondary' }, 'Add')
                        )
                    ),
                    e('div', { className: 'mt-6' },
                        e('label', { className: 'form-label' }, 'Saved Keys'),
                        apiKeys.map((key, index) => e('div', { key: index, className: 'api-key-item' },
                            e('span', { className: 'font-mono' }, `**********${key.key.slice(-4)}`),
                            e('button', { onClick: () => handleRemoveApiKey(index), className: 'api-key-delete-btn' }, 'Remove')
                        ))
                    )
                );
            }
            if (activeTab === 'Quiz Defaults') {
                return e('div', null,
                    e('h3', { className: 'text-lg font-semibold mb-4' }, 'Default Quiz Generation'),
                    e('div', { className: 'grid grid-cols-2 gap-4' },
                        e('div', { className: 'form-group' },
                            e('label', { htmlFor: 'def-difficulty', className: 'form-label' }, 'Default Difficulty'),
                            e('select', { 
                                id: 'def-difficulty', className: 'form-select',
                                value: defaultSettings.defaultDifficulty, 
                                onChange: (ev) => handleDefaultChange('defaultDifficulty', ev.target.value)
                            },
                                e('option', { value: 'Easy' }, '쉬움'),
                                e('option', { value: 'Medium' }, '보통'),
                                e('option', { value: 'Hard' }, '어려움')
                            )
                        ),
                        e('div', { className: 'form-group' },
                            e('label', { htmlFor: 'def-q-type', className: 'form-label' }, 'Default Question Type'),
                            e('select', {
                                id: 'def-q-type', className: 'form-select',
                                value: defaultSettings.defaultQuestionType, 
                                onChange: (ev) => handleDefaultChange('defaultQuestionType', ev.target.value)
                            },
                                Object.entries(QUESTION_TYPE_MAP).map(([value, label]) => 
                                    e('option', { key: value, value: value }, label)
                                )
                            )
                        )
                    ),
                    e('div', { className: 'form-group' },
                        e('label', { htmlFor: 'def-num-q', className: 'form-label' }, 'Default Number of Questions'),
                        e('input', {
                            id: 'def-num-q', type: 'number', className: 'form-input',
                            value: defaultSettings.defaultNumQuestions, 
                            onChange: (ev) => handleDefaultChange('defaultNumQuestions', parseInt(ev.target.value, 10))
                        })
                    )
                );
            }
            if (activeTab === 'Prompts') {
                return e('div', { className: 'flex flex-col h-full' },
                    e('h3', { className: 'text-lg font-semibold mb-4' }, 'Quiz System Prompt'),
                    e('p', { className: 'text-xs text-gray-500 mb-4' }, '변수: {{DIFFICULTY}}, {{QUESTION_TYPE}}, {{NUM_QUESTIONS}}, {{CUSTOM_INSTRUCTIONS}} 등'),
                    e('textarea', {
                        className: 'form-textarea flex-grow h-full',
                        style: { height: '150px' },
                        value: quizSystemPrompt,
                        onChange: (e) => setQuizSystemPrompt(e.target.value)
                    }),
                    e('h3', { className: 'text-lg font-semibold mb-4 mt-6' }, 'Grading System Prompt'),
                    e('p', { className: 'text-xs text-gray-500 mb-4' }, '변수: (UserQuery에서 자동 주입됨)'),
                    e('textarea', {
                        className: 'form-textarea flex-grow h-full',
                        style: { height: '150px' },
                        value: gradingSystemPrompt,
                        onChange: (e) => setGradingSystemPrompt(e.target.value)
                    })
                );
            }
            return null;
        };
        
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', onClick: (e) => e.stopPropagation() },
                e('div', { className: 'modal-header' },
                    e('h2', null, 'Settings'),
                    e('button', { className: 'modal-close-btn', onClick: onClose }, '×')
                ),
                e('div', { className: 'modal-body' },
                    e('nav', { className: 'settings-nav' },
                        e('div', { 
                            className: 'settings-nav-item', 'data-active': activeTab === 'Quiz Defaults',
                            onClick: () => setActiveTab('Quiz Defaults')
                        }, 'Quiz Defaults'),
                        e('div', { 
                            className: 'settings-nav-item', 'data-active': activeTab === 'API Keys',
                            onClick: () => setActiveTab('API Keys')
                        }, 'API Keys'),
                        e('div', { 
                            className: 'settings-nav-item', 'data-active': activeTab === 'Prompts',
                            onClick: () => setActiveTab('Prompts')
                        }, 'Prompts')
                    ),
                    e('div', { className: 'settings-content' }, renderTabContent())
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: onClose }, 'Cancel'),
                    e('button', { className: 'modal-button-primary', onClick: handleSave }, 'Save Changes')
                )
            )
        );
    };
    
    // (v11.0) 파일 메모 에디터 (Firebase)
    const FileNotesEditor = ({ activeFile, fileActions }) => {
        const [notes, setNotes] = useState("");
        useEffect(() => {
            setNotes(activeFile?.metadata?.notes || "");
        }, [activeFile]);
        
        const debouncedNotes = useDebounce(notes, 1000);
        
        useEffect(() => {
            if (activeFile && fileActions.updateMetadata && debouncedNotes === notes && debouncedNotes !== (activeFile.metadata?.notes || "")) {
                fileActions.updateMetadata(activeFile.id, { notes: debouncedNotes });
            }
        }, [debouncedNotes, notes, activeFile, fileActions]);
        
        return e('div', { className: 'h-full flex flex-col' },
            e('textarea', {
                key: activeFile.id,
                className: 'main-editor !p-4',
                style: { height: '100%' },
                value: notes,
                onChange: (ev) => setNotes(ev.target.value),
                placeholder: '이 파일에 대한 요약, 메모 또는 메타데이터를 입력하세요...'
            })
        );
    };


    // (v10) 검색 뷰
    const SearchView = ({ viewId }) => {
        const { files, setActiveEditorFile, handleActivityChange, userId } = useContext(AppContext);
        const [searchTerm, setSearchTerm] = useState("");
        const [results, setResults] = useState([]);
        const debouncedSearchTerm = useDebounce(searchTerm, 300);
        
        useEffect(() => {
            if (!debouncedSearchTerm || debouncedSearchTerm.length < 2 || !userId) {
                setResults([]);
                return;
            }
            const lowerTerm = debouncedSearchTerm.toLowerCase();
            const searchResults = files.filter(f => {
                if (f.type === 'folder') return false;
                const inName = f.name.toLowerCase().includes(lowerTerm);
                const inContent = f.content && f.content.toLowerCase().includes(lowerTerm);
                const inNotes = f.metadata?.notes && f.metadata.notes.toLowerCase().includes(lowerTerm);
                return inName || inContent || inNotes;
            });
            setResults(searchResults);
        }, [debouncedSearchTerm, files, userId]);
        
        const handleResultClick = (file) => {
            setActiveEditorFile(file);
            if(handleActivityChange) {
                handleActivityChange('files', true);
            }
        };
        
        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, '전체 검색'),
            e('div', { className: 'view-content-full p-4' },
                e('div', { className: 'form-group' },
                    e('input', {
                        type: 'text',
                        className: 'form-input',
                        placeholder: '파일 이름, 내용, 메모 검색...',
                        value: searchTerm,
                        onChange: (e) => setSearchTerm(e.target.value),
                        autoFocus: true,
                        disabled: !userId // (v11.1)
                    })
                ),
                e('div', { className: 'mt-4' },
                    !userId && e('p', { className: 'text-sm text-gray-400 text-center' }, '로그인(👤)하여 검색하세요.'),
                    userId && results.length === 0 && debouncedSearchTerm.length > 1 &&
                        e('p', { className: 'text-sm text-gray-400' }, '검색 결과가 없습니다.'),
                    userId && results.map(file => e('div', {
                        key: file.id,
                        className: 'list-item',
                        onClick: () => handleResultClick(file)
                    },
                        e('div', { className: 'list-item-title' }, file.name)
                    ))
                )
            )
        );
    };
    
    // (v11.1) 사용자 뷰 (Google Auth)
    const UserView = ({ viewId }) => {
        const { userInfo, handleGoogleSignIn, handleSignOut } = useContext(AppContext);

        if (userInfo) {
            return e('div', { viewId, className: 'flex flex-col h-full' },
                e('h3', { className: 'view-header' }, '사용자 프로필'),
                e('div', { className: 'view-content-scroll flex flex-col items-center' },
                    e('img', { 
                        src: userInfo.photoURL || 'https://placehold.co/80x80/3c3c3c/cccccc?text=User',
                        className: 'w-20 h-20 rounded-full mt-4 mb-2 border-2 border-gray-500',
                        alt: 'User profile picture'
                    }),
                    e('p', { className: 'text-lg font-semibold text-white text-center' }, userInfo.displayName || 'User'),
                    e('p', { className: 'text-xs text-gray-400 mb-4 break-all px-2 text-center' }, userInfo.uid),
                    e('button', { 
                        className: 'form-button !w-auto px-6 !bg-red-600 hover:!bg-red-700',
                        onClick: handleSignOut 
                    }, '로그아웃')
                )
            );
        }

        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, '로그인'),
            e('div', { className: 'view-content-scroll flex flex-col items-center justify-center' },
                e('p', { className: 'text-sm text-gray-400 mb-4 text-center' }, 'Google 계정으로 로그인하여<br/>작업물을 클라우드에 저장하세요.'),
                e('button', { 
                    className: 'form-button !w-auto px-6',
                    onClick: handleGoogleSignIn 
                }, 'Google 계정으로 로그인')
            )
        );
    };
    
    // 뷰 8: 퀴즈 풀이 모달
    const QuizTaker = ({ quiz, onClose, onQuizSubmit }) => {
        const [questions, setQuestions] = useState([]);
        const [currentAnswers, setCurrentAnswers] = useState({});
        useEffect(() => {
            try {
                const parsedQuestions = JSON.parse(quiz.questions);
                setQuestions(parsedQuestions);
            } catch (e) { console.error("퀴즈 질문 파싱 오류:", e); }
        }, [quiz]);
        const handleAnswerChange = (qIndex, value) => {
            setCurrentAnswers(prev => ({ ...prev, [qIndex]: value }));
        };
        const handleSubmit = () => {
            let score = 0;
            const userAnswers = questions.map((q, qIndex) => {
                let isCorrect = false;
                const selectedAnswer = currentAnswers[qIndex];
                switch (q.questionType) {
                    case 'MultipleChoice':
                        isCorrect = (selectedAnswer === q.correctAnswerIndex);
                        if (isCorrect) score++;
                        break;
                    default: 
                        isCorrect = null;
                        break;
                }
                return {
                    questionType: q.questionType,
                    questionText: q.questionText,
                    options: q.options,
                    selectedAnswer: selectedAnswer,
                    correctAnswerIndex: q.correctAnswerIndex,
                    gradingCriteria: q.gradingCriteria,
                    isCorrect: isCorrect
                };
            });
            const result = {
                // (v11.0) id는 Firestore에서 자동 생성되므로 제거
                quizId: quiz.id,
                fileId: quiz.fileId,
                quizTitle: quiz.title,
                score: score,
                total: questions.length,
                answers: JSON.stringify(userAnswers),
                completedAt: new Date().toISOString()
            };
            onQuizSubmit(result);
        };
        const renderQuestion = (q, qIndex) => {
            switch (q.questionType) {
                case 'MultipleChoice':
                    return e('div', { className: 'options-container' },
                        (q.options || []).map((option, oIndex) => e('label', { key: oIndex, className: 'quiz-option-label' },
                            e('input', {
                                type: 'radio',
                                name: `question-${qIndex}`,
                                checked: currentAnswers[qIndex] === oIndex,
                                onChange: () => handleAnswerChange(qIndex, oIndex)
                            }),
                            option
                        ))
                    );
                default:
                    return e('div', { className: 'form-group' },
                        e('textarea', { // input에서 textarea로 변경
                            className: 'form-input',
                            rows: 3,
                            value: currentAnswers[qIndex] || "",
                            onChange: (ev) => handleAnswerChange(qIndex, ev.target.value)
                        })
                    );
            }
        };
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', style: { maxWidth: '800px' }, onClick: (e) => e.stopPropagation() },
                e('div', { className: 'modal-header' },
                    e('h2', null, quiz.title)
                ),
                e('div', { className: 'modal-body', style: { padding: '24px', display: 'block' } },
                    questions.map((q, qIndex) => e('div', { key: qIndex, className: 'quiz-question-card' },
                        e('p', { className: 'quiz-question-text' }, `${qIndex + 1}. ${q.questionText}`),
                        renderQuestion(q, qIndex)
                    ))
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: onClose }, '취소'),
                    e('button', { className: 'modal-button-primary', onClick: handleSubmit }, '퀴즈 제출')
                )
            )
        );
    };
    
    // 뷰 9: 퀴즈 결과 모달
    const QuizResult = ({ attempt, quiz, onClose, dispatchGradingTask }) => {
        const { setModalContent } = useContext(AppContext);
        const toast = useToast();
        const [results, setResults] = useState([]);
        useEffect(() => {
            try { setResults(JSON.parse(attempt.answers)); }
            catch(e) { console.error("결과 파싱 오류", e); }
        }, [attempt]);
        
        const handleGradeAllSubjective = async () => {
            dispatchGradingTask(attempt);
            toast.show("AI 채점을 시작합니다. (작업 모니터 📊)", 'info');
            onClose();
        };
        
        const retryIncorrect = () => {
            toast.show("오답 다시 풀기 기능은 구현 중입니다.", 'info');
        };
        
        const renderResultAnswer = (res, index) => {
            if (res.isCorrect === null) {
                return e(React.Fragment, null,
                    e('p', { className: 'result-answer yours' }, 
                        `제출한 답: ${res.selectedAnswer || 'N/A'}`
                    ),
                    e('p', { className: 'result-answer correct text-xs mt-2' }, 
                        `[채점 기준] ${res.gradingCriteria || 'N/A'}`
                    ),
                    e('p', { className: 'text-sm text-yellow-400 mt-2' }, 'AI 채점 대기 중...')
                );
            }
            let answerContent;
            switch(res.questionType) {
                case 'MultipleChoice':
                    answerContent = e(React.Fragment, null,
                        e('p', { className: 'result-answer correct' }, 
                            `정답: ${res.options[res.correctAnswerIndex]}`
                        ),
                        !res.isCorrect && e('p', { className: 'result-answer yours' }, 
                            `선택한 답: ${res.options[res.selectedAnswer] || 'N/A'}`
                        )
                    );
                    break;
                default:
                    answerContent = e(React.Fragment, null,
                        e('p', { className: 'result-answer correct' }, 
                            `채점 기준: ${res.gradingCriteria || 'N/A'}`
                        ),
                        e('p', { className: 'result-answer yours' }, 
                            `제출한 답: ${res.selectedAnswer || 'N/A'}`
                        )
                    );
                    break;
            }
            return e(React.Fragment, null, 
                answerContent,
                res.feedback && e('div', { className: 'mt-2 p-2 bg-gray-800 rounded' },
                    e('p', { className: 'text-xs font-semibold text-blue-300' }, 'AI 첨삭:'),
                    e('p', { className: 'text-sm' }, res.feedback)
                )
            );
        };
        const hasSubjectiveToGrade = useMemo(() => {
            return results.some(r => r.isCorrect === null);
        }, [results]);
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', onClick: (e) => e.stopPropagation() },
                e('div', { className: 'modal-header' },
                    e('h2', null, '퀴즈 결과: ' + attempt.quizTitle),
                    e('button', { className: 'modal-close-btn', onClick: onClose }, '×')
                ),
                e('div', { className: 'modal-body quiz-result-body', style: { display: 'block' } },
                    e('div', { className: 'quiz-result-score mb-6' }, 
                        `점수: ${attempt.score} / ${attempt.total}`
                    ),
                    results.map((res, index) => e('div', { 
                        key: index, 
                        className: `result-question ${res.isCorrect === true ? 'result-question-correct' : (res.isCorrect === false ? 'result-question-incorrect' : 'bg-gray-700')}`
                    },
                        e('p', { className: 'result-question-text' }, `${index + 1}. ${res.questionText}`),
                        renderResultAnswer(res, index)
                    ))
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: retryIncorrect }, '틀린 문제 다시 풀기'),
                    hasSubjectiveToGrade && e('button', { 
                        className: 'modal-button-primary', 
                        onClick: handleGradeAllSubjective,
                    }, '✨ 전체 AI 채점'),
                    e('button', { className: 'modal-button-primary', onClick: onClose }, '닫기')
                )
            )
        );
    };


    // --- 5. 메인 앱 컴포넌트 (v11.1 - Google Auth) ---
    const App = () => {
      const toast = useToast(); 
      const [isLoading, setIsLoading] = useState(true);
      const [userSettings, setUserSettings] = useState(DEFAULT_SETTINGS);
      const [modalContent, setModalContent] = useState(null);
      const [activeViewId, setActiveViewId] = useState('files');
      const [isSidebarVisible, setIsSidebarVisible] = useState(true);
      const [activeEditorFile, setActiveEditorFile] = useState(null);
      const [editingNodeId, setEditingNodeId] = useState(null);
      
      // (v11.0) Firebase 상태
      const [db, setDb] = useState(null);
      const [auth, setAuth] = useState(null);
      const [userId, setUserId] = useState(null);
      const [appId, setAppId] = useState('default-app-id');
      
      // (v11.1) 사용자 정보 상태 (프로필 사진, 이름 등)
      const [userInfo, setUserInfo] = useState(null);
      const authAttempted = useRef(false); // (v11.1) 커스텀 토큰 재시도 방지
      
      const QUIZ_OPTIONS_STORAGE_KEY = 'aiQuiz_quizOptions_v10';
      const getInitialQuizOptions = (settings) => {
          try {
              const savedOptions = localStorage.getItem(QUIZ_OPTIONS_STORAGE_KEY);
              if (savedOptions) {
                  return JSON.parse(savedOptions);
              }
          } catch (e) { console.error("Failed to parse saved quiz options", e); }
          return {
              numQuestions: settings.defaultNumQuestions || 10,
              difficulty: settings.defaultDifficulty || "Medium",
              questionType: settings.defaultQuestionType || "MultipleChoice",
              includeSnippets: false,
              provideAnswerKey: true,
              customInstructions: ""
          };
      };
      const [quizOptions, _setQuizOptions] = useState(() => getInitialQuizOptions(DEFAULT_SETTINGS));
      const setQuizOptions = useCallback((updater) => {
          _setQuizOptions(prev => {
              const newState = typeof updater === 'function' ? updater(prev) : updater;
              localStorage.setItem(QUIZ_OPTIONS_STORAGE_KEY, JSON.stringify(newState));
              return newState;
          });
      }, []);
      
      const quizWorker = useMemo(() => new Worker(workerUrl), []);
      const [taskQueue, setTaskQueue] = useState([]);
      const [files, setFiles] = useState([]);
      const [quizzes, setQuizzes] = useState([]);
      const [attempts, setAttempts] = useState([]);

      // (v11.1) Firebase 초기화 및 인증 로직 수정
      useEffect(() => {
        const currentAppId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
        
        if (!firebaseConfigStr) {
            console.error("Firebase config is missing.");
            toast.show("❌ Firebase 설정 오류", "error");
            setIsLoading(false);
            return;
        }
        
        try {
            const firebaseConfig = JSON.parse(firebaseConfigStr);
            const fbApp = initializeApp(firebaseConfig);
            const fbAuth = getAuth(fbApp);
            const fbDb = getFirestore(fbApp);
            
            setLogLevel('Debug'); // Firestore 로깅
            
            setDb(fbDb);
            setAuth(fbAuth);
            setAppId(currentAppId);

            onAuthStateChanged(fbAuth, async (user) => {
                if (user) {
                    // 로그인 성공
                    console.log("Firebase Auth: User signed in.", user.uid, user.displayName);
                    setUserId(user.uid);
                    setUserInfo({ // (v11.1) 전체 사용자 정보 저장
                        uid: user.uid,
                        displayName: user.displayName,
                        email: user.email,
                        photoURL: user.photoURL
                    });
                    setIsLoading(false);
                } else {
                    // 로그아웃 상태
                    console.log("Firebase Auth: No user.");
                    setUserId(null);
                    setUserInfo(null);
                    
                    // (v11.1) 커스텀 토큰이 있으면 1회 시도, 없으면 그냥 로그아웃 상태로 로딩 완료
                    if (typeof __initial_auth_token !== 'undefined' && !authAttempted.current) {
                        authAttempted.current = true; // 중복 시도 방지
                        try {
                            console.log("Firebase Auth: Attempting custom token sign-in...");
                            await signInWithCustomToken(fbAuth, __initial_auth_token);
                            // 성공하면 onAuthStateChanged가 'user'와 함께 다시 호출됨
                        } catch (authError) {
                            console.error("Firebase Auth: Custom token sign-in failed", authError);
                            toast.show(`❌ 토큰 인증 실패: ${authError.message}`, "error");
                            setIsLoading(false); // 토큰 실패 시에도 로딩 완료
                        }
                    } else {
                        // 커스텀 토큰이 없거나 이미 시도했으면, 로그아웃 상태로 로딩 완료
                        setIsLoading(false);
                    }
                }
            });
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            toast.show(`❌ Firebase 초기화 실패: ${e.message}`, "error");
            setIsLoading(false);
        }
      }, [toast]); // (v11.1) 의존성 배열에서 toast 제거 (함수가 아니므로) -> 아님, 훅이므로 유지
      
      // (v11.0) Firestore 실시간 리스너
      useEffect(() => {
        // (v11.1) userId가 null이면(로그아웃) 리스너를 설정하지 않고, 기존 데이터 클린업
        if (!db || !userId) {
            setFiles([]);
            setQuizzes([]);
            setAttempts([]);
            setTaskQueue([]);
            setActiveEditorFile(null);
            return; // 리스너 설정 중단
        }

        console.log(`Setting up snapshots for user: ${userId}, app: ${appId}`);

        const getCollectionRef = (collName) => collection(db, `artifacts/${appId}/users/${userId}/${collName}`);

        // 1. Files listener
        const filesQuery = query(getCollectionRef('files'));
        const filesUnsub = onSnapshot(filesQuery, (querySnapshot) => {
            const filesData = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setFiles(filesData);
            console.log("Snapshot: Files updated", filesData.length);
        }, (error) => console.error("Snapshot Error (Files):", error));
        
        // 2. Quizzes listener
        const quizzesQuery = query(getCollectionRef('quizzes'));
        const quizzesUnsub = onSnapshot(quizzesQuery, (querySnapshot) => {
            const quizzesData = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setQuizzes(quizzesData);
            console.log("Snapshot: Quizzes updated", quizzesData.length);
        }, (error) => console.error("Snapshot Error (Quizzes):", error));

        // 3. Attempts listener
        const attemptsQuery = query(getCollectionRef('quizAttempts'));
        const attemptsUnsub = onSnapshot(attemptsQuery, (querySnapshot) => {
            const attemptsData = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            setAttempts(attemptsData);
            console.log("Snapshot: Attempts updated", attemptsData.length);
        }, (error) => console.error("Snapshot Error (Attempts):", error));

        // 4. Settings listener
        const settingsRef = doc(db, `artifacts/${appId}/users/${userId}/settings/userConfig`);
        const settingsUnsub = onSnapshot(settingsRef, (docSnap) => {
            if (docSnap.exists()) {
                const settingsData = docSnap.data();
                setUserSettings(settingsData);
                _setQuizOptions(getInitialQuizOptions(settingsData)); 
                console.log("Snapshot: Settings updated");
            } else {
                setUserSettings(DEFAULT_SETTINGS);
                _setQuizOptions(getInitialQuizOptions(DEFAULT_SETTINGS));
                console.log("Snapshot: No settings found, using default.");
            }
        }, (error) => console.error("Snapshot Error (Settings):", error));

        // Cleanup function
        return () => {
            console.log("Cleaning up snapshots...");
            filesUnsub();
            quizzesUnsub();
            attemptsUnsub();
            settingsUnsub();
        };
      }, [db, userId, appId]);
      
      const { fileTree, fileActions } = useFileSystem(files, db, userId, appId);
      
      // Worker (퀴즈 생성/채점) 콜백
      useEffect(() => {
        quizWorker.onmessage = (e) => {
          if (!userId) return; // (v11.1) 로그아웃 상태면 메시지 무시
          
          const { status, taskId, taskType, quizData, updatedAttempt, error, options } = e.data; 
          
          setTaskQueue(prev => prev.map(task => 
              task.id === taskId ? { ...task, status, error } : task
          ));
          
          if (status === 'success') {
            if (taskType === 'grade' && updatedAttempt) {
                // (v11.0) Firestore에 채점 결과 업데이트
                const attemptRef = doc(db, `artifacts/${appId}/users/${userId}/quizAttempts`, updatedAttempt.id);
                updateDoc(attemptRef, updatedAttempt)
                    .then(() => toast.show('✅ AI 채점이 완료되었습니다.', 'success'))
                    .catch(err => toast.show(`❌ 채점 결과 저장 실패: ${err.message}`, 'error'));
                
            } else if (taskType === 'generate' && quizData) {
                // (v11.0) Firestore에 새 퀴즈 추가
                const newQuiz = {
                    // id는 Firestore가 자동 생성
                    title: quizData.title,
                    sourceText: "N/A", 
                    fileId: options.fileId, 
                    sourceFileName: options.sourceFileName,
                    questions: JSON.stringify(quizData.questions),
                    createdAt: new Date().toISOString(),
                    questionCount: quizData.questions.length,
                    options: options,
                    userId: userId
                };
                addDoc(collection(db, `artifacts/${appId}/users/${userId}/quizzes`), newQuiz)
                    .then(() => toast.show('✨ 퀴즈 생성이 완료되었습니다.', 'success'))
                    .catch(err => toast.show(`❌ 퀴즈 저장 실패: ${err.message}`, 'error'));
            }
          } else if (status === 'error') {
              console.error(`Task ${taskId} (${taskType}) failed: ${error}`);
              if (toast) toast.show(`❌ 작업 실패: ${error}`, 'error');
          }
        };
        return () => { quizWorker.onmessage = null; };
      }, [quizWorker, db, userId, appId, toast]);
      
      // (v12.0) 설정 저장 (Firestore) - 모델명 저장 로직 포함
      const handleSaveSettings = useCallback(async (newSettings) => {
          if (!db || !userId) {
              toast.show('❌ 로그인이 필요합니다.', 'error');
              return;
          }
          const settingsRef = doc(db, `artifacts/${appId}/users/${userId}/settings/userConfig`);
          try {
              // newSettings에 modelName이 포함되어 있는지 확인
              const settingsToSave = {
                  ...newSettings,
                  modelName: newSettings.modelName || DEFAULT_SETTINGS.modelName
              };
              await setDoc(settingsRef, settingsToSave, { merge: true });
              toast.show('✅ 설정이 저장되었습니다.', 'success');
              // onSnapshot이 자동으로 userSettings를 업데이트
          } catch (e) {
              console.error("설정 저장 실패:", e);
              toast.show(`❌ 설정 저장 실패: ${e.message}`, 'error');
          }
      }, [db, userId, appId, toast]);

      const handleActivityChange = (id, forceVisible = false) => {
          if (id === 'settings') {
              if (!userId) { // (v11.1) 로그인 확인
                  toast.show('설정을 보려면 먼저 로그인(👤)하세요.', 'info');
                  handleActivityChange('user');
                  return;
              }
              setModalContent(e(SettingsModal, { onClose: () => setModalContent(null) }));
              return;
          }
          if (id === activeViewId && isSidebarVisible && !forceVisible) setIsSidebarVisible(false);
          else { setIsSidebarVisible(true); setActiveViewId(id); }
      };
      
      const dispatchTask = useCallback((taskData) => {
          if (!userId) { // (v11.1) 로그인 확인
              toast.show('❌ 로그인이 필요합니다.', 'error');
              return;
          }
          const taskId = crypto.randomUUID();
          const newTask = { ...taskData, id: taskId, status: 'processing', taskType: 'generate' };
          setTaskQueue(prev => [newTask, ...prev]);
          quizWorker.postMessage({ ...newTask, settings: userSettings, DEFAULT_SETTINGS });
          handleActivityChange('tasks');
          if (toast) toast.show('✨ 퀴즈 생성을 시작합니다.', 'info');
      }, [quizWorker, userSettings, toast, userId]);
      
      const dispatchGradingTask = useCallback((attempt) => {
          if (!userId) { // (v11.1) 로그인 확인
              toast.show('❌ 로그인이 필요합니다.', 'error');
              return;
          }
          const taskId = crypto.randomUUID();
          const newTask = { 
              id: taskId, 
              status: 'processing', 
              taskType: 'grade',
              options: { quizTitle: attempt.quizTitle }
          };
          setTaskQueue(prev => [newTask, ...prev]);
          quizWorker.postMessage({ ...newTask, attempt, settings: userSettings, DEFAULT_SETTINGS });
          handleActivityChange('tasks');
      }, [quizWorker, userSettings, userId]);

      // (v11.0) 퀴즈 제출 (Firestore)
      const handleQuizSubmit = async (result) => {
          if (!db || !userId) {
              toast.show('❌ 로그인이 필요합니다.', 'error');
              return;
          }
          
          try {
              const attemptWithUser = { ...result, userId: userId };
              const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/quizAttempts`), attemptWithUser);
              
              const newAttempt = { ...attemptWithUser, id: docRef.id };
              
              setModalContent(e(QuizResult, {
                  attempt: newAttempt,
                  quiz: quizzes.find(q => q.id === newAttempt.quizId),
                  onClose: () => setModalContent(null),
                  userSettings,
                  dispatchGradingTask
              }));
          } catch (err) { 
              console.error("퀴즈 제출 오류:", err); 
              toast.show(`❌ 퀴즈 제출 실패: ${err.message}`, 'error');
          }
      };
      
      // (v11.1) Google 로그인/로그아웃 함수
      const handleGoogleSignIn = async () => {
          if (!auth) return;
          const provider = new GoogleAuthProvider();
          try {
              await signInWithPopup(auth, provider);
              // onAuthStateChanged가 결과를 처리
              toast.show('✅ 로그인 성공!', 'success');
              handleActivityChange('files'); // 로그인 후 파일 뷰로 이동
          } catch (error) {
              console.error("Google Sign-In Error:", error);
              toast.show(`❌ 로그인 실패: ${error.message}`, 'error');
          }
      };

      const handleSignOut = async () => {
          if (!auth) return;
          try {
              await signOut(auth);
              // onAuthStateChanged가 결과를 처리 (userId=null)
              toast.show('로그아웃되었습니다.', 'info');
              setActiveEditorFile(null); // (v11.1) 로그아웃 시 활성 파일 닫기
          } catch (error) {
              console.error("Sign-Out Error:", error);
              toast.show(`❌ 로그아웃 실패: ${error.message}`, 'error');
          }
      };

      const contextValue = {
          db,
          userId,
          userInfo, // (v11.1)
          appId,
          userSettings,
          saveSettings: handleSaveSettings,
          files,
          quizzes,
          attempts,
          taskQueue,
          dispatchTask,
          dispatchGradingTask,
          fileTree,
          fileActions,
          activeEditorFile,
          setActiveEditorFile,
          setModalContent,
          editingNodeId,
          setEditingNodeId,
          quizOptions, 
          setQuizOptions,
          handleQuizSubmit,
          toast,
          handleActivityChange,
          handleGoogleSignIn, // (v11.1)
          handleSignOut       // (v11.1)
      };

      const sidebarItems = [
        { id: 'files', label: '파일 탐색기', icon: '📄' },
        { id: 'search', label: '검색', icon: '🔍' },
        { id: 'quiz-generator', label: '퀴즈 생성 옵션', icon: '✨' },
        { id: 'history', label: '전체 풀이 기록', icon: '📚' },
        { id: 'tasks', label: '작업 모니터', icon: '📊' },
        { id: 'user', label: '사용자', icon: '👤', isBottom: true },
        { id: 'settings', label: '설정', icon: '⚙️', isBottom: true },
      ];
      
      if (isLoading) {
        return e('div', { className: 'flex items-center justify-center h-screen' }, 
            e(Spinner),
            e('p', { className: 'ml-4' }, 'Firebase 인증 확인 중...')
        );
      }

      return e(AppContext.Provider, { value: contextValue },
        e('div', { className: 'flex h-screen' },
          e(ReactVscodeSidebar, {
            items: sidebarItems,
            onActiveChange: handleActivityChange,
            activeId: activeViewId,
            isVisible: isSidebarVisible
          },
            // 뷰 컨텐츠 (Children)
            e(FileManagerView, { viewId: 'files' }),
            e(SearchView, { viewId: 'search' }),
            e(QuizGeneratorView, { viewId: 'quiz-generator' }),
            e(QuizHistoryView, { viewId: 'history' }),
            e(TaskMonitorView, { viewId: 'tasks' }),
            e(UserView, { viewId: 'user' }) // (v11.1) 이 뷰가 이제 로그인/로그아웃 UI를 처리
          ),
          
          e('div', { className: 'main-content' }, 
            e(MainContentEditor, null)
          ),
          
          modalContent
        )
      );
    };

    // --- 6. 앱 마운트 ---
    const root = createRoot(document.getElementById('root'));
    root.render(e(ToastProvider, null, e(App)));
    
  </script>
</body>
</html>
