<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- (v10.2) ÌÉÄÏù¥ÌãÄ ÏóÖÎç∞Ïù¥Ìä∏ -->
  <title>AI ÌÄ¥Ï¶à VSCode (v10.2 - ÏÇ¨Ïù¥ÎìúÎ∞î Ìå®Ïπò)</title>

  <!-- 1. ÏùòÏ°¥ÏÑ± Î°úÎìú: React, Tailwind, JSZip -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  
  <!-- 2. Ïä§ÌÉÄÏùº (v10.1Í≥º ÎèôÏùº) -->
  <style>
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
        Helvetica, Arial, sans-serif;
      margin: 0;
      background-color: #1e1e1e;
      color: #cccccc;
      height: 100vh;
      overflow: hidden;
    }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #252526; }
    ::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #5a5a5a; }
    .vsc-sidebar-container {
      display: flex;
      flex-direction: row;
      width: auto;
      height: 100vh;
    }
    .vsc-activity-bar {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 8px 0;
      background-color: #333333;
      color: white;
      flex-shrink: 0;
      width: 52px;
    }
    .vsc-activity-item {
      background-color: transparent;
      border: none;
      color: #b0b0b0;
      padding: 12px;
      margin: 2px 4px;
      cursor: pointer;
      font-size: 24px;
      line-height: 1;
      border-radius: 4px;
      transition: background-color 0.2s, color 0.2s;
    }
    .vsc-activity-item:hover { background-color: #404040; }
    .vsc-activity-item[data-active='true'] {
      color: #ffffff;
      background-color: #4a4a4a;
    }
    .vsc-sidebar-view {
      flex-grow: 1;
      overflow-y: auto;
      background-color: #252526;
      color: #cccccc;
      width: 300px;
      min-width: 300px;
      border-right: 1px solid #444;
      transition: min-width 0.2s ease-out, width 0.2s ease-out;
      overflow: hidden;
    }
    .vsc-sidebar-view[data-visible='false'] {
      width: 0px;
      min-width: 0px;
      border-right: none;
    }
    .vsc-view-content {
      height: 100%;
      min-width: 300px;
      display: flex;
      flex-direction: column;
    }
    .view-padding {
        padding: 16px;
    }
    .view-header {
      margin-top: 0;
      color: #cccccc;
      font-size: 1.1rem;
      font-weight: 600;
      padding: 12px 16px;
      border-bottom: 1px solid #444;
      flex-shrink: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .view-header-icon {
        background: none; border: none; color: #b0b0b0; cursor: pointer;
        padding: 4px; border-radius: 4px;
    }
    .view-header-icon:hover { background-color: #4a4a4a; color: white; }
    .view-content-scroll {
        flex-grow: 1;
        overflow-y: auto;
        padding: 16px;
    }
    .view-content-full {
        flex-grow: 1;
        overflow-y: auto;
    }
    .vsc-view-panes {
        display: flex;
        flex-direction: column;
        height: 100%;
    }
    .vsc-view-pane {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    .vsc-view-pane-header {
        padding: 4px 12px;
        background-color: #333;
        font-size: 0.9rem;
        font-weight: 500;
        border-top: 1px solid #444;
        border-bottom: 1px solid #444;
    }
    .vsc-view-pane-content {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
    }
    .vsc-view-pane-content.full {
        padding: 0;
    }
    .vsc-view-pane-content.full[data-drag-over='true'] {
        background-color: #0e639c;
    }
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .main-editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background-color: #252526;
        border-bottom: 1px solid #444;
        flex-shrink: 0;
    }
    .main-editor-title {
        font-size: 0.9rem;
    }
    .main-editor-action-btn {
        background-color: #0e639c;
        color: white;
        padding: 4px 10px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
    }
    .main-editor-action-btn:hover { background-color: #1177bb; }
    .main-editor-action-btn:disabled { background-color: #555; cursor: not-allowed; }
    .main-editor {
      flex-grow: 1;
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: none;
      outline: none;
      padding: 20px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      line-height: 1.5;
      resize: none;
    }
    .main-editor.\!p-4 {
        padding: 1rem;
    }
    .main-editor-placeholder {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: #6a6a6a;
      font-size: 1.2rem;
    }
    .main-editor-footer {
        padding: 4px 12px;
        background-color: #252526;
        border-top: 1px solid #444;
        flex-shrink: 0;
        font-size: 0.8rem;
        color: #a0a0a0;
        text-align: right;
        min-height: 26px;
    }
    .form-group { margin-bottom: 16px; }
    .form-label {
        display: block;
        font-size: 0.9rem;
        margin-bottom: 6px;
        color: #a0a0a0;
        font-weight: 500;
    }
    .form-input, .form-textarea, .form-select {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      border: 1px solid #444;
      background-color: #3c3c3c;
      color: #cccccc;
      border-radius: 4px;
    }
    .form-textarea {
        font-family: 'Courier New', Courier, monospace;
    }
    .form-input.\!p-0.\!text-sm {
        padding: 0;
        font-size: 0.875rem;
    }
    .form-select {
        appearance: none;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239ca3af' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 0.5rem center;
        background-size: 1.2em 1.2em;
        padding-right: 2.5rem;
    }
    .form-checkbox-label {
        display: flex;
        align-items: center;
        font-size: 0.9rem;
        color: #cccccc;
        cursor: pointer;
    }
    .form-checkbox {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        background-color: #3c3c3c;
        border: 1px solid #444;
        border-radius: 3px;
    }
    .form-button {
      background-color: #0e639c;
      color: white;
      width: 100%;
      padding: 10px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      font-weight: 600;
    }
    .form-button:hover { background-color: #1177bb; }
    .form-button:disabled { background-color: #555; cursor: not-allowed; }
    .list-item {
      padding: 10px;
      background-color: #3c3c3c;
      border-radius: 4px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .list-item:hover { background-color: #4a4a4a; }
    .list-item-title { font-weight: 600; }
    .list-item-sub { font-size: 0.8rem; color: #a0a0a0; }
    .list-item-badge {
        font-size: 0.8rem;
        padding: 2px 6px;
        border-radius: 10px;
        background-color: #4a90e2;
        color: white;
    }
    .list-item-badge.success { background-color: #4CAF50; }
    .list-item-badge.error { background-color: #f44336; }
    .quiz-question-card { margin-bottom: 1.5rem; }
    .quiz-question-text { font-weight: 600; font-size: 1.1rem; margin-bottom: 0.75rem; }
    .quiz-option-label {
        display: block;
        padding: 10px;
        background-color: #3c3c3c;
        border-radius: 4px;
        margin-bottom: 8px;
        cursor: pointer;
    }
    .quiz-option-label:hover { background-color: #4a4a4a; }
    .quiz-option-label input { margin-right: 10px; }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .modal-container {
      background-color: #2d2d2d;
      color: #cccccc;
      border-radius: 8px;
      width: 90%;
      max-width: 700px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .modal-header {
      padding: 16px 24px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 { margin: 0; font-size: 1.2rem; }
    .modal-close-btn {
      background: none; border: none; color: #a0a0a0; font-size: 1.5rem;
      cursor: pointer; padding: 0; line-height: 1;
    }
    .modal-body {
      padding: 0;
      overflow-y: auto;
      display: flex;
      flex-grow: 1;
    }
    .modal-footer {
      padding: 16px 24px;
      border-top: 1px solid #444;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }
    .modal-button {
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }
    .modal-button-primary {
      background-color: #0e639c; color: white; border: none;
    }
    .modal-button-primary:hover { background-color: #1177bb; }
    .modal-button-secondary {
      background-color: #4a4a4a; color: #cccccc; border: none;
    }
    .modal-button-secondary:hover { background-color: #5a5a5a; }
    .settings-nav {
      width: 200px;
      flex-shrink: 0;
      padding: 24px 0;
      border-right: 1px solid #444;
    }
    .settings-nav-item {
      padding: 10px 24px;
      cursor: pointer;
      font-size: 0.9rem;
      border-left: 3px solid transparent;
    }
    .settings-nav-item:hover { background-color: #3c3c3c; }
    .settings-nav-item[data-active='true'] {
      background-color: #3c3c3c;
      border-left-color: #0e639c;
      color: white;
    }
    .settings-content {
      padding: 24px;
      flex-grow: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    .api-key-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        background-color: #3c3c3c;
        border-radius: 4px;
        margin-bottom: 8px;
    }
    .api-key-delete-btn {
        background: #f44336; color: white; border: none;
        border-radius: 4px; padding: 4px 8px; font-size: 0.8rem;
        cursor: pointer;
    }
    .quiz-result-body { padding: 24px; }
    .quiz-result-score { font-size: 2rem; font-weight: bold; text-align: center; }
    .result-question {
        padding: 12px;
        border-radius: 4px;
        margin-bottom: 8px;
    }
    .result-question-correct { background-color: #3a4a3a; }
    .result-question-incorrect { background-color: #5a3a3a; }
    .bg-gray-700 { background-color: #3c3c3c; } 
    .result-question-text { font-weight: 600; margin-bottom: 4px; }
    .result-answer { font-size: 0.9rem; }
    .result-answer.correct { color: #81c784; }
    .result-answer.yours { color: #ffb74d; }
    .bg-gray-800 { background-color: #252526; }
    .text-blue-300 { color: #9cdcfe; }
    .file-manager-container {
        height: 100%;
        font-size: 14px;
    }
    .file-tree-list { padding: 8px; }
    .file-tree-node {
        display: flex;
        align-items: center;
        padding: 4px 8px;
        cursor: pointer;
        border-radius: 4px;
    }
    .file-tree-node:hover { background-color: #3c3c3c; }
    .file-tree-node[data-active='true'] { background-color: #094771; }
    .file-tree-node[data-drag-over='true'] {
        background-color: #0e639c;
    }
    .file-tree-node-icon { margin-right: 6px; }
    .context-menu {
      position: fixed;
      z-index: 1000;
      background-color: #252526;
      border: 1px solid #37373d;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      padding: 4px 0;
      min-width: 150px;
    }
    .context-menu-item {
      padding: 6px 12px;
      font-size: 0.9rem;
      cursor: pointer;
    }
    .context-menu-item:hover {
      background-color: #094771;
    }
    .context-menu-item-delete {
      color: #f48771;
    }
    .context-menu-divider {
      border-top: 1px solid #37373d;
      margin: 4px 0;
    }
    .spinner-overlay {
      position: absolute; inset: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex; justify-content: center; align-items: center;
      z-index: 50;
    }
    .spinner-overlay.\!relative { position: relative; }
    .spinner-overlay.\!h-10 { height: 2.5rem; }
    .spinner-overlay.\!bg-transparent { background-color: transparent; }
    .spinner {
      border: 4px solid #f3f3f3; border-top: 4px solid #0e639c;
      border-radius: 50%; width: 40px; height: 40px;
      animation: spin 1s linear infinite;
    }
    .spinner.\!w-6 { width: 1.5rem; }
    .spinner.\!h-6 { height: 1.5rem; }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1001;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .toast-item {
      padding: 12px 16px;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: toast-fade-in 0.3s ease-out;
    }
    .toast-item.success {
      background-color: #4CAF50;
    }
    .toast-item.error {
      background-color: #f44336;
    }
    .toast-item.info {
      background-color: #0e639c;
    }
    @keyframes toast-fade-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    .bg-gray-600 { background-color: #4a4a4a; }
    .text-gray-400 { color: #a0a0a0; }
  </style>
</head>
<body>
  
  <div id="root"></div>
  <input type="file" id="file-upload-input" style="display: none" multiple accept=".txt,.md,.zip" />
  <input type="file" id="project-import-input" style="display: none" accept=".json" />


  <!-- 3. React Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ïä§ÌÅ¨Î¶ΩÌä∏ -->
  <script type="module">
    const { 
      useState, 
      useEffect, 
      useCallback, 
      useMemo,
      createContext,
      useContext
    } = React;
    const { createRoot } = ReactDOM;
    const e = React.createElement;

    const ToastContext = createContext(null);
    const useToast = () => useContext(ToastContext);
    
    const AppContext = createContext(null);
    
    // --- 0. IndexedDB Ìó¨Ìçº (v10.1Í≥º ÎèôÏùº) ---
    class IdbHelper {
        constructor(dbName, version, stores) {
            this.dbName = dbName;
            this.version = version;
            this.stores = stores;
            this.db = null;
        }
        init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, this.version);
                request.onerror = (event) => reject("IndexedDB Ïò§Î•ò: " + request.error);
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    resolve(this);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    this.stores.forEach(storeConfig => {
                        let store;
                        if (!db.objectStoreNames.contains(storeConfig.name)) {
                            store = db.createObjectStore(storeConfig.name, { keyPath: storeConfig.keyPath });
                        } else {
                            store = event.target.transaction.objectStore(storeConfig.name);
                        }
                        (storeConfig.indexes || []).forEach(idx => {
                            if (!store.indexNames.contains(idx.name)) {
                                store.createIndex(idx.name, idx.keyPath, { unique: false });
                            }
                        });
                    });
                };
            });
        }
        get(storeName, key) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        getAll(storeName) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        query(storeName, indexName, value) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                const index = store.index(indexName);
                const request = index.getAll(value);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        put(storeName, item) {
             return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.put(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        add(storeName, item) {
             return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.add(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        delete(storeName, key) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        clear(storeName) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
    }
    
    const DB_STORES_CONFIG = [
        { name: 'files', keyPath: 'id', indexes: [{ name: 'by_parentId', keyPath: 'parentId' }] },
        { name: 'quizzes', keyPath: 'id', indexes: [{ name: 'by_fileId', keyPath: 'fileId' }] },
        { name: 'quizAttempts', keyPath: 'id', indexes: [{ name: 'by_fileId', keyPath: 'fileId' }, { name: 'by_quizId', keyPath: 'quizId' }] },
        { name: 'settings', keyPath: 'id' }
    ];

    // --- 1. AI Gemini API Ìò∏Ï∂ú (v10.1Í≥º ÎèôÏùº) ---

    const QUIZ_SCHEMA = {
      type: "OBJECT",
      properties: {
        title: { type: "STRING" },
        questions: {
          type: "ARRAY",
          items: {
            type: "OBJECT",
            properties: {
              questionType: { type: "STRING" },
              questionText: { type: "STRING" },
              options: { type: "ARRAY", items: { type: "STRING" }, nullable: true },
              correctAnswerIndex: { type: "NUMBER", nullable: true },
              gradingCriteria: { type: "STRING", nullable: true },
            },
            required: ["questionType", "questionText"]
          }
        }
      },
      required: ["title", "questions"]
    };
    
    const GRADING_SCHEMA = {
      type: "OBJECT",
      properties: {
        isCorrect: { type: "BOOLEAN", description: "Ï±ÑÏ†ê Í∏∞Ï§ÄÏóê Îî∞Îùº Ï†ïÎãµÏù¥Î©¥ true, Ïò§ÎãµÏù¥Î©¥ false" },
        feedback: { type: "STRING", description: "ÏÇ¨Ïö©ÏûêÏùò ÎãµÎ≥ÄÏóê ÎåÄÌïú Íµ¨Ï≤¥Ï†ÅÏù∏ Ï≤®ÏÇ≠ ÎÇ¥Ïö©" }
      },
      required: ["isCorrect", "feedback"]
    };
    
    class ApiError extends Error {
      constructor(message, status) { super(message); this.name = 'ApiError'; this.status = status; }
    }
    const fetchWithRetry = async (url, options, retries = 3, delay = 1000) => {
      for (let i = 0; i < retries; i++) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            if (response.status === 429) throw new ApiError('Rate limit exceeded', response.status);
            throw new ApiError(`HTTP error! status: ${response.status}`, response.status);
          }
          return response.json();
        } catch (error) {
          if (error.status === 429 && i < retries - 1) {
            await new Promise(res => setTimeout(res, delay * Math.pow(2, i)));
          } else { throw error; }
        }
      }
      throw new Error('API call failed after all retries');
    };
    
    const generateQuizWithAi = async (sourceText, options, settings) => {
      const { numQuestions, difficulty, questionType, includeSnippets, provideAnswerKey, customInstructions } = options;
      const apiKeys = settings?.apiKeys || [{ key: "", rpm: 60 }]; 
      const keyIndex = Date.now() % apiKeys.length; 
      const selectedKey = apiKeys[keyIndex];
      const apiKey = selectedKey.key.trim() ? selectedKey.key.trim() : "";
      const model = settings?.modelName || "gemini-2.5-flash-preview-09-2025";
      
      if (!apiKey) {
          throw new ApiError('API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. [ÏÑ§Ï†ï(‚öôÔ∏è) > API Keys]ÏóêÏÑú Ïú†Ìö®Ìïú ÌÇ§Î•º Ï∂îÍ∞ÄÌïòÏã≠ÏãúÏò§.', 401); 
      }

      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      
      let systemPrompt = settings.quizSystemPrompt || DEFAULT_SETTINGS.quizSystemPrompt;
      
      systemPrompt = systemPrompt
          .replace('{{DIFFICULTY}}', difficulty)
          .replace('{{QUESTION_TYPE}}', questionType)
          .replace('{{INCLUDE_SNIPPETS}}', includeSnippets ? "Include relevant code snippets from the text if applicable." : "")
          .replace('{{PROVIDE_ANSWER_KEY}}', provideAnswerKey ? "Ensure correct answers are provided." : "")
          .replace('{{CUSTOM_INSTRUCTIONS}}', customInstructions ? `Additional Instructions: ${customInstructions}` : "")
          .replace('{{NUM_QUESTIONS}}', numQuestions);
          
      const userQuery = `--- SOURCE TEXT ---
${sourceText}
--- END SOURCE TEXT ---
`;

      const payload = {
        contents: [{ role: "user", parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: QUIZ_SCHEMA,
          temperature: 0.3,
        }
      };

      try {
        const result = await fetchWithRetry(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const candidate = result.candidates?.[0];
        if (candidate && candidate.content?.parts?.[0]?.text) {
          return JSON.parse(candidate.content.parts[0].text);
        } else {
          const errorReason = candidate?.finishReason || "Unknown error";
          throw new Error(`AIÍ∞Ä Ïú†Ìö®Ìïú ÌÄ¥Ï¶àÎ•º ÏÉùÏÑ±ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. (Reason: ${errorReason})`);
        }
      } catch (error) {
        console.error("AI ÌÄ¥Ï¶à ÏÉùÏÑ± Ïò§Î•ò:", error);
        throw new Error(`AI ÌÄ¥Ï¶à ÏÉùÏÑ± Ïã§Ìå®: ${error.message}`);
      }
    };
    
    const gradeAnswerWithAi = async (questionText, userAnswer, gradingCriteria, settings) => {
      const apiKeys = settings?.apiKeys || [{ key: "", rpm: 60 }]; 
      const keyIndex = Date.now() % apiKeys.length; 
      const selectedKey = apiKeys[keyIndex];
      const apiKey = selectedKey.key.trim() ? selectedKey.key.trim() : "";
      const model = settings?.modelName || "gemini-2.5-flash-preview-09-2025";

      if (!apiKey) {
        throw new ApiError('API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. [ÏÑ§Ï†ï(‚öôÔ∏è) > API Keys]ÏóêÏÑú Ïú†Ìö®Ìïú ÌÇ§Î•º Ï∂îÍ∞ÄÌïòÏã≠ÏãúÏò§.', 401);
      }
      
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      
      const systemPrompt = settings.gradingSystemPrompt || DEFAULT_SETTINGS.gradingSystemPrompt;
      
      const userQuery = `--- QUESTION ---
${questionText}

--- GRADING CRITERIA (Rubric) ---
${gradingCriteria}

--- USER'S ANSWER ---
${userAnswer}
--- END OF DATA ---

Please grade the "USER'S ANSWER" based *only* on the "GRADING CRITERIA" and provide feedback.
`;

      const payload = {
        contents: [{ role: "user", parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: GRADING_SCHEMA,
          temperature: 0.1
        }
      };

      try {
        const result = await fetchWithRetry(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const candidate = result.candidates?.[0];
        if (candidate && candidate.content?.parts?.[0]?.text) {
          return JSON.parse(candidate.content.parts[0].text);
        } else {
          const errorReason = candidate?.finishReason || "Unknown error";
          throw new Error(`AIÍ∞Ä Ï±ÑÏ†êÏùÑ ÏÉùÏÑ±ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. (Reason: ${errorReason})`);
        }
      } catch (error) {
        console.error("AI Ï±ÑÏ†ê Ïò§Î•ò:", error);
        throw new Error(`AI Ï±ÑÏ†ê Ïã§Ìå®: ${error.message}`);
      }
    };
    
    // --- 2. Web Worker (v10.1Í≥º ÎèôÏùº) ---
    const workerScript = `
      const fetchWithRetry = ${fetchWithRetry.toString()};
      ${ApiError.toString()}
      const generateQuizWithAi = ${generateQuizWithAi.toString()};
      const QUIZ_SCHEMA = ${JSON.stringify(QUIZ_SCHEMA)};
      
      const gradeAnswerWithAi = ${gradeAnswerWithAi.toString()};
      const GRADING_SCHEMA = ${JSON.stringify(GRADING_SCHEMA)};

      const handleAsyncGrading = async (attempt, settings, DEFAULT_SETTINGS) => {
          const results = JSON.parse(attempt.answers);
          
          const gradingPromises = results.map(async (originalResult) => {
              if (originalResult.isCorrect !== null) {
                  return originalResult;
              }
              try {
                  const gradeData = await gradeAnswerWithAi(
                      originalResult.questionText,
                      originalResult.selectedAnswer,
                      originalResult.gradingCriteria,
                      { ...DEFAULT_SETTINGS, ...settings }
                  );
                  return {
                      ...originalResult,
                      isCorrect: gradeData.isCorrect,
                      feedback: gradeData.feedback
                  };
              } catch (error) {
                  console.error("AI Í∞úÎ≥Ñ Ï±ÑÏ†ê Ïò§Î•ò (Worker):", error);
                  return {
                      ...originalResult,
                      isCorrect: false,
                      feedback: \`AI Ï±ÑÏ†ê Ïã§Ìå®: \${error.message}\`
                  };
              }
          });

          const newResults = await Promise.all(gradingPromises);
          
          let newScore = 0;
          newResults.forEach(r => {
              if (r.isCorrect === true) newScore++;
          });

          const updatedAttempt = {
              ...attempt,
              score: newScore,
              answers: JSON.stringify(newResults)
          };
          
          return updatedAttempt;
      };

      self.onmessage = async (e) => {
        const { id: taskId, taskType, sourceText, options, settings, DEFAULT_SETTINGS, attempt } = e.data;
        
        try {
          if (taskType === 'grade') {
            const updatedAttempt = await handleAsyncGrading(attempt, settings, DEFAULT_SETTINGS);
            self.postMessage({ 
                status: 'success', 
                taskId, 
                taskType, 
                updatedAttempt,
                options: { quizTitle: attempt.quizTitle }
            });
            
          } else {
            const quizData = await generateQuizWithAi(sourceText, options, { ...DEFAULT_SETTINGS, ...settings });
            self.postMessage({ 
                status: 'success', 
                taskId, 
                taskType, 
                quizData, 
                options: e.data.options 
            });
          }
        } catch (error) {
          self.postMessage({ status: 'error', taskId, taskType, error: error.message });
        }
      };
    `;
    const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);
    
    
    // --- 3. Í∏∞Î≥∏ ÏÑ§Ï†ï Î∞è ÌõÖ (v10.2) ---

    const DEFAULT_SETTINGS = {
        apiKeys: [{ key: "", rpm: 60 }],
        defaultDifficulty: "Medium",
        defaultQuestionType: "MultipleChoice",
        defaultNumQuestions: 10,
        quizSystemPrompt: `You are an expert quiz generation AI. You must generate a {{NUM_QUESTIONS}}-question quiz based *only* on the provided source text.
- Difficulty: {{DIFFICULTY}}
- Requested Question Type: {{QUESTION_TYPE}}
- Adhere strictly to the provided JSON schema.
- You MUST set 'questionType' for each question (e.g., "MultipleChoice" or "ShortAnswer", "Essay" etc.).
- For "MultipleChoice" questions, provide 'options' (array) and 'correctAnswerIndex' (number).
- For subjective questions (like "ShortAnswer", "Essay", "CaseStudy"), DO NOT provide 'correctAnswerIndex' or 'options'.
- Instead, for subjective questions, you MUST provide detailed 'gradingCriteria' (string). This criteria is a rubric for another AI to use for grading. (Ïòà: "Ï†ïÌôïÌïú Ïö©Ïñ¥ 'TDD' Ïñ∏Í∏â Ïãú 1Ï†ê, 'ÌÖåÏä§Ìä∏ Ïö∞ÏÑ† ÏûëÏÑ±'Ïùò Í∞úÎÖê ÏÑ§Î™Ö Ïãú 1Ï†ê")
- {{INCLUDE_SNIPPETS}}
- {{PROVIDE_ANSWER_KEY}}
- {{CUSTOM_INSTRUCTIONS}}`,
        gradingSystemPrompt: `You are a fair and meticulous AI teaching assistant. Your task is to grade a user's answer based *only* on the provided grading criteria (rubric).
- Evaluate the "USER'S ANSWER" strictly against the "GRADING CRITERIA".
- Determine if the answer is correct (true) or incorrect (false).
- Provide concise, constructive feedback (Ï≤®ÏÇ≠) in Korean, explaining *why* the answer is correct or incorrect based on the criteria.
- Adhere strictly to the JSON output schema.`
    };

    // üìå (v10.1) Req 2: ÏßàÎ¨∏ Ïú†Ìòï ÌïúÍ∏ÄÌôî Îßµ
    const QUESTION_TYPE_MAP = {
      "MultipleChoice": "Í∞ùÍ¥ÄÏãù (ÏÑ†ÌÉùÌòï)",
      "ShortAnswer": "Ï£ºÍ¥ÄÏãù (Îã®ÎãµÌòï)",
      "Essay": "ÏÑúÏà†Ìòï",
      "TrueFalse": "ÏßÑÏúÑÌòï (O/X)",
      "FillInTheBlank": "ÎπàÏπ∏ Ï±ÑÏö∞Í∏∞",
      "CaseStudy": "ÏÇ¨Î°Ä Ïó∞Íµ¨",
      "Matching": "Ïó∞Í≤∞Ìòï",
      "Sequencing": "ÏàúÏÑú ÎßûÏ∂îÍ∏∞",
      "CodeSnippet": "ÏΩîÎìú Î∂ÑÏÑù"
    };

    // (v10) IndexedDB Í∏∞Î∞ò ÌååÏùº ÏãúÏä§ÌÖú ÌõÖ
    const useFileSystem = (files, dbHelper, refetch) => {
        
        const fileActions = useMemo(() => {
          if (!dbHelper) return {};

          const recursiveDelete = async (parentId) => {
              const allFiles = await dbHelper.getAll('files');
              const children = allFiles.filter(f => f.parentId === parentId);
              for (const child of children) {
                  if (child.type === 'folder') {
                      await recursiveDelete(child.id);
                  }
                  await dbHelper.delete('files', child.id);
              }
          };
          
          const move = async (fileId, newParentId) => {
              if (fileId === newParentId) return;
              
              const file = await dbHelper.get('files', fileId);
              if(file && file.parentId !== newParentId) { 
                  await dbHelper.put('files', { ...file, parentId: newParentId });
                  refetch();
              }
          };

          return {
            create: async (parentId, type, name, content = '') => {
              const docName = name || (type === 'folder' ? 'New Folder' : 'new-file.txt');
              const newFile = {
                id: crypto.randomUUID(),
                name: docName,
                type,
                parentId,
                content: type === 'file' ? content : null,
                metadata: { notes: '' }, 
                createdAt: new Date().toISOString()
              };
              await dbHelper.add('files', newFile);
              refetch();
              return newFile;
            },
            rename: async (fileId, newName) => {
              const file = await dbHelper.get('files', fileId);
              if(file) await dbHelper.put('files', { ...file, name: newName });
              refetch();
            },
            remove: async (fileId, type) => {
              if (type === 'folder') {
                  await recursiveDelete(fileId);
              }
              await dbHelper.delete('files', fileId);
              refetch();
            },
            updateContent: async (fileId, newContent) => {
              const file = await dbHelper.get('files', fileId);
              if(file) await dbHelper.put('files', { ...file, content: newContent });
              await refetch();
            },
            move: move,
            updateMetadata: async (fileId, newMetadata) => {
                const file = await dbHelper.get('files', fileId);
                if (file) {
                    const oldMetadata = file.metadata || { notes: '' };
                    await dbHelper.put('files', {
                        ...file,
                        metadata: { ...oldMetadata, ...newMetadata }
                    });
                }
                await refetch();
            }
          };
        }, [dbHelper, refetch]);

        const fileTree = useMemo(() => {
          const map = {};
          const roots = [];
          files.forEach(file => {
            map[file.id] = { ...file, children: [] };
          });
          Object.values(map).forEach(node => {
            if (node.parentId === 'root') {
              roots.push(node);
            } else if (map[node.parentId]) {
              map[node.parentId].children.push(node);
            }
          });
          return roots;
        }, [files]);

        return { fileTree, fileActions };
    };
    
    // Debounce ÌõÖ
    const useDebounce = (value, delay) => {
        const [debouncedValue, setDebouncedValue] = useState(value);
        useEffect(() => {
            const handler = setTimeout(() => { setDebouncedValue(value); }, delay);
            return () => clearTimeout(handler);
        }, [value, delay]);
        return debouncedValue;
    };


    // --- 4. UI Ïª¥Ìè¨ÎÑåÌä∏ ---
    
    /* ÌÜ†Ïä§Ìä∏ ÏãúÏä§ÌÖú */
    const ToastProvider = ({ children }) => {
        const [toasts, setToasts] = useState([]);
        const show = useCallback((message, type = 'info') => {
            const id = crypto.randomUUID();
            setToasts(prev => [...prev, { id, message, type }]);
            setTimeout(() => {
                setToasts(prev => prev.filter(t => t.id !== id));
            }, 3000);
        }, []);
        const value = useMemo(() => ({ show }), [show]);
        return e(ToastContext.Provider, { value },
            children,
            e(ToastContainer, { toasts })
        );
    };
    const ToastContainer = ({ toasts }) => {
        return e('div', { className: 'toast-container' },
            toasts.map(toast => e('div', { 
                key: toast.id, 
                className: `toast-item ${toast.type}` 
            }, toast.message))
        );
    };


    const Spinner = () => e(
      'div', { className: 'spinner-overlay' },
      e('div', { className: 'spinner' })
    );

    // ÏÖ∏: üìå (v10.2) Req 1: ÏÇ¨Ïù¥ÎìúÎ∞î ÌïÑÌÑ∞ÎßÅ Î≤ÑÍ∑∏ ÏàòÏ†ï
    const ReactVscodeSidebar = ({ items = [], onActiveChange, activeId, isVisible, children }) => {
      const activityBarTop = e('div', null,
        // üìå (v10.2) 'isBottom'Ïù¥ Î™ÖÏãúÏ†ÅÏúºÎ°ú trueÍ∞Ä *ÏïÑÎãå* Î™®Îì† Ìï≠Î™©
        items.filter(item => item.isBottom !== true).map((item) => e('button', {
          key: item.id, className: 'vsc-activity-item',
          onClick: () => onActiveChange(item.id),
          'data-active': isVisible && item.id === activeId, 'aria-label': item.label
        }, item.icon))
      );
      const activityBarBottom = e('div', null,
        // üìå (v10.2) 'isBottom'Ïù¥ Î™ÖÏãúÏ†ÅÏúºÎ°ú trueÏù∏ Ìï≠Î™©
        items.filter(item => item.isBottom === true).map((item) => e('button', {
          key: item.id, className: 'vsc-activity-item',
          onClick: () => onActiveChange(item.id),
          'data-active': isVisible && item.id === activeId, 'aria-label': item.label
        }, item.icon))
      );
      const activeView = React.Children.toArray(children).find(
        (child) => child.props.viewId === activeId
      );
      const sidebarView = e('div', { 
          className: 'vsc-sidebar-view',
          'data-visible': isVisible
        },
        isVisible && activeView ? e('div', { className: 'vsc-view-content', key: activeId }, activeView) : null
      );
      return e('div', { className: 'vsc-sidebar-container' }, 
        e('div', { className: 'vsc-activity-bar' }, activityBarTop, activityBarBottom), 
        sidebarView
      );
    };
    
    // (v10) Ïª®ÌÖçÏä§Ìä∏ Î©îÎâ¥ Ïª¥Ìè¨ÎÑåÌä∏
    const ContextMenu = ({ menuData, handlers, onClose }) => {
        if (!menuData.visible) return null;
        const { node } = menuData;
        const isFolder = node?.type === 'folder';
        const isRoot = !node;

        const handleAction = (action) => {
            onClose();
            action();
        };

        const MenuItem = ({ label, onClick, disabled = false, isDelete = false }) => e(
            'li', {
                className: `context-menu-item ${isDelete ? 'context-menu-item-delete' : ''}`,
                onClick: (e) => { e.stopPropagation(); if (!disabled) handleAction(onClick); }
            }, label
        );

        return e('div', {
            className: 'context-menu',
            style: { top: menuData.y, left: menuData.x },
            onClick: (e) => e.stopPropagation()
        },
            e('ul', { className: 'py-1' },
                !isRoot && e(React.Fragment, null,
                    e(MenuItem, { label: 'Ïù¥Î¶Ñ Î∞îÍæ∏Í∏∞', onClick: handlers.onRename }),
                    e(MenuItem, { label: 'ÏÇ≠Ï†ú', onClick: handlers.onDelete, isDelete: true }),
                    e('hr', { className: 'context-menu-divider' })
                ),
                (isRoot || isFolder) && e(React.Fragment, null,
                    e(MenuItem, { label: 'ÏÉà ÌååÏùº', onClick: handlers.onCreateFile }),
                    e(MenuItem, { label: 'ÏÉà Ìè¥Îçî', onClick: handlers.onCreateFolder })
                ),
                !isRoot && !isFolder && e(React.Fragment, null,
                    e('hr', { className: 'context-menu-divider' }),
                    e(MenuItem, { label: '‚ú® ÌÄ¥Ï¶à ÏÉùÏÑ±', onClick: handlers.onGenerateQuiz })
                )
            )
        );
    };

    // (v10) ÌååÏùº Í¥ÄÎ¶¨Ïûê
    const FileManagerView = ({ viewId }) => {
        const { 
            files, fileTree, fileActions, setActiveEditorFile, activeEditorFile,
            dbHelper, refetchAllData, setEditingNodeId,
            quizzes, attempts, setModalContent,
            handleQuizSubmit,
            userSettings,
            dispatchGradingTask,
            dispatchTask, 
            quizOptions 
        } = useContext(AppContext);
        
        const toast = useToast();
        
        const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, node: null });
        const [isRootDragOver, setIsRootDragOver] = useState(false);
        const [activeLowerPaneTab, setActiveLowerPaneTab] = useState('quizzes');
        
        const fileQuizzes = useMemo(() => 
            activeEditorFile ? quizzes.filter(q => q.fileId === activeEditorFile.id) : [],
        [quizzes, activeEditorFile]);
        
        const fileAttempts = useMemo(() =>
            activeEditorFile ? attempts.filter(a => a.fileId === activeEditorFile.id) : [],
        [attempts, activeEditorFile]);
        
        
        /* ÌååÏùº ÏóÖÎ°úÎìú/ÌîÑÎ°úÏ†ùÌä∏ ÏûÑÌè¨Ìä∏/ÏùµÏä§Ìè¨Ìä∏ Ìï∏Îì§Îü¨ (v10.1Í≥º ÎèôÏùº) */
        const handleFileUpload = useCallback(async (event) => {
            const files = event.target.files;
            if (!files.length) return;
            toast.show('ÌååÏùº ÏóÖÎ°úÎìú ÏãúÏûë...', 'info');
            for (const file of files) {
                const fileName = file.name;
                const fileExt = fileName.split('.').pop().toLowerCase();
                if (['txt', 'md'].includes(fileExt)) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        fileActions.create('root', 'file', fileName, e.target.result);
                    };
                    reader.readAsText(file);
                } else if (fileExt === 'zip') {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const zip = await JSZip.loadAsync(e.target.result);
                            const zipRootFolder = await fileActions.create('root', 'folder', fileName.replace(/\.zip$/i, ''));
                            const createdFolderIds = new Map();
                            createdFolderIds.set('root', zipRootFolder.id);
                            const allFolderPaths = new Set();
                            Object.keys(zip.files).forEach(p => {
                                if (zip.files[p].dir) {
                                    allFolderPaths.add(p);
                                } else {
                                    const parts = p.split('/');
                                    parts.pop();
                                    let currentPath = '';
                                    for (const part of parts) {
                                        if (!part) continue;
                                        currentPath += part + '/';
                                        allFolderPaths.add(currentPath);
                                    }
                                }
                            });
                            const sortedFolderPaths = Array.from(allFolderPaths)
                                .filter(p => p && !p.startsWith('__MACOSX/'))
                                .sort((a, b) => a.split('/').length - b.split('/').length);
                            for (const folderPath of sortedFolderPaths) {
                                const parts = folderPath.replace(/\/$/, '').split('/');
                                const folderName = parts[parts.length - 1];
                                const parentPath = parts.slice(0, -1).join('/') + (parts.length > 1 ? '/' : '');
                                const parentFolderId = createdFolderIds.get(parentPath || 'root');
                                if (parentFolderId && folderName && !createdFolderIds.has(folderPath)) {
                                    const newFolder = await fileActions.create(parentFolderId, 'folder', folderName);
                                    createdFolderIds.set(folderPath, newFolder.id);
                                }
                            }
                            for (const [relativePath, zipEntry] of Object.entries(zip.files)) {
                                if (!zipEntry.dir && !zipEntry.name.startsWith('__MACOSX/') && zipEntry.name) {
                                    const parts = zipEntry.name.split('/');
                                    const fileName = parts.pop();
                                    const parentPath = parts.join('/') + (parts.length > 0 ? '/' : '');
                                    const parentFolderId = createdFolderIds.get(parentPath || 'root');
                                    if (parentFolderId && fileName) {
                                        const content = await zipEntry.async('string');
                                        await fileActions.create(parentFolderId, 'file', fileName, content);
                                    }
                                }
                            }
                        } catch (err) {
                            console.error("ZIP processing failed:", err);
                            toast.show(`‚ùå ZIP ÌååÏùº Ï≤òÎ¶¨ Ïã§Ìå®: ${err.message}`, 'error');
                        }
                    };
                    reader.readAsArrayBuffer(file);
                }
            }
            setTimeout(() => {
                refetchAllData();
                toast.show('‚úÖ ÌååÏùº ÏóÖÎ°úÎìú ÏôÑÎ£å.', 'success');
            }, 1500);
            event.target.value = null;
        }, [fileActions, refetchAllData, toast]);
        const handleImportProject = useCallback((event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                if (!window.confirm("ÌòÑÏû¨ ÌîÑÎ°úÏ†ùÌä∏Î•º ÎçÆÏñ¥Ïì∞ÏãúÍ≤†ÏäµÎãàÍπå?")) return;
                try {
                    const data = JSON.parse(e.target.result);
                    await dbHelper.clear('files');
                    await dbHelper.clear('quizzes');
                    await dbHelper.clear('quizAttempts');
                    for (const file of data.files || []) await dbHelper.put('files', file);
                    for (const quiz of data.quizzes || []) await dbHelper.put('quizzes', quiz);
                    for (const attempt of data.attempts || []) await dbHelper.put('attempts', attempt);
                    if (data.settings) await dbHelper.put('settings', data.settings);
                    refetchAllData();
                    toast.show('‚úÖ ÌîÑÎ°úÏ†ùÌä∏Î•º ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Í∞ÄÏ†∏ÏôîÏäµÎãàÎã§.', 'success');
                } catch (err) {
                    console.error("Import failed:", err);
                    toast.show(`‚ùå Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®: ${err.message}`, 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }, [dbHelper, refetchAllData, toast]);
        const handleExportProject = useCallback(async () => {
            try {
                const data = {
                    files: await dbHelper.getAll('files'),
                    quizzes: await dbHelper.getAll('quizzes'),
                    attempts: await dbHelper.getAll('quizAttempts'),
                    settings: await dbHelper.get('settings', 'userConfig')
                };
                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ai-quiz-app-export.json';
                a.click();
                URL.revokeObjectURL(url);
                toast.show('‚úÖ ÌîÑÎ°úÏ†ùÌä∏Î•º ÎÇ¥Î≥¥ÎÉàÏäµÎãàÎã§.', 'success');
            } catch (err) {
                console.error("Export failed:", err);
                toast.show(`‚ùå ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®: ${err.message}`, 'error');
            }
        }, [dbHelper, toast]);
        useEffect(() => {
            const handleClick = () => setContextMenu({ visible: false });
            window.addEventListener('click', handleClick);
            const fileUploadInput = document.getElementById('file-upload-input');
            const projectImportInput = document.getElementById('project-import-input');
            fileUploadInput.addEventListener('change', handleFileUpload);
            projectImportInput.addEventListener('change', handleImportProject);
            return () => {
                window.removeEventListener('click', handleClick);
                fileUploadInput.removeEventListener('change', handleFileUpload);
                projectImportInput.removeEventListener('change', handleImportProject);
            };
        }, [handleFileUpload, handleImportProject]);
        
        const handleContextMenu = (e, node) => {
            e.preventDefault();
            e.stopPropagation();
            setContextMenu({ visible: true, x: e.clientX, y: e.clientY, node: node });
        };
        
        // (v10.1Í≥º ÎèôÏùº) FileNode
        const FileNode = ({ node, depth, onContextMenu }) => {
            const { activeEditorFile, editingNodeId, setEditingNodeId, fileActions } = useContext(AppContext);
            const [isOpen, setIsOpen] = useState(true);
            const [editName, setEditName] = useState(node.name);
            const [isDragOver, setIsDragOver] = useState(false);
            const isEditing = editingNodeId === node.id;
            useEffect(() => {
                if (isEditing) setEditName(node.name);
            }, [isEditing, node.name]);
            const handleToggle = (e) => {
                e.stopPropagation();
                if (node.type === 'folder') setIsOpen(!isOpen);
                else setActiveEditorFile(files.find(f => f.id === node.id));
            };
            const handleRenameSubmit = (e) => {
                e.stopPropagation(); e.preventDefault();
                if (editName.trim() && editName.trim() !== node.name) {
                    fileActions.rename(node.id, editName.trim());
                }
                setEditingNodeId(null);
            };
            const handleDragStart = (e) => {
                e.stopPropagation();
                e.dataTransfer.setData('fileId', node.id);
                e.dataTransfer.effectAllowed = 'move';
            };
            const handleDragOver = (e) => {
                e.preventDefault(); e.stopPropagation();
                if (node.type === 'folder') {
                    setIsDragOver(true);
                    e.dataTransfer.dropEffect = 'move';
                } else {
                    e.dataTransfer.dropEffect = 'none';
                }
            };
            const handleDragLeave = (e) => {
                e.preventDefault(); e.stopPropagation();
                setIsDragOver(false);
            };
            const handleDrop = (e) => {
                e.preventDefault(); e.stopPropagation();
                setIsDragOver(false);
                if (node.type === 'folder') {
                    const fileId = e.dataTransfer.getData('fileId');
                    if (fileId && fileId !== node.id) {
                        fileActions.move(fileId, node.id);
                    }
                }
            };
            return e(React.Fragment, null,
                e('div', { 
                    className: 'file-tree-node',
                    style: { paddingLeft: `${depth * 16 + 8}px` },
                    onClick: handleToggle,
                    onContextMenu: (e) => onContextMenu(e, node),
                    'data-active': activeEditorFile?.id === node.id,
                    draggable: true,
                    onDragStart: handleDragStart,
                    onDragOver: handleDragOver,
                    onDragLeave: handleDragLeave,
                    onDrop: handleDrop,
                    'data-drag-over': isDragOver
                  },
                  e('span', { className: 'file-tree-node-icon' }, 
                    node.type === 'folder' ? (isOpen ? '‚ñº' : '‚ñ∫') : 'üìÑ'
                  ),
                  isEditing
                    ? e('form', { onSubmit: handleRenameSubmit, className: 'flex-1 ml-1' },
                        e('input', {
                            key: node.id, type: 'text', value: editName,
                            onChange: (ev) => setEditName(ev.target.value),
                            onBlur: handleRenameSubmit,
                            onClick: (e) => e.stopPropagation(), autoFocus: true,
                            className: 'form-input !p-0 !text-sm'
                        })
                      )
                    : e('span', { className: 'ml-1' }, node.name)
                ),
                isOpen && node.children && node.children.map(child => 
                    e(FileNode, { 
                        key: child.id, 
                        node: child, 
                        depth: depth + 1, 
                        onContextMenu: onContextMenu
                    })
                )
            );
        };
        
        // (v10.1Í≥º ÎèôÏùº) contextMenuHandlers
        const contextMenuHandlers = useMemo(() => {
            const { node } = contextMenu;
            const parentId = (node && node.type === 'folder') ? node.id : (node ? node.parentId : 'root');
            
            return {
                onRename: () => { if (node) setEditingNodeId(node.id); },
                onDelete: () => {
                    if (node && window.confirm(`'${node.name}'ÏùÑ(Î•º) ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                        fileActions.remove(node.id, node.type);
                        if (activeEditorFile?.id === node.id) setActiveEditorFile(null);
                    }
                },
                onCreateFile: () => fileActions.create(parentId, 'file'),
                onCreateFolder: () => fileActions.create(parentId, 'folder'),
                onGenerateQuiz: () => {
                    if (node && node.type === 'file') {
                        dbHelper.get('files', node.id).then(file => {
                            if (!file.content || !file.content.trim()) {
                                toast.show('‚ùå ÌååÏùºÏóê ÏõêÎ¨∏Ïù¥ ÏóÜÏäµÎãàÎã§. ÌååÏùºÏùÑ Ïó¥Ïñ¥ ÎÇ¥Ïö©ÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.', 'error');
                                return;
                            }
                            if(activeEditorFile?.id !== file.id) {
                                setActiveEditorFile(file);
                            }
                            dispatchTask({
                                taskType: 'generate',
                                sourceText: file.content,
                                options: {
                                    ...quizOptions,
                                    fileId: file.id,
                                    sourceFileName: file.name
                                }
                            });
                        });
                    }
                }
            };
        }, [contextMenu, fileActions, setEditingNodeId, activeEditorFile, dbHelper, dispatchTask, quizOptions, toast, setActiveEditorFile]);
        
        // (v10.1Í≥º ÎèôÏùº) Î£®Ìä∏ DnD Ìï∏Îì§Îü¨
        const handleRootDragOver = (e) => {
            e.preventDefault();
            e.stopPropagation();
            setIsRootDragOver(true);
            e.dataTransfer.dropEffect = 'move';
        };
        const handleRootDragLeave = (e) => {
            e.preventDefault();
            e.stopPropagation();
            setIsRootDragOver(false);
        };
        const handleRootDrop = (e) => {
            e.preventDefault();
            e.stopPropagation();
            setIsRootDragOver(false);
            const fileId = e.dataTransfer.getData('fileId');
            if (fileId) {
                fileActions.move(fileId, 'root');
            }
        };

        return e('div', { 
            viewId, 
            className: 'flex flex-col h-full vsc-view-panes',
            onContextMenu: (e) => handleContextMenu(e, null)
           },
            // ÏÉÅÎã®: ÌååÏùº Ìä∏Î¶¨
            e('div', { className: 'vsc-view-pane' },
                e('div', { className: 'view-header' },
                    e('h3', { className: 'border-b-0 p-0 m-0' }, 'ÌååÏùº ÌÉêÏÉâÍ∏∞'),
                    e('div', { className: 'flex gap-1' },
                        e('button', { title: "ÏÉà Ìè¥Îçî", className: 'view-header-icon', onClick: () => contextMenuHandlers.onCreateFolder() }, 'üìÅ+'),
                        e('button', { title: "ÌååÏùº ÏóÖÎ°úÎìú", className: 'view-header-icon', onClick: () => document.getElementById('file-upload-input').click() }, '‚¨ÜÔ∏è'),
                        e('button', { title: "ÎÇ¥Î≥¥ÎÇ¥Í∏∞", className: 'view-header-icon', onClick: handleExportProject }, 'üíæ'),
                        e('button', { title: "Í∞ÄÏ†∏Ïò§Í∏∞", className: 'view-header-icon', onClick: () => document.getElementById('project-import-input').click() }, 'üì•')
                    )
                ),
                e('div', { 
                    className: 'vsc-view-pane-content full',
                    onDragOver: handleRootDragOver,
                    onDragLeave: handleRootDragLeave,
                    onDrop: handleRootDrop,
                    'data-drag-over': isRootDragOver
                }, 
                    e('div', { className: 'file-tree-list' },
                        fileTree.map(node => e(FileNode, { 
                            key: node.id, 
                            node: node, 
                            depth: 0, 
                            onContextMenu: handleContextMenu
                        }))
                    )
                )
            ),
            
            // ÌïòÎã®: ÌååÏùº ÏÉÅÏÑ∏ (ÌÉ≠ Î∑∞)
            activeEditorFile && e('div', { className: 'vsc-view-pane' },
                e('div', { className: 'vsc-view-pane-header flex justify-between' }, 
                    e('div', { className: 'flex' },
                        e('button', {
                            className: `px-3 py-1 text-xs ${activeLowerPaneTab === 'quizzes' ? 'text-white bg-gray-600' : 'text-gray-400'}`,
                            onClick: () => setActiveLowerPaneTab('quizzes')
                        }, 'ÌÄ¥Ï¶à/Í∏∞Î°ù'),
                        e('button', {
                            className: `px-3 py-1 text-xs ${activeLowerPaneTab === 'notes' ? 'text-white bg-gray-600' : 'text-gray-400'}`,
                            onClick: () => setActiveLowerPaneTab('notes')
                        }, 'Î©îÎ™®')
                    )
                ),
                e('div', { className: `vsc-view-pane-content ${activeLowerPaneTab === 'notes' ? 'full' : ''}` },
                    activeLowerPaneTab === 'quizzes' && e('div', null,
                        e('h4', { className: 'text-md font-semibold mt-0 mb-2' }, 'ÏÉùÏÑ±Îêú ÌÄ¥Ï¶à'),
                        fileQuizzes.length === 0 && e('p', { className: 'text-sm text-gray-400' }, 'Ïù¥ ÌååÏùºÎ°ú ÏÉùÏÑ±Îêú ÌÄ¥Ï¶àÍ∞Ä ÏóÜÏäµÎãàÎã§.'),
                        fileQuizzes.map(quiz => e('div', { 
                            key: quiz.id, className: 'list-item',
                            onClick: () => setModalContent(e(QuizTaker, { 
                                quiz, 
                                onClose: () => setModalContent(null),
                                onQuizSubmit: handleQuizSubmit 
                            }))
                        }, e('div', { className: 'list-item-title' }, quiz.title))),
                        
                        e('h4', { className: 'text-md font-semibold mt-4 mb-2' }, 'ÌíÄÏù¥ Í∏∞Î°ù'),
                        fileAttempts.length === 0 && e('p', { className: 'text-sm text-gray-400' }, 'Ïù¥ ÌååÏùºÏùò ÌÄ¥Ï¶à ÌíÄÏù¥ Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.'),
                        fileAttempts.map(attempt => e('div', { 
                            key: attempt.id, className: 'list-item',
                            onClick: () => setModalContent(e(QuizResult, { 
                                attempt, 
                                quiz: quizzes.find(q => q.id === attempt.quizId), 
                                onClose: () => setModalContent(null),
                                userSettings,
                                dbHelper,
                                refetchAllData,
                                dispatchGradingTask
                            }))
                        }, e('div', { className: 'list-item-title' }, `${attempt.quizTitle} (${attempt.score}/${attempt.total})`)))
                    ),
                    activeLowerPaneTab === 'notes' && e(FileNotesEditor, {
                        activeFile: activeEditorFile,
                        fileActions: fileActions
                    })
                )
            ),
            
            e(ContextMenu, {
                menuData: contextMenu,
                onClose: () => setContextMenu({ visible: false }),
                handlers: contextMenuHandlers
            })
        );
    };

    // Î∑∞ 2: ÌÄ¥Ï¶à ÏÉùÏÑ±Í∏∞ (v10.2 - Req 2 ÌïúÍ∏ÄÌôî)
    const QuizGeneratorView = ({ viewId }) => {
      const { quizOptions, setQuizOptions } = useContext(AppContext);

      const handleSubmit = (e) => { e.preventDefault(); };
      
      return e('form', { viewId, onSubmit: handleSubmit, className: 'flex flex-col h-full' },
        e('h3', { className: 'view-header' }, 'ÌÄ¥Ï¶à ÏòµÏÖò'),
        e('div', { className: 'view-content-scroll' },
          e('div', { className: 'grid grid-cols-2 gap-4' },
            e('div', { className: 'form-group' },
              e('label', { htmlFor: 'num-questions', className: 'form-label' }, 'ÏßàÎ¨∏ Ïàò'),
              e('input', {
                id: 'num-questions', type: 'number', className: 'form-input',
                value: quizOptions.numQuestions, 
                onChange: (ev) => setQuizOptions(o => ({...o, numQuestions: parseInt(ev.target.value, 10)}))
              })
            ),
            e('div', { className: 'form-group' },
              e('label', { htmlFor: 'difficulty', className: 'form-label' }, 'ÎÇúÏù¥ÎèÑ'),
              e('select', { 
                  id: 'difficulty', className: 'form-select',
                  value: quizOptions.difficulty, 
                  onChange: (ev) => setQuizOptions(o => ({...o, difficulty: ev.target.value}))
                },
                e('option', { value: 'Easy' }, 'Ïâ¨ÏõÄ'),
                e('option', { value: 'Medium' }, 'Î≥¥ÌÜµ'),
                e('option', { value: 'Hard' }, 'Ïñ¥Î†§ÏõÄ')
              )
            )
          ),
          e('div', { className: 'form-group' },
            e('label', { htmlFor: 'question-type', className: 'form-label' }, 'ÏßàÎ¨∏ Ïú†Ìòï'),
            e('select', {
                id: 'question-type', className: 'form-select',
                value: quizOptions.questionType, 
                onChange: (ev) => setQuizOptions(o => ({...o, questionType: ev.target.value}))
              },
              // üìå (v10.2) Req 2: ÌïúÍ∏ÄÌôî Îßµ Ï†ÅÏö©
              Object.entries(QUESTION_TYPE_MAP).map(([value, label]) => 
                  e('option', { key: value, value: value }, label)
              )
            )
          ),
          e('div', { className: 'form-group' },
            e('label', { className: 'form-label' }, 'Ï∂îÍ∞Ä ÏßÄÏπ® (ÏÑ†ÌÉù ÏÇ¨Ìï≠)'),
            e('input', {
              type: 'text', className: 'form-input',
              value: quizOptions.customInstructions, 
              onChange: (ev) => setQuizOptions(o => ({...o, customInstructions: ev.target.value})),
              placeholder: 'Ïòà: ÏΩîÎìú ÏòàÏ†úÏóê ÏßëÏ§ëÌïòÏÑ∏Ïöî'
            })
          ),
          e('div', { className: 'form-group space-y-2' },
            e('label', { className: 'form-checkbox-label' },
              e('input', {
                type: 'checkbox', className: 'form-checkbox',
                checked: quizOptions.includeSnippets, 
                onChange: (ev) => setQuizOptions(o => ({...o, includeSnippets: ev.target.checked}))
              }),
              'ÏΩîÎìú Ïä§ÎãàÌé´ Ìè¨Ìï®' // (v10.1) ÌïúÍ∏ÄÌôî
            ),
            e('label', { className: 'form-checkbox-label' },
              e('input', {
                type: 'checkbox', className: 'form-checkbox',
                checked: quizOptions.provideAnswerKey, 
                onChange: (ev) => setQuizOptions(o => ({...o, provideAnswerKey: ev.target.checked}))
              }),
              'Ï†ïÎãµ ÌÇ§ Ï†úÍ≥µ' // (v10.1) ÌïúÍ∏ÄÌôî
            )
          )
        )
      );
    };
    
    // Î∑∞ 3: ÌÄ¥Ï¶à Í∏∞Î°ù
    const QuizHistoryView = ({ viewId }) => {
      const { quizzes, attempts, setModalContent, userSettings, dbHelper, refetchAllData, dispatchGradingTask } = useContext(AppContext);
      
      const showAttemptResult = (attempt) => {
          setModalContent(e(QuizResult, { 
              attempt, 
              quiz: quizzes.find(q => q.id === attempt.quizId),
              onClose: () => setModalContent(null),
              userSettings,
              dbHelper,
              refetchAllData,
              dispatchGradingTask
          }));
      };
      
      return e('div', { viewId, className: 'flex flex-col h-full' },
        e('h3', { className: 'view-header' }, 'Ï†ÑÏ≤¥ ÌíÄÏù¥ Í∏∞Î°ù'),
        e('div', { className: 'view-content-scroll' },
          attempts.length === 0 && e('p', { className: 'text-sm text-gray-400' }, 'ÌíÄÏù¥ Í∏∞Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.'),
          attempts.map(attempt => e('div', { 
              key: attempt.id, 
              className: 'list-item',
              onClick: () => showAttemptResult(attempt)
            },
            e('div', { className: 'list-item-title' }, attempt.quizTitle),
            e('div', { className: 'flex justify-between' },
                e('span', { className: 'list-item-sub' }, `Ï†êÏàò: ${attempt.score} / ${attempt.total}`),
                e('span', { className: 'list-item-sub' }, 
                    new Date(attempt.completedAt).toLocaleDateString()
                )
            )
          ))
        )
      );
    };
    
    // Î∑∞ 4: ÏûëÏóÖ Î™®ÎãàÌÑ∞ (v10.2 - Req 2 ÌïúÍ∏ÄÌôî)
    const TaskMonitorView = ({ viewId }) => {
        const { taskQueue } = useContext(AppContext);
        
        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, 'ÏûëÏóÖ Î™®ÎãàÌÑ∞'),
            e('div', { className: 'view-content-scroll' },
                taskQueue.length === 0 && e('p', { className: 'text-sm text-gray-400' }, 'ÌôúÏÑ± ÏûëÏóÖÏù¥ ÏóÜÏäµÎãàÎã§.'),
                taskQueue.map(task => e('div', { key: task.id, className: 'list-item' },
                    e('div', { className: 'list-item-title' }, 
                      task.taskType === 'grade' 
                        ? `[Ï±ÑÏ†ê] ${task.options.quizTitle}` 
                        : `[ÏÉùÏÑ±] ${task.options.sourceFileName}`
                    ),
                    e('div', { className: 'flex justify-between items-center' },
                        e('span', { className: 'list-item-sub' }, 
                          task.taskType === 'grade'
                            ? `ÌÄ¥Ï¶à Ï±ÑÏ†ê ÏûëÏóÖ`
                            // üìå (v10.2) Req 2: ÌïúÍ∏ÄÌôî Îßµ Ï†ÅÏö©
                            : `Ïú†Ìòï: ${QUESTION_TYPE_MAP[task.options.questionType] || task.options.questionType} (${task.options.numQuestions} Î¨∏Ï†ú)`
                        ),
                        task.status === 'processing' && e('span', { className: 'list-item-badge' }, 'Ï≤òÎ¶¨ Ï§ë...'),
                        task.status === 'success' && e('span', { className: 'list-item-badge success' }, 'ÏôÑÎ£å'),
                        task.status === 'error' && e('span', { className: 'list-item-badge error' }, 'Ïò§Î•ò')
                    )
                ))
            )
        );
    };

    // Î∑∞ 5: Î©îÏù∏ Ïª®ÌÖêÏ∏† ÏóêÎîîÌÑ∞ (v10.2 - Req 1 Î≤ÑÍ∑∏ ÏàòÏ†ï)
    const MainContentEditor = () => {
        const { 
            activeEditorFile, fileActions, 
            dispatchTask, quizOptions 
        } = useContext(AppContext);
        const [content, setContent] = useState("");
        const [saveStatus, setSaveStatus] = useState('saved');
        
        const toast = useToast();
        
        useEffect(() => {
            setContent(activeEditorFile?.content || "");
            setSaveStatus('saved');
        }, [activeEditorFile]);
        
        const debouncedContent = useDebounce(content, 1000);
        
        // üìå (v10.2) Req 1: Ï†ÄÏû• Î°úÏßÅ Î≤ÑÍ∑∏ ÏàòÏ†ï
        useEffect(() => {
            if (activeEditorFile && debouncedContent !== activeEditorFile.content) {
                setSaveStatus('saving');
                fileActions.updateContent(activeEditorFile.id, debouncedContent)
                    .then(() => {
                        setSaveStatus('saved');
                    })
                    .catch((err) => {
                         console.error("Ï†ÄÏû• Ïã§Ìå®:", err);
                         toast.show("‚ùå ÌååÏùº Ï†ÄÏû• Ïã§Ìå®.", 'error');
                         setSaveStatus('editing');
                    });
            } else if (saveStatus === 'editing' && activeEditorFile && debouncedContent === activeEditorFile.content) {
                setSaveStatus('saved');
            }
        // üìå (v10.2) Req 1: ÏùòÏ°¥ÏÑ± Î∞∞Ïó¥ÏóêÏÑú 'saveStatus' Ï†úÍ±∞ (Í≤ΩÏüÅ ÏÉÅÌÉú Î∞©ÏßÄ)
        }, [debouncedContent, activeEditorFile, fileActions, toast]);

        const handleGenerateQuiz = () => {
            if (!activeEditorFile) return;
            if (!content.trim()) {
                toast.show("‚ùå ÌååÏùºÏóê ÏõêÎ¨∏Ïù¥ ÏóÜÏäµÎãàÎã§.", 'error');
                return;
            }
            dispatchTask({
                taskType: 'generate',
                sourceText: content, 
                options: {
                    ...quizOptions,
                    fileId: activeEditorFile.id,
                    sourceFileName: activeEditorFile.name
                }
            });
        };
        
        const statusMessages = {
          'saved': 'Ï†ÄÏû•Îê®',
          'editing': 'ÏàòÏ†ï Ï§ë...',
          'saving': 'Ï†ÄÏû• Ï§ë...'
        };

        if (!activeEditorFile) {
            return e('div', { className: 'main-editor-placeholder' }, 'ÌååÏùº ÌÉêÏÉâÍ∏∞(üìÑ)ÏóêÏÑú ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.');
        }

        return e('div', { className: 'flex flex-col h-full' },
            e('div', { className: 'main-editor-header' },
                e('span', { className: 'main-editor-title' }, activeEditorFile.name),
                e('button', { 
                    className: 'main-editor-action-btn',
                    onClick: handleGenerateQuiz,
                    disabled: saveStatus !== 'saved'
                }, '‚ú® ÌÄ¥Ï¶à ÏÉùÏÑ±')
            ),
            e('textarea', {
                key: activeEditorFile.id,
                className: 'main-editor',
                value: content,
                onChange: (ev) => {
                    setContent(ev.target.value);
                    setSaveStatus('editing');
                }
            }),
            e('div', { className: 'main-editor-footer' }, statusMessages[saveStatus])
        );
    };
    
    // Î∑∞ 6: ÏÑ§Ï†ï Î™®Îã¨ (v10.2 - Req 2 ÌïúÍ∏ÄÌôî)
    const SettingsModal = ({ onClose }) => {
        const { userSettings, saveSettings } = useContext(AppContext);
        const [activeTab, setActiveTab] = useState('Quiz Defaults');
        
        const [apiKeys, setApiKeys] = useState([]);
        const [newApiKey, setNewApiKey] = useState("");
        const [quizSystemPrompt, setQuizSystemPrompt] = useState("");
        const [gradingSystemPrompt, setGradingSystemPrompt] = useState("");
        const [defaultSettings, setDefaultSettings] = useState({});
        
        useEffect(() => {
            if (userSettings) {
                setApiKeys(userSettings.apiKeys || DEFAULT_SETTINGS.apiKeys);
                setQuizSystemPrompt(userSettings.quizSystemPrompt || DEFAULT_SETTINGS.quizSystemPrompt);
                setGradingSystemPrompt(userSettings.gradingSystemPrompt || DEFAULT_SETTINGS.gradingSystemPrompt);
                setDefaultSettings({
                    defaultDifficulty: userSettings.defaultDifficulty || DEFAULT_SETTINGS.defaultDifficulty,
                    defaultQuestionType: userSettings.defaultQuestionType || DEFAULT_SETTINGS.defaultQuestionType,
                    defaultNumQuestions: userSettings.defaultNumQuestions || DEFAULT_SETTINGS.defaultNumQuestions
                });
            }
        }, [userSettings]);
        
        const handleAddApiKey = () => {
            if (newApiKey.trim()) {
                setApiKeys([...apiKeys, { key: newApiKey.trim(), rpm: 60 }]);
                setNewApiKey("");
            }
        };
        
        const handleRemoveApiKey = (index) => {
            setApiKeys(apiKeys.filter((_, i) => i !== index));
        };
        
        const handleDefaultChange = (key, value) => {
            setDefaultSettings(prev => ({...prev, [key]: value}));
        };

        const handleSave = () => {
            saveSettings({
                ...userSettings,
                apiKeys,
                ...defaultSettings,
                quizSystemPrompt,
                gradingSystemPrompt
            });
            onClose();
        };

        const renderTabContent = () => {
            if (activeTab === 'API Keys') {
                return e('div', null,
                    e('h3', { className: 'text-lg font-semibold mb-4' }, 'API Configuration'),
                    e('div', { className: 'form-group' },
                        e('label', { htmlFor: 'api-key-input', className: 'form-label' }, 'New API Key'),
                        e('div', { className: 'flex gap-2' },
                            e('input', { 
                                id: 'api-key-input', type: 'password', className: 'form-input flex-grow',
                                value: newApiKey, onChange: (ev) => setNewApiKey(ev.target.value)
                            }),
                            e('button', { type: 'button', onClick: handleAddApiKey, className: 'modal-button-secondary' }, 'Add')
                        )
                    ),
                    e('div', { className: 'mt-6' },
                        e('label', { className: 'form-label' }, 'Saved Keys'),
                        apiKeys.map((key, index) => e('div', { key: index, className: 'api-key-item' },
                            e('span', { className: 'font-mono' }, `**********${key.key.slice(-4)}`),
                            e('button', { onClick: () => handleRemoveApiKey(index), className: 'api-key-delete-btn' }, 'Remove')
                        ))
                    )
                );
            }
            if (activeTab === 'Quiz Defaults') {
                return e('div', null,
                    e('h3', { className: 'text-lg font-semibold mb-4' }, 'Default Quiz Generation'),
                    e('div', { className: 'grid grid-cols-2 gap-4' },
                        e('div', { className: 'form-group' },
                            e('label', { htmlFor: 'def-difficulty', className: 'form-label' }, 'Default Difficulty'),
                            e('select', { 
                                id: 'def-difficulty', className: 'form-select',
                                value: defaultSettings.defaultDifficulty, 
                                onChange: (ev) => handleDefaultChange('defaultDifficulty', ev.target.value)
                            },
                                e('option', { value: 'Easy' }, 'Ïâ¨ÏõÄ'),
                                e('option', { value: 'Medium' }, 'Î≥¥ÌÜµ'),
                                e('option', { value: 'Hard' }, 'Ïñ¥Î†§ÏõÄ')
                            )
                        ),
                        e('div', { className: 'form-group' },
                            e('label', { htmlFor: 'def-q-type', className: 'form-label' }, 'Default Question Type'),
                            e('select', {
                                id: 'def-q-type', className: 'form-select',
                                value: defaultSettings.defaultQuestionType, 
                                onChange: (ev) => handleDefaultChange('defaultQuestionType', ev.target.value)
                            },
                                // üìå (v10.2) Req 2: ÌïúÍ∏ÄÌôî Îßµ Ï†ÅÏö©
                                Object.entries(QUESTION_TYPE_MAP).map(([value, label]) => 
                                    e('option', { key: value, value: value }, label)
                                )
                            )
                        )
                    ),
                    e('div', { className: 'form-group' },
                        e('label', { htmlFor: 'def-num-q', className: 'form-label' }, 'Default Number of Questions'),
                        e('input', {
                            id: 'def-num-q', type: 'number', className: 'form-input',
                            value: defaultSettings.defaultNumQuestions, 
                            onChange: (ev) => handleDefaultChange('defaultNumQuestions', parseInt(ev.target.value, 10))
                        })
                    )
                );
            }
            if (activeTab === 'Prompts') {
                return e('div', { className: 'flex flex-col h-full' },
                    e('h3', { className: 'text-lg font-semibold mb-4' }, 'Quiz System Prompt'),
                    e('p', { className: 'text-xs text-gray-500 mb-4' }, 'Î≥ÄÏàò: {{DIFFICULTY}}, {{QUESTION_TYPE}}, {{NUM_QUESTIONS}}, {{CUSTOM_INSTRUCTIONS}} Îì±'),
                    e('textarea', {
                        className: 'form-textarea flex-grow h-full',
                        style: { height: '150px' },
                        value: quizSystemPrompt,
                        onChange: (e) => setQuizSystemPrompt(e.target.value)
                    }),
                    e('h3', { className: 'text-lg font-semibold mb-4 mt-6' }, 'Grading System Prompt'),
                    e('p', { className: 'text-xs text-gray-500 mb-4' }, 'Î≥ÄÏàò: (UserQueryÏóêÏÑú ÏûêÎèô Ï£ºÏûÖÎê®)'),
                    e('textarea', {
                        className: 'form-textarea flex-grow h-full',
                        style: { height: '150px' },
                        value: gradingSystemPrompt,
                        onChange: (e) => setGradingSystemPrompt(e.target.value)
                    })
                );
            }
            return null;
        };
        
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', onClick: (e) => e.stopPropagation() },
                e('div', { className: 'modal-header' },
                    e('h2', null, 'Settings'),
                    e('button', { className: 'modal-close-btn', onClick: onClose }, '√ó')
                ),
                e('div', { className: 'modal-body' },
                    e('nav', { className: 'settings-nav' },
                        e('div', { 
                            className: 'settings-nav-item', 'data-active': activeTab === 'Quiz Defaults',
                            onClick: () => setActiveTab('Quiz Defaults')
                        }, 'Quiz Defaults'),
                        e('div', { 
                            className: 'settings-nav-item', 'data-active': activeTab === 'API Keys',
                            onClick: () => setActiveTab('API Keys')
                        }, 'API Keys'),
                        e('div', { 
                            className: 'settings-nav-item', 'data-active': activeTab === 'Prompts',
                            onClick: () => setActiveTab('Prompts')
                        }, 'Prompts')
                    ),
                    e('div', { className: 'settings-content' }, renderTabContent())
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: onClose }, 'Cancel'),
                    e('button', { className: 'modal-button-primary', onClick: handleSave }, 'Save Changes')
                )
            )
        );
    };
    
    // (v10) ÌååÏùº Î©îÎ™® ÏóêÎîîÌÑ∞
    const FileNotesEditor = ({ activeFile, fileActions }) => {
        const [notes, setNotes] = useState("");
        useEffect(() => {
            setNotes(activeFile?.metadata?.notes || "");
        }, [activeFile]);
        const debouncedNotes = useDebounce(notes, 1000);
        useEffect(() => {
            if (activeFile && debouncedNotes !== (activeFile.metadata?.notes || "")) {
                fileActions.updateMetadata(activeFile.id, { notes: debouncedNotes });
            }
        }, [debouncedNotes, activeFile, fileActions]);
        return e('div', { className: 'h-full flex flex-col' },
            e('textarea', {
                key: activeFile.id,
                className: 'main-editor !p-4',
                style: { height: '100%' },
                value: notes,
                onChange: (ev) => setNotes(ev.target.value),
                placeholder: 'Ïù¥ ÌååÏùºÏóê ÎåÄÌïú ÏöîÏïΩ, Î©îÎ™® ÎòêÎäî Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî...'
            })
        );
    };


    // (v10) Í≤ÄÏÉâ Î∑∞
    const SearchView = ({ viewId }) => {
        const { files, setActiveEditorFile, handleActivityChange } = useContext(AppContext);
        const [searchTerm, setSearchTerm] = useState("");
        const [results, setResults] = useState([]);
        const debouncedSearchTerm = useDebounce(searchTerm, 300);
        useEffect(() => {
            if (!debouncedSearchTerm || debouncedSearchTerm.length < 2) {
                setResults([]);
                return;
            }
            const lowerTerm = debouncedSearchTerm.toLowerCase();
            const searchResults = files.filter(f => {
                if (f.type === 'folder') return false;
                const inName = f.name.toLowerCase().includes(lowerTerm);
                const inContent = f.content && f.content.toLowerCase().includes(lowerTerm);
                const inNotes = f.metadata?.notes && f.metadata.notes.toLowerCase().includes(lowerTerm);
                return inName || inContent || inNotes;
            });
            setResults(searchResults);
        }, [debouncedSearchTerm, files]);
        const handleResultClick = (file) => {
            setActiveEditorFile(file);
            if(handleActivityChange) {
                handleActivityChange('files', true);
            }
        };
        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, 'Ï†ÑÏ≤¥ Í≤ÄÏÉâ'),
            e('div', { className: 'view-content-full p-4' },
                e('div', { className: 'form-group' },
                    e('input', {
                        type: 'text',
                        className: 'form-input',
                        placeholder: 'ÌååÏùº Ïù¥Î¶Ñ, ÎÇ¥Ïö©, Î©îÎ™® Í≤ÄÏÉâ...',
                        value: searchTerm,
                        onChange: (e) => setSearchTerm(e.target.value),
                        autoFocus: true
                    })
                ),
                e('div', { className: 'mt-4' },
                    results.length === 0 && debouncedSearchTerm.length > 1 &&
                        e('p', { className: 'text-sm text-gray-400' }, 'Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.'),
                    results.map(file => e('div', {
                        key: file.id,
                        className: 'list-item',
                        onClick: () => handleResultClick(file)
                    },
                        e('div', { className: 'list-item-title' }, file.name)
                    ))
                )
            )
        );
    };
    
    // üìå (v10.2) Ïã†Í∑ú: ÏÇ¨Ïö©Ïûê Î∑∞ (Req 2)
    const UserView = ({ viewId }) => {
        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, 'ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ'),
            e('div', { className: 'view-content-scroll' },
                e('p', { className: 'text-sm text-gray-400' }, 'ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ Í∏∞Îä•ÏùÄ ÌòÑÏû¨ Ï§ÄÎπÑ Ï§ëÏûÖÎãàÎã§.')
            )
        );
    };
    
    // Î∑∞ 8: ÌÄ¥Ï¶à ÌíÄÏù¥ Î™®Îã¨ (v10.2 - ÌïúÍ∏ÄÌôî)
    const QuizTaker = ({ quiz, onClose, onQuizSubmit }) => {
        const [questions, setQuestions] = useState([]);
        const [currentAnswers, setCurrentAnswers] = useState({});
        useEffect(() => {
            try {
                const parsedQuestions = JSON.parse(quiz.questions);
                setQuestions(parsedQuestions);
            } catch (e) { console.error("ÌÄ¥Ï¶à ÏßàÎ¨∏ ÌååÏã± Ïò§Î•ò:", e); }
        }, [quiz]);
        const handleAnswerChange = (qIndex, value) => {
            setCurrentAnswers(prev => ({ ...prev, [qIndex]: value }));
        };
        const handleSubmit = () => {
            let score = 0;
            const userAnswers = questions.map((q, qIndex) => {
                let isCorrect = false;
                const selectedAnswer = currentAnswers[qIndex];
                switch (q.questionType) {
                    case 'MultipleChoice':
                        isCorrect = (selectedAnswer === q.correctAnswerIndex);
                        if (isCorrect) score++;
                        break;
                    default: 
                        isCorrect = null;
                        break;
                }
                return {
                    questionType: q.questionType,
                    questionText: q.questionText,
                    options: q.options,
                    selectedAnswer: selectedAnswer,
                    correctAnswerIndex: q.correctAnswerIndex,
                    gradingCriteria: q.gradingCriteria,
                    isCorrect: isCorrect
                };
            });
            const result = {
                id: crypto.randomUUID(),
                quizId: quiz.id,
                fileId: quiz.fileId,
                quizTitle: quiz.title,
                score: score,
                total: questions.length,
                answers: JSON.stringify(userAnswers),
                completedAt: new Date().toISOString()
            };
            onQuizSubmit(result);
        };
        const renderQuestion = (q, qIndex) => {
            switch (q.questionType) {
                case 'MultipleChoice':
                    return e('div', { className: 'options-container' },
                        (q.options || []).map((option, oIndex) => e('label', { key: oIndex, className: 'quiz-option-label' },
                            e('input', {
                                type: 'radio',
                                name: `question-${qIndex}`,
                                checked: currentAnswers[qIndex] === oIndex,
                                onChange: () => handleAnswerChange(qIndex, oIndex)
                            }),
                            option
                        ))
                    );
                default:
                    return e('div', { className: 'form-group' },
                        e('input', {
                            type: 'text',
                            className: 'form-input',
                            value: currentAnswers[qIndex] || "",
                            onChange: (ev) => handleAnswerChange(qIndex, ev.target.value)
                        })
                    );
            }
        };
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', style: { maxWidth: '800px' }, onClick: (e) => e.stopPropagation() },
                e('div', { className: 'modal-header' },
                    e('h2', null, quiz.title)
                ),
                e('div', { className: 'modal-body', style: { padding: '24px', display: 'block' } },
                    questions.map((q, qIndex) => e('div', { key: qIndex, className: 'quiz-question-card' },
                        e('p', { className: 'quiz-question-text' }, `${qIndex + 1}. ${q.questionText}`),
                        renderQuestion(q, qIndex)
                    ))
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: onClose }, 'Ï∑®ÏÜå'),
                    e('button', { className: 'modal-button-primary', onClick: handleSubmit }, 'ÌÄ¥Ï¶à Ï†úÏ∂ú')
                )
            )
        );
    };
    
    // Î∑∞ 9: ÌÄ¥Ï¶à Í≤∞Í≥º Î™®Îã¨
    const QuizResult = ({ attempt, quiz, onClose, dispatchGradingTask }) => {
        const { setModalContent } = useContext(AppContext);
        const toast = useToast();
        const [results, setResults] = useState([]);
        useEffect(() => {
            try { setResults(JSON.parse(attempt.answers)); }
            catch(e) { console.error("Í≤∞Í≥º ÌååÏã± Ïò§Î•ò", e); }
        }, [attempt]);
        const handleGradeAllSubjective = async () => {
            dispatchGradingTask(attempt);
            toast.show("AI Ï±ÑÏ†êÏùÑ ÏãúÏûëÌï©ÎãàÎã§. (ÏûëÏóÖ Î™®ÎãàÌÑ∞ üìä)", 'info');
            onClose();
        };
        const retryIncorrect = () => {
            toast.show("Ïò§Îãµ Îã§Ïãú ÌíÄÍ∏∞ Í∏∞Îä•ÏùÄ Íµ¨ÌòÑ Ï§ëÏûÖÎãàÎã§.", 'info');
        };
        const renderResultAnswer = (res, index) => {
            if (res.isCorrect === null) {
                return e(React.Fragment, null,
                    e('p', { className: 'result-answer yours' }, 
                        `Ï†úÏ∂úÌïú Îãµ: ${res.selectedAnswer || 'N/A'}`
                    ),
                    e('p', { className: 'result-answer correct text-xs mt-2' }, 
                        `[Ï±ÑÏ†ê Í∏∞Ï§Ä] ${res.gradingCriteria || 'N/A'}`
                    ),
                    e('p', { className: 'text-sm text-yellow-400 mt-2' }, 'AI Ï±ÑÏ†ê ÎåÄÍ∏∞ Ï§ë...')
                );
            }
            let answerContent;
            switch(res.questionType) {
                case 'MultipleChoice':
                    answerContent = e(React.Fragment, null,
                        e('p', { className: 'result-answer correct' }, 
                            `Ï†ïÎãµ: ${res.options[res.correctAnswerIndex]}`
                        ),
                        !res.isCorrect && e('p', { className: 'result-answer yours' }, 
                            `ÏÑ†ÌÉùÌïú Îãµ: ${res.options[res.selectedAnswer] || 'N/A'}`
                        )
                    );
                    break;
                default:
                    answerContent = e(React.Fragment, null,
                        e('p', { className: 'result-answer correct' }, 
                            `Ï±ÑÏ†ê Í∏∞Ï§Ä: ${res.gradingCriteria || 'N/A'}`
                        ),
                        e('p', { className: 'result-answer yours' }, 
                            `Ï†úÏ∂úÌïú Îãµ: ${res.selectedAnswer || 'N/A'}`
                        )
                    );
                    break;
            }
            return e(React.Fragment, null, 
                answerContent,
                res.feedback && e('div', { className: 'mt-2 p-2 bg-gray-800 rounded' },
                    e('p', { className: 'text-xs font-semibold text-blue-300' }, 'AI Ï≤®ÏÇ≠:'),
                    e('p', { className: 'text-sm' }, res.feedback)
                )
            );
        };
        const hasSubjectiveToGrade = useMemo(() => {
            return results.some(r => r.isCorrect === null);
        }, [results]);
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', onClick: (e) => e.stopPropagation() },
                e('div', { className: 'modal-header' },
                    e('h2', null, 'ÌÄ¥Ï¶à Í≤∞Í≥º: ' + attempt.quizTitle),
                    e('button', { className: 'modal-close-btn', onClick: onClose }, '√ó')
                ),
                e('div', { className: 'modal-body quiz-result-body', style: { display: 'block' } },
                    e('div', { className: 'quiz-result-score mb-6' }, 
                        `Ï†êÏàò: ${attempt.score} / ${attempt.total}`
                    ),
                    results.map((res, index) => e('div', { 
                        key: index, 
                        className: `result-question ${res.isCorrect === true ? 'result-question-correct' : (res.isCorrect === false ? 'result-question-incorrect' : 'bg-gray-700')}`
                    },
                        e('p', { className: 'result-question-text' }, `${index + 1}. ${res.questionText}`),
                        renderResultAnswer(res, index)
                    ))
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: retryIncorrect }, 'ÌãÄÎ¶∞ Î¨∏Ï†ú Îã§Ïãú ÌíÄÍ∏∞'),
                    hasSubjectiveToGrade && e('button', { 
                        className: 'modal-button-primary', 
                        onClick: handleGradeAllSubjective,
                    }, '‚ú® Ï†ÑÏ≤¥ AI Ï±ÑÏ†ê'),
                    e('button', { className: 'modal-button-primary', onClick: onClose }, 'Îã´Í∏∞')
                )
            )
        );
    };


    // --- 5. Î©îÏù∏ Ïï± Ïª¥Ìè¨ÎÑåÌä∏ (v10.2) ---
    const App = () => {
      const dbHelper = useMemo(() => new IdbHelper('AIQuizAppDB', 1, DB_STORES_CONFIG), []);
      const toast = useToast(); 
      const [isLoading, setIsLoading] = useState(true);
      const [userSettings, setUserSettings] = useState(DEFAULT_SETTINGS);
      const [modalContent, setModalContent] = useState(null);
      const [activeViewId, setActiveViewId] = useState('files');
      const [isSidebarVisible, setIsSidebarVisible] = useState(true);
      const [activeEditorFile, setActiveEditorFile] = useState(null);
      const [editingNodeId, setEditingNodeId] = useState(null);
      
      const QUIZ_OPTIONS_STORAGE_KEY = 'aiQuiz_quizOptions_v10';
      const getInitialQuizOptions = (settings) => {
          try {
              const savedOptions = localStorage.getItem(QUIZ_OPTIONS_STORAGE_KEY);
              if (savedOptions) {
                  return JSON.parse(savedOptions);
              }
          } catch (e) { console.error("Failed to parse saved quiz options", e); }
          return {
              numQuestions: settings.defaultNumQuestions || 10,
              difficulty: settings.defaultDifficulty || "Medium",
              questionType: settings.defaultQuestionType || "MultipleChoice",
              includeSnippets: false,
              provideAnswerKey: true,
              customInstructions: ""
          };
      };
      const [quizOptions, _setQuizOptions] = useState(() => getInitialQuizOptions(DEFAULT_SETTINGS));
      const setQuizOptions = useCallback((updater) => {
          _setQuizOptions(prev => {
              const newState = typeof updater === 'function' ? updater(prev) : updater;
              localStorage.setItem(QUIZ_OPTIONS_STORAGE_KEY, JSON.stringify(newState));
              return newState;
          });
      }, []);
      
      const quizWorker = useMemo(() => new Worker(workerUrl), []);
      const [taskQueue, setTaskQueue] = useState([]);
      const [files, setFiles] = useState([]);
      const [quizzes, setQuizzes] = useState([]);
      const [attempts, setAttempts] = useState([]);

      const refetchAllData = useCallback(async () => {
          if (!dbHelper.db) return;
          try {
              const [filesData, quizzesData, attemptsData, settingsData] = await Promise.all([
                  dbHelper.getAll('files'),
                  dbHelper.getAll('quizzes'),
                  dbHelper.getAll('quizAttempts'),
                  dbHelper.get('settings', 'userConfig')
              ]);
              setFiles(filesData);
              setQuizzes(quizzesData);
              setAttempts(attemptsData);
              const newSettings = settingsData || DEFAULT_SETTINGS;
              setUserSettings(newSettings);
              _setQuizOptions(getInitialQuizOptions(newSettings));
          } catch (e) {
              console.error("Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:", e);
          }
      }, [dbHelper]);
      
      const { fileTree, fileActions } = useFileSystem(files, dbHelper, refetchAllData);

      useEffect(() => {
        dbHelper.init().then(() => {
            refetchAllData().then(() => setIsLoading(false));
        });
      }, [dbHelper, refetchAllData]);
      
      useEffect(() => {
        quizWorker.onmessage = (e) => {
          const { status, taskId, taskType, quizData, updatedAttempt, error, options } = e.data; 
          setTaskQueue(prev => prev.map(task => 
              task.id === taskId ? { ...task, status, error } : task
          ));
          if (status === 'success') {
            if (taskType === 'grade' && updatedAttempt) {
                dbHelper.put('quizAttempts', updatedAttempt).then(() => {
                    refetchAllData();
                    if (toast) toast.show('‚úÖ AI Ï±ÑÏ†êÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.', 'success');
                });
            } else if (taskType === 'generate' && quizData) {
                const newQuiz = {
                    id: crypto.randomUUID(),
                    title: quizData.title,
                    sourceText: "N/A", 
                    fileId: options.fileId, 
                    sourceFileName: options.sourceFileName,
                    questions: JSON.stringify(quizData.questions),
                    createdAt: new Date().toISOString(),
                    questionCount: quizData.questions.length,
                    options: options
                };
                dbHelper.add('quizzes', newQuiz).then(() => {
                    refetchAllData();
                    if (toast) toast.show('‚ú® ÌÄ¥Ï¶à ÏÉùÏÑ±Ïù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.', 'success');
                });
            }
          } else if (status === 'error') {
              console.error(`Task ${taskId} (${taskType}) failed: ${error}`);
              if (toast) toast.show(`‚ùå ÏûëÏóÖ Ïã§Ìå®: ${error}`, 'error');
          }
        };
        return () => { quizWorker.onmessage = null; };
      }, [quizWorker, dbHelper, refetchAllData, toast]);
      
      const handleSaveSettings = useCallback(async (newSettings) => {
          const settingsToSave = { ...newSettings, id: 'userConfig' };
          await dbHelper.put('settings', settingsToSave);
          setUserSettings(settingsToSave);
          const currentOptions = localStorage.getItem(QUIZ_OPTIONS_STORAGE_KEY);
          if (!currentOptions) {
             _setQuizOptions(getInitialQuizOptions(settingsToSave));
          }
      }, [dbHelper]);

      const handleActivityChange = (id, forceVisible = false) => {
          if (id === 'settings') {
              setModalContent(e(SettingsModal, { onClose: () => setModalContent(null) }));
              return;
          }
          if (id === activeViewId && isSidebarVisible && !forceVisible) setIsSidebarVisible(false);
          else { setIsSidebarVisible(true); setActiveViewId(id); }
      };
      
      const dispatchTask = useCallback((taskData) => {
          const taskId = crypto.randomUUID();
          const newTask = { ...taskData, id: taskId, status: 'processing', taskType: 'generate' };
          setTaskQueue(prev => [newTask, ...prev]);
          quizWorker.postMessage({ ...newTask, settings: userSettings, DEFAULT_SETTINGS });
          handleActivityChange('tasks');
          if (toast) toast.show('‚ú® ÌÄ¥Ï¶à ÏÉùÏÑ±ÏùÑ ÏãúÏûëÌï©ÎãàÎã§.', 'info');
      }, [quizWorker, userSettings, toast]);
      
      const dispatchGradingTask = useCallback((attempt) => {
          const taskId = crypto.randomUUID();
          const newTask = { 
              id: taskId, 
              status: 'processing', 
              taskType: 'grade',
              options: { quizTitle: attempt.quizTitle }
          };
          setTaskQueue(prev => [newTask, ...prev]);
          quizWorker.postMessage({ ...newTask, attempt, settings: userSettings, DEFAULT_SETTINGS });
          handleActivityChange('tasks');
      }, [quizWorker, userSettings]);

      const handleQuizSubmit = async (result) => {
          try {
              await dbHelper.add('quizAttempts', result);
              await refetchAllData();
              setModalContent(e(QuizResult, {
                  attempt: result,
                  quiz: quizzes.find(q => q.id === result.quizId),
                  onClose: () => setModalContent(null),
                  userSettings,
                  dbHelper,
                  refetchAllData,
                  dispatchGradingTask
              }));
          } catch (err) { console.error("ÌÄ¥Ï¶à Ï†úÏ∂ú Ïò§Î•ò:", err); }
      };

      const contextValue = {
          dbHelper,
          refetchAllData,
          userSettings,
          saveSettings: handleSaveSettings,
          files,
          quizzes,
          attempts,
          taskQueue,
          dispatchTask,
          dispatchGradingTask,
          fileTree,
          fileActions,
          activeEditorFile,
          setActiveEditorFile,
          setModalContent,
          editingNodeId,
          setEditingNodeId,
          quizOptions, 
          setQuizOptions,
          handleQuizSubmit,
          toast,
          handleActivityChange
      };

      // üìå (v10.2) Req 1: ÏÇ¨Ïù¥ÎìúÎ∞î ÏïÑÏù¥ÌÖú Ï†ïÏùò (v10.1Í≥º ÎèôÏùº)
      const sidebarItems = [
        { id: 'files', label: 'ÌååÏùº ÌÉêÏÉâÍ∏∞', icon: 'üìÑ' },
        { id: 'search', label: 'Í≤ÄÏÉâ', icon: 'üîç' },
        { id: 'quiz-generator', label: 'ÌÄ¥Ï¶à ÏÉùÏÑ± ÏòµÏÖò', icon: '‚ú®' },
        { id: 'history', label: 'Ï†ÑÏ≤¥ ÌíÄÏù¥ Í∏∞Î°ù', icon: 'üìö' },
        { id: 'tasks', label: 'ÏûëÏóÖ Î™®ÎãàÌÑ∞', icon: 'üìä' },
        { id: 'user', label: 'ÏÇ¨Ïö©Ïûê', icon: 'üë§', isBottom: true },
        { id: 'settings', label: 'ÏÑ§Ï†ï', icon: '‚öôÔ∏è', isBottom: true },
      ];
      
      if (isLoading) {
        return e('div', { className: 'flex items-center justify-center h-screen' }, e(Spinner));
      }

      return e(AppContext.Provider, { value: contextValue },
        e('div', { className: 'flex h-screen' },
          e(ReactVscodeSidebar, {
            items: sidebarItems,
            onActiveChange: handleActivityChange,
            activeId: activeViewId,
            isVisible: isSidebarVisible
          },
            // Î∑∞ Ïª®ÌÖêÏ∏† (Children)
            e(FileManagerView, { viewId: 'files' }),
            e(SearchView, { viewId: 'search' }),
            e(QuizGeneratorView, { viewId: 'quiz-generator' }),
            e(QuizHistoryView, { viewId: 'history' }),
            e(TaskMonitorView, { viewId: 'tasks' }),
            // üìå (v10.2) Req 2: ÏÇ¨Ïö©Ïûê Î∑∞ Ï∂îÍ∞Ä
            e(UserView, { viewId: 'user' })
          ),
          
          e('div', { className: 'main-content' }, 
            e(MainContentEditor, null)
          ),
          
          modalContent
        )
      );
    };

    // --- 6. Ïï± ÎßàÏö¥Ìä∏ ---
    const root = createRoot(document.getElementById('root'));
    root.render(e(ToastProvider, null, e(App)));
    
  </script>
</body>
</html>
