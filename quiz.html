<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI í€´ì¦ˆ VSCode (v9 - ê³ ê¸‰ íŒŒì¼ ì„í¬íŠ¸)</title>

  <!-- 1. ì˜ì¡´ì„± ë¡œë“œ: React, Tailwind -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- ğŸ“Œ ì‹ ê·œ: íŒŒì¼ ì²˜ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ (ZIP, PDF, DOCX) ğŸ“Œ -->
  <!-- ZIP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- PDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    // PDF.js ì›Œì»¤ ì„¤ì •
    if (typeof pdfjsLib !== 'undefined') {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    }
  </script>
  <!-- DOCX -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
  
  <!-- 2. ìŠ¤íƒ€ì¼: VSCode ë‹¤í¬ í…Œë§ˆ ë° ì‹ ê·œ UI ìŠ¤íƒ€ì¼ -->
  <style>
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
        Helvetica, Arial, sans-serif;
      margin: 0;
      background-color: #1e1e1e; /* VSCode ë°°ê²½ */
      color: #cccccc;
      height: 100vh;
      overflow: hidden;
    }
    
    /* ìŠ¤í¬ë¡¤ë°” ìŠ¤íƒ€ì¼ */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #252526; }
    ::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #5a5a5a; }

    /* * ReactVscodeSidebar ì…¸ ìŠ¤íƒ€ì¼ë§
     */
    .vsc-sidebar-container {
      display: flex;
      flex-direction: row;
      width: auto;
      height: 100vh;
    }
    .vsc-activity-bar {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 8px 0;
      background-color: #333333;
      color: white;
      flex-shrink: 0;
      width: 52px;
    }
    .vsc-activity-item {
      background-color: transparent;
      border: none;
      color: #b0b0b0;
      padding: 12px;
      margin: 2px 4px;
      cursor: pointer;
      font-size: 24px;
      line-height: 1;
      border-radius: 4px;
      transition: background-color 0.2s, color 0.2s;
    }
    .vsc-activity-item:hover { background-color: #404040; }
    .vsc-activity-item[data-active='true'] {
      color: #ffffff;
      background-color: #4a4a4a;
    }
    
    .vsc-sidebar-view {
      flex-grow: 1;
      overflow-y: auto;
      background-color: #252526;
      color: #cccccc;
      width: 300px;
      min-width: 300px;
      border-right: 1px solid #444;
      transition: min-width 0.2s ease-out, width 0.2s ease-out;
      overflow: hidden;
    }
    .vsc-sidebar-view[data-visible='false'] {
      width: 0px;
      min-width: 0px;
      border-right: none;
    }
    .vsc-view-content {
      height: 100%;
      min-width: 300px;
      display: flex;
      flex-direction: column;
    }
    
    /* ë·° ì»¨í…ì¸  ê¸°ë³¸ íŒ¨ë”© */
    .view-padding {
        padding: 16px;
    }
    /* ë·° ì»¨í…ì¸  í—¤ë” */
    .view-header {
      margin-top: 0;
      color: #cccccc;
      font-size: 1.1rem;
      font-weight: 600;
      padding: 12px 16px;
      border-bottom: 1px solid #444;
      flex-shrink: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    /* ë·° í—¤ë” ì•„ì´ì½˜ ë²„íŠ¼ */
    .view-header-icon {
        background: none; border: none; color: #b0b0b0; cursor: pointer;
        padding: 4px; border-radius: 4px;
    }
    .view-header-icon:hover { background-color: #4a4a4a; color: white; }
    
    /* ë·° ì»¨í…ì¸  ìŠ¤í¬ë¡¤ ì˜ì—­ */
    .view-content-scroll {
        flex-grow: 1;
        overflow-y: auto;
        padding: 16px;
    }
    .view-content-full { /* íŒ¨ë”© ì—†ëŠ” ê½‰ ì°¬ ì»¨í…ì¸  (íŒŒì¼ íƒìƒ‰ê¸°ìš©) */
        flex-grow: 1;
        overflow-y: auto;
    }
    
    /* (v5) ë¶„í•  ë·° ìŠ¤íƒ€ì¼ */
    .vsc-view-panes {
        display: flex;
        flex-direction: column;
        height: 100%;
    }
    .vsc-view-pane {
        flex: 1;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    .vsc-view-pane-header {
        padding: 4px 12px;
        background-color: #333;
        font-size: 0.9rem;
        font-weight: 500;
        border-top: 1px solid #444;
        border-bottom: 1px solid #444;
    }
    .vsc-view-pane-content {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
    }
    .vsc-view-pane-content.full {
        padding: 0; /* íŒŒì¼ íŠ¸ë¦¬ìš© */
    }


    /* * ë©”ì¸ ì»¨í…ì¸  ì˜ì—­ (íŒŒì¼ ì—ë””í„°)
     */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    /* (v5) ë©”ì¸ ì—ë””í„° í—¤ë” */
    .main-editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background-color: #252526;
        border-bottom: 1px solid #444;
        flex-shrink: 0;
    }
    .main-editor-title {
        font-size: 0.9rem;
    }
    .main-editor-action-btn {
        background-color: #0e639c;
        color: white;
        padding: 4px 10px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
    }
    .main-editor-action-btn:hover { background-color: #1177bb; }
    .main-editor-action-btn:disabled { background-color: #555; cursor: not-allowed; }
    
    .main-editor {
      flex-grow: 1;
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: none;
      outline: none;
      padding: 20px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      line-height: 1.5;
      resize: none;
    }
    .main-editor-placeholder {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: #6a6a6a;
      font-size: 1.2rem;
    }
    
    .main-editor-footer {
        padding: 4px 12px;
        background-color: #252526;
        border-top: 1px solid #444;
        flex-shrink: 0;
        font-size: 0.8rem;
        color: #a0a0a0;
        text-align: right;
        min-height: 26px; /* í…ìŠ¤íŠ¸ ë†’ì´ í™•ë³´ */
    }
    
    /* * í¼ ìš”ì†Œ ìŠ¤íƒ€ì¼ (í€´ì¦ˆ ìƒì„±ê¸°, ì„¤ì •)
     */
    .form-group { margin-bottom: 16px; }
    .form-label {
        display: block;
        font-size: 0.9rem;
        margin-bottom: 6px;
        color: #a0a0a0;
        font-weight: 500;
    }
    .form-input, .form-textarea, .form-select {
      width: 100%;
      padding: 8px;
      box-sizing: border-box;
      border: 1px solid #444;
      background-color: #3c3c3c;
      color: #cccccc;
      border-radius: 4px;
    }
    .form-textarea {
        font-family: 'Courier New', Courier, monospace;
    }
    .form-select {
        appearance: none;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239ca3af' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 0.5rem center;
        background-size: 1.2em 1.2em;
        padding-right: 2.5rem;
    }
    .form-checkbox-label {
        display: flex;
        align-items: center;
        font-size: 0.9rem;
        color: #cccccc;
        cursor: pointer;
    }
    .form-checkbox {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        background-color: #3c3c3c;
        border: 1px solid #444;
        border-radius: 3px;
    }
    .form-button {
      background-color: #0e639c;
      color: white;
      width: 100%;
      padding: 10px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
      font-weight: 600;
    }
    .form-button:hover { background-color: #1177bb; }
    .form-button:disabled { background-color: #555; cursor: not-allowed; }

    /* * í€´ì¦ˆ ê¸°ë¡/ëª¨ë‹ˆí„°ë§ ëª©ë¡
     */
    .list-item {
      padding: 10px;
      background-color: #3c3c3c;
      border-radius: 4px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .list-item:hover { background-color: #4a4a4a; }
    .list-item-title { font-weight: 600; }
    .list-item-sub { font-size: 0.8rem; color: #a0a0a0; }
    .list-item-badge {
        font-size: 0.8rem;
        padding: 2px 6px;
        border-radius: 10px;
        background-color: #4a90e2;
        color: white;
    }
    .list-item-badge.success { background-color: #4CAF50; }
    .list-item-badge.error { background-color: #f44336; }
    
    /* (v6) í€´ì¦ˆ í’€ì´/ê²°ê³¼ ìŠ¤íƒ€ì¼ */
    .quiz-question-card { margin-bottom: 1.5rem; }
    .quiz-question-text { font-weight: 600; font-size: 1.1rem; margin-bottom: 0.75rem; }
    .quiz-option-label {
        display: block;
        padding: 10px;
        background-color: #3c3c3c;
        border-radius: 4px;
        margin-bottom: 8px;
        cursor: pointer;
    }
    .quiz-option-label:hover { background-color: #4a4a4a; }
    .quiz-option-label input { margin-right: 10px; }


    /* * ëª¨ë‹¬ (ì„¤ì •, í€´ì¦ˆ ê²°ê³¼)
     */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    .modal-container {
      background-color: #2d2d2d;
      color: #cccccc;
      border-radius: 8px;
      width: 90%;
      max-width: 700px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .modal-header {
      padding: 16px 24px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 { margin: 0; font-size: 1.2rem; }
    .modal-close-btn {
      background: none; border: none; color: #a0a0a0; font-size: 1.5rem;
      cursor: pointer; padding: 0; line-height: 1;
    }
    .modal-body {
      padding: 0;
      overflow-y: auto;
      display: flex;
      flex-grow: 1;
    }
    .modal-footer {
      padding: 16px 24px;
      border-top: 1px solid #444;
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }
    .modal-button {
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }
    .modal-button-primary {
      background-color: #0e639c; color: white; border: none;
    }
    .modal-button-primary:hover { background-color: #1177bb; }
    .modal-button-secondary {
      background-color: #4a4a4a; color: #cccccc; border: none;
    }
    .modal-button-secondary:hover { background-color: #5a5a5a; }
    
    /* ì„¤ì • ëª¨ë‹¬ ë‚´ë¶€ ë„¤ë¹„ê²Œì´ì…˜ */
    .settings-nav {
      width: 200px;
      flex-shrink: 0;
      padding: 24px 0;
      border-right: 1px solid #444;
    }
    .settings-nav-item {
      padding: 10px 24px;
      cursor: pointer;
      font-size: 0.9rem;
      border-left: 3px solid transparent;
    }
    .settings-nav-item:hover { background-color: #3c3c3c; }
    .settings-nav-item[data-active='true'] {
      background-color: #3c3c3c;
      border-left-color: #0e639c;
      color: white;
    }
    .settings-content {
      padding: 24px;
      flex-grow: 1;
      overflow-y: auto;
      display: flex; /* ìì‹(textarea)ì´ 100% ë†’ì´ ì°¨ì§€í•˜ë„ë¡ */
      flex-direction: column;
    }
    
    /* API í‚¤ ëª©ë¡ */
    .api-key-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        background-color: #3c3c3c;
        border-radius: 4px;
        margin-bottom: 8px;
    }
    .api-key-delete-btn {
        background: #f44336; color: white; border: none;
        border-radius: 4px; padding: 4px 8px; font-size: 0.8rem;
        cursor: pointer;
    }

    /* í€´ì¦ˆ ê²°ê³¼ ëª¨ë‹¬ */
    .quiz-result-body { padding: 24px; }
    .quiz-result-score { font-size: 2rem; font-weight: bold; text-align: center; }
    .result-question {
        padding: 12px;
        border-radius: 4px;
        margin-bottom: 8px;
    }
    .result-question-correct { background-color: #3a4a3a; }
    .result-question-incorrect { background-color: #5a3a3a; }
    /* AI ì±„ì  ëŒ€ê¸° ì¤‘ ìŠ¤íƒ€ì¼ */
    .bg-gray-700 { background-color: #3c3c3c; } 
    .result-question-text { font-weight: 600; margin-bottom: 4px; }
    .result-answer { font-size: 0.9rem; }
    .result-answer.correct { color: #81c784; }
    .result-answer.yours { color: #ffb74d; }
    /* ğŸ“Œ ì‹ ê·œ: AI ì¡°ì–¸ */
    .ai-advice-container {
        margin-top: 24px;
        padding: 16px;
        background-color: #252526;
        border-radius: 6px;
    }
    .ai-advice-header {
        font-size: 1.1rem;
        font-weight: 600;
        color: #4a90e2;
        margin-bottom: 12px;
    }
    .ai-advice-body {
        white-space: pre-wrap;
        line-height: 1.6;
    }


    /* íŒŒì¼ ê´€ë¦¬ì (vsc-view-content-full) */
    .file-manager-container {
        height: 100%;
        font-size: 14px;
    }
    .file-tree-list { padding: 8px; }
    .file-tree-node {
        display: flex;
        align-items: center;
        padding: 4px 8px;
        cursor: pointer;
        border-radius: 4px;
    }
    .file-tree-node:hover { background-color: #3c3c3c; }
    .file-tree-node[data-active='true'] { background-color: #094771; }
    /* (v5) ë“œë˜ê·¸ ì˜¤ë²„ (í´ë”) */
    .file-tree-node[data-drag-over='true'] {
        background-color: #0e639c;
    }
    .file-tree-node-icon { margin-right: 6px; }
    
    /* (v4.1) ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ìŠ¤íƒ€ì¼ */
    .context-menu {
      position: fixed;
      z-index: 1000;
      background-color: #252526;
      border: 1px solid #37373d;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      padding: 4px 0;
      min-width: 150px;
    }
    .context-menu-item {
      padding: 6px 12px;
      font-size: 0.9rem;
      cursor: pointer;
    }
    .context-menu-item:hover {
      background-color: #094771;
    }
    .context-menu-item-delete {
      color: #f48771;
    }
    .context-menu-divider {
      border-top: 1px solid #37373d;
      margin: 4px 0;
    }
    
    /* ë¡œë”© ìŠ¤í”¼ë„ˆ */
    .spinner-overlay {
      position: absolute; inset: 0;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex; justify-content: center; align-items: center;
      z-index: 50;
    }
    /* ìŠ¤í”¼ë„ˆ ìŠ¤íƒ€ì¼ ì¬ì •ì˜ (QuizResultìš©) */
    .spinner-overlay.\!relative { position: relative; }
    .spinner-overlay.\!h-10 { height: 2.5rem; }
    .spinner-overlay.\!bg-transparent { background-color: transparent; }
    .spinner {
      border: 4px solid #f3f3f3; border-top: 4px solid #0e639c;
      border-radius: 50%; width: 40px; height: 40px;
      animation: spin 1s linear infinite;
    }
    .spinner.\!w-6 { width: 1.5rem; }
    .spinner.\!h-6 { height: 1.5rem; }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* ğŸ“Œ ì‹ ê·œ: í† ìŠ¤íŠ¸ ë©”ì‹œì§€ ì‹œìŠ¤í…œ ìŠ¤íƒ€ì¼ ğŸ“Œ */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1001;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .toast-item {
      padding: 12px 16px;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: toast-fade-in 0.3s ease-out;
    }
    .toast-item.success {
      background-color: #4CAF50; /* Green */
    }
    .toast-item.error {
      background-color: #f44336; /* Red */
    }
    .toast-item.info {
      background-color: #0e639c; /* Blue */
    }
    @keyframes toast-fade-in {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    /* ğŸ“Œ ì‹ ê·œ: ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì˜¤ë²„ë ˆì´ ğŸ“Œ */
    .drag-overlay {
      position: fixed;
      inset: 0;
      z-index: 999;
      background-color: rgba(14, 99, 156, 0.7);
      border: 4px dashed #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
      font-weight: bold;
      color: white;
      pointer-events: none; /* ë“œë¡­ ì´ë²¤íŠ¸ê°€ í†µê³¼í•˜ë„ë¡ */
    }

  </style>
</head>
<body>
  
  <div id="root"></div>
  <!-- ğŸ“Œ (ìˆ˜ì •) multiple ë° accept ì†ì„± ì¶”ê°€ -->
  <input type="file" id="file-upload-input" style="display: none" multiple accept=".txt,.md,.pdf,.docx,.zip" />
  <input type="file" id="project-import-input" style="display: none" accept=".json" />


  <!-- 3. React ì• í”Œë¦¬ì¼€ì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ -->
  <script type="module">
    const { 
      useState, 
      useEffect, 
      useCallback, 
      useMemo,
      createContext,
      useContext
    } = React;
    const { createRoot } = ReactDOM;
    const e = React.createElement;

    // ğŸ“Œ ì‹ ê·œ: í† ìŠ¤íŠ¸ ì»¨í…ìŠ¤íŠ¸
    const ToastContext = createContext(null);
    const useToast = () => useContext(ToastContext);
    
    // React ì»¨í…ìŠ¤íŠ¸: ì „ì—­ ìƒíƒœ ê´€ë¦¬
    const AppContext = createContext(null);
    
    // --- 0. IndexedDB í—¬í¼ (v5 - ì¸ë±ìŠ¤ ì¶”ê°€) ---
    class IdbHelper {
        constructor(dbName, version, stores) {
            this.dbName = dbName;
            this.version = version;
            this.stores = stores; // { name, keyPath, indexes: [{name, keyPath}] }[]
            this.db = null;
        }

        init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, this.version);
                request.onerror = (event) => reject("IndexedDB ì˜¤ë¥˜: " + request.error);
                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    resolve(this);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    this.stores.forEach(storeConfig => {
                        let store;
                        if (!db.objectStoreNames.contains(storeConfig.name)) {
                            store = db.createObjectStore(storeConfig.name, { keyPath: storeConfig.keyPath });
                        } else {
                            store = event.target.transaction.objectStore(storeConfig.name);
                        }
                        
                        // (v5) ì¸ë±ìŠ¤ ìƒì„±
                        (storeConfig.indexes || []).forEach(idx => {
                            if (!store.indexNames.contains(idx.name)) {
                                store.createIndex(idx.name, idx.keyPath, { unique: false });
                            }
                        });
                    });
                };
            });
        }

        get(storeName, key) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        getAll(storeName) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        query(storeName, indexName, value) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readonly');
                const store = tx.objectStore(storeName);
                const index = store.index(indexName);
                const request = index.getAll(value);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        put(storeName, item) {
             return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.put(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        add(storeName, item) {
             return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.add(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        delete(storeName, key) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.delete(key);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        clear(storeName) {
            return new Promise((resolve, reject) => {
                const tx = this.db.transaction(storeName, 'readwrite');
                const store = tx.objectStore(storeName);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
    }
    
    // (v5) DB ìŠ¤í‚¤ë§ˆ ì •ì˜
    const DB_STORES_CONFIG = [
        { name: 'files', keyPath: 'id', indexes: [{ name: 'by_parentId', keyPath: 'parentId' }] },
        { name: 'quizzes', keyPath: 'id', indexes: [{ name: 'by_fileId', keyPath: 'fileId' }] },
        { name: 'quizAttempts', keyPath: 'id', indexes: [{ name: 'by_fileId', keyPath: 'fileId' }, { name: 'by_quizId', keyPath: 'quizId' }] },
        { name: 'settings', keyPath: 'id' }
    ];

    // --- 1. AI Gemini API í˜¸ì¶œ (Rule R2.2.6) ---

    // ğŸ“Œ (ìˆ˜ì • 1) í€´ì¦ˆ ìƒì„±ì„ ìœ„í•œ JSON ìŠ¤í‚¤ë§ˆ (ì±„ì  ê¸°ì¤€)
    const QUIZ_SCHEMA = {
      type: "OBJECT",
      properties: {
        title: { type: "STRING" },
        questions: {
          type: "ARRAY",
          items: {
            type: "OBJECT",
            properties: {
              questionType: { type: "STRING" }, // "MultipleChoice", "ShortAnswer"
              questionText: { type: "STRING" },
              // ê°ê´€ì‹ ì „ìš©
              options: { type: "ARRAY", items: { type: "STRING" }, nullable: true },
              correctAnswerIndex: { type: "NUMBER", nullable: true },
              // ğŸ“Œ (ìˆ˜ì •) ì£¼ê´€ì‹/ì‚¬ë¡€í˜• ì±„ì  ê¸°ì¤€
              gradingCriteria: { type: "STRING", nullable: true },
            },
            required: ["questionType", "questionText"]
          }
        }
      },
      required: ["title", "questions"]
    };
    
    /* ğŸ“Œ (ìˆ˜ì • 2) AI ì±„ì  ê²°ê³¼ ìŠ¤í‚¤ë§ˆ (ë¶€ë¶„ ì ìˆ˜) ğŸ“Œ */
    const GRADING_SCHEMA = {
      type: "OBJECT",
      properties: {
        score: { type: "NUMBER", description: "ì±„ì  ê¸°ì¤€ì— ë”°ë¥¸ 0.0ì—ì„œ 1.0 ì‚¬ì´ì˜ ì ìˆ˜. 1.0ì´ ë§Œì ." },
        feedback: { type: "STRING", description: "ì‚¬ìš©ìì˜ ë‹µë³€ì— ëŒ€í•´ ì ìˆ˜ ê·¼ê±°ë¥¼ í¬í•¨í•œ êµ¬ì²´ì ì¸ ì²¨ì‚­ ë‚´ìš©." }
      },
      required: ["score", "feedback"]
    };
    
    /* ğŸ“Œ (ì‹ ê·œ) AI í•™ìŠµ ì¡°ì–¸ ìŠ¤í‚¤ë§ˆ ğŸ“Œ */
    const ANALYSIS_SCHEMA = {
      type: "OBJECT",
      properties: {
        studyAdvice: { type: "STRING", description: "í‹€ë¦° ë¬¸ì œ ëª©ë¡ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ êµ¬ì²´ì ì¸ í•™ìŠµ ì¡°ì–¸." }
      },
      required: ["studyAdvice"]
    };

    class ApiError extends Error {
      constructor(message, status) { super(message); this.name = 'ApiError'; this.status = status; }
    }
    const fetchWithRetry = async (url, options, retries = 3, delay = 1000) => {
      for (let i = 0; i < retries; i++) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            if (response.status === 429) throw new ApiError('Rate limit exceeded', response.status);
            throw new ApiError(`HTTP error! status: ${response.status}`, response.status);
          }
          return response.json();
        } catch (error) {
          if (error.status === 429 && i < retries - 1) {
            await new Promise(res => setTimeout(res, delay * Math.pow(2, i)));
          } else { throw error; }
        }
      }
      throw new Error('API call failed after all retries');
    };
    
    // (v6) Gemini API í˜¸ì¶œ í•¨ìˆ˜ (ë‹¤í˜•ì„± ìŠ¤í‚¤ë§ˆ ì‚¬ìš©)
    const generateQuizWithAi = async (sourceText, options, settings) => {
      const { numQuestions, difficulty, questionType, includeSnippets, provideAnswerKey, customInstructions } = options;
      const apiKeys = settings?.apiKeys || [{ key: "", rpm: 60 }]; 
      const keyIndex = Date.now() % apiKeys.length; 
      const selectedKey = apiKeys[keyIndex];
      const apiKey = selectedKey.key.trim() ? selectedKey.key.trim() : "";
      const model = settings?.modelName || "gemini-2.5-flash-preview-09-2025";
      
      /* ğŸ“Œ (ìˆ˜ì • 3) API í‚¤ ê°€ë“œ í´ë¡œì¦ˆ (í™•ì¸) */
      if (!apiKey) {
          throw new ApiError('API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. [ì„¤ì •(âš™ï¸) > API Keys]ì—ì„œ ìœ íš¨í•œ í‚¤ë¥¼ ì¶”ê°€í•˜ì‹­ì‹œì˜¤.', 401); 
      }

      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      
      let systemPrompt = settings.quizSystemPrompt || DEFAULT_SETTINGS.quizSystemPrompt;
      
      systemPrompt = systemPrompt
          .replace('{{DIFFICULTY}}', difficulty)
          .replace('{{QUESTION_TYPE}}', questionType) // ğŸ“Œ (v6) AIì—ê²Œ ìœ í˜• ëª…ì‹œ
          .replace('{{INCLUDE_SNIPPETS}}', includeSnippets ? "Include relevant code snippets from the text if applicable." : "")
          .replace('{{PROVIDE_ANSWER_KEY}}', provideAnswerKey ? "Ensure correct answers are provided." : "")
          .replace('{{CUSTOM_INSTRUCTIONS}}', customInstructions ? `Additional Instructions: ${customInstructions}` : "")
          .replace('{{NUM_QUESTIONS}}', numQuestions);
          
      const userQuery = `--- SOURCE TEXT ---
${sourceText}
--- END SOURCE TEXT ---
`;

      const payload = {
        contents: [{ role: "user", parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: QUIZ_SCHEMA, // ğŸ“Œ (v6) ìƒˆ ìŠ¤í‚¤ë§ˆ
          temperature: 0.3,
        }
      };

      try {
        const result = await fetchWithRetry(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const candidate = result.candidates?.[0];
        if (candidate && candidate.content?.parts?.[0]?.text) {
          return JSON.parse(candidate.content.parts[0].text);
        } else {
          const errorReason = candidate?.finishReason || "Unknown error";
          throw new Error(`AIê°€ ìœ íš¨í•œ í€´ì¦ˆë¥¼ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (Reason: ${errorReason})`);
        }
      } catch (error) {
        console.error("AI í€´ì¦ˆ ìƒì„± ì˜¤ë¥˜:", error);
        throw new Error(`AI í€´ì¦ˆ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
      }
    };
    
    /* ğŸ“Œ (ìˆ˜ì • 4) AI ì£¼ê´€ì‹ ì±„ì  API í•¨ìˆ˜ ğŸ“Œ */
    const gradeAnswerWithAi = async (questionText, userAnswer, gradingCriteria, settings) => {
      const apiKeys = settings?.apiKeys || [{ key: "", rpm: 60 }]; 
      const keyIndex = Date.now() % apiKeys.length; 
      const selectedKey = apiKeys[keyIndex];
      const apiKey = selectedKey.key.trim() ? selectedKey.key.trim() : "";
      const model = settings?.modelName || "gemini-2.5-flash-preview-09-2025";

      if (!apiKey) {
        throw new ApiError('API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. [ì„¤ì •(âš™ï¸) > API Keys]ì—ì„œ ìœ íš¨í•œ í‚¤ë¥¼ ì¶”ê°€í•˜ì‹­ì‹œì˜¤.', 401);
      }
      
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      
      const systemPrompt = settings.gradingSystemPrompt || DEFAULT_SETTINGS.gradingSystemPrompt;
      
      const userQuery = `--- QUESTION ---
${questionText}

--- GRADING CRITERIA (Rubric) ---
${gradingCriteria}

--- USER'S ANSWER ---
${userAnswer}
--- END OF DATA ---

Please grade the "USER'S ANSWER" based *only* on the "GRADING CRITERIA" and provide feedback.
`;

      const payload = {
        contents: [{ role: "user", parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: GRADING_SCHEMA, // ğŸ“Œ (ìˆ˜ì •) ë¶€ë¶„ ì ìˆ˜ ìŠ¤í‚¤ë§ˆ
          temperature: 0.1
        }
      };

      try {
        const result = await fetchWithRetry(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const candidate = result.candidates?.[0];
        if (candidate && candidate.content?.parts?.[0]?.text) {
          return JSON.parse(candidate.content.parts[0].text);
        } else {
          const errorReason = candidate?.finishReason || "Unknown error";
          throw new Error(`AIê°€ ì±„ì ì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (Reason: ${errorReason})`);
        }
      } catch (error) {
        console.error("AI ì±„ì  ì˜¤ë¥˜:", error);
        throw new Error(`AI ì±„ì  ì‹¤íŒ¨: ${error.message}`);
      }
    };
    
    /* ğŸ“Œ (ì‹ ê·œ) AI í•™ìŠµ ì¡°ì–¸ API í•¨ìˆ˜ ğŸ“Œ */
    const analyzeResultsWithAi = async (incorrectResults, settings) => {
      const apiKeys = settings?.apiKeys || [{ key: "", rpm: 60 }]; 
      const keyIndex = Date.now() % apiKeys.length; 
      const selectedKey = apiKeys[keyIndex];
      const apiKey = selectedKey.key.trim() ? selectedKey.key.trim() : "";
      const model = settings?.modelName || "gemini-2.5-flash-preview-09-2025";

      if (!apiKey) {
        throw new ApiError('API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. [ì„¤ì •(âš™ï¸) > API Keys]ì—ì„œ ìœ íš¨í•œ í‚¤ë¥¼ ì¶”ê°€í•˜ì‹­ì‹œì˜¤.', 401);
      }
      
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      const systemPrompt = settings.analysisSystemPrompt || DEFAULT_SETTINGS.analysisSystemPrompt;
      
      const analysisData = incorrectResults.map(r => ({
          question: r.questionText,
          yourAnswer: r.selectedAnswer,
          feedback: r.feedback,
          score: r.score_0_1,
          gradingCriteria: r.gradingCriteria
      }));

      const userQuery = `--- INCORRECT/PARTIAL ANSWERS ---
${JSON.stringify(analysisData, null, 2)}
--- END OF DATA ---

Please analyze this list of incorrect or partially correct answers and provide study advice in Korean.
`;

      const payload = {
        contents: [{ role: "user", parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: ANALYSIS_SCHEMA,
          temperature: 0.5
        }
      };

      try {
        const result = await fetchWithRetry(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const candidate = result.candidates?.[0];
        if (candidate && candidate.content?.parts?.[0]?.text) {
          return JSON.parse(candidate.content.parts[0].text);
        } else {
          const errorReason = candidate?.finishReason || "Unknown error";
          throw new Error(`AIê°€ ì¡°ì–¸ì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (Reason: ${errorReason})`);
        }
      } catch (error) {
        console.error("AI ì¡°ì–¸ ìƒì„± ì˜¤ë¥˜:", error);
        throw new Error(`AI ì¡°ì–¸ ìƒì„± ì‹¤íŒ¨: ${error.message}`);
      }
    };


    // --- 2. Web Worker (ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬) ---
    // ğŸ“Œ (ìˆ˜ì • 5) Worker Script ì „ë©´ ìˆ˜ì • (AI ë¶€ë¶„ ì±„ì  ë¡œì§)
    const workerScript = `
      /* ğŸ“Œ 1. ì˜ì¡´ì„± ì£¼ì… (í€´ì¦ˆ ìƒì„±) ğŸ“Œ */
      const fetchWithRetry = ${fetchWithRetry.toString()};
      ${ApiError.toString()}
      const generateQuizWithAi = ${generateQuizWithAi.toString()};
      const QUIZ_SCHEMA = ${JSON.stringify(QUIZ_SCHEMA)};
      
      /* ğŸ“Œ 2. ì˜ì¡´ì„± ì£¼ì… (í€´ì¦ˆ ì±„ì ) ğŸ“Œ */
      const gradeAnswerWithAi = ${gradeAnswerWithAi.toString()};
      const GRADING_SCHEMA = ${JSON.stringify(GRADING_SCHEMA)};

      /* ğŸ“Œ 3. AI ì „ì²´ ì±„ì  ë¡œì§ (100ì  ë§Œì  ê¸°ì¤€) ğŸ“Œ */
      const handleAsyncGrading = async (attempt, settings, DEFAULT_SETTINGS) => {
          const results = JSON.parse(attempt.answers);
          
          let newScore = 0; // 100ì  ë§Œì  ê¸°ì¤€

          const gradingPromises = results.map(async (originalResult) => {
              // 1-1. ì´ë¯¸ ì±„ì ëœ ë¬¸ì œ (ê°ê´€ì‹)ëŠ” ì ìˆ˜ë¥¼ ëˆ„ì í•˜ê³  ê·¸ëŒ€ë¡œ ë°˜í™˜
              if (originalResult.isCorrect !== null) {
                  newScore += originalResult.points;
                  return originalResult;
              }
              
              // 1-2. ì±„ì  ëŒ€ìƒ (ì£¼ê´€ì‹)
              try {
                  const gradeData = await gradeAnswerWithAi(
                      originalResult.questionText,
                      originalResult.selectedAnswer,
                      originalResult.gradingCriteria,
                      { ...DEFAULT_SETTINGS, ...settings } // ì›Œì»¤ ìŠ¤ì½”í”„ì˜ settings ì‚¬ìš©
                  );
                  
                  // 0.0 ~ 1.0 ì‚¬ì´ì˜ ì ìˆ˜ë¥¼ ì‹¤ì œ ë°°ì (maxPoints)ì— ë§ì¶° ë³€í™˜
                  const questionScore = (gradeData.score || 0) * originalResult.maxPoints;
                  newScore += questionScore;
                  
                  return {
                      ...originalResult,
                      isCorrect: gradeData.score >= 0.8, // 80% ì´ìƒì´ë©´ 'ì •ë‹µ' ì•„ì´ì½˜ í‘œì‹œ
                      score_0_1: gradeData.score,
                      points: questionScore, // íšë“ ì ìˆ˜
                      feedback: gradeData.feedback
                  };
              } catch (error) {
                  console.error("AI ê°œë³„ ì±„ì  ì˜¤ë¥˜ (Worker):", error);
                  return {
                      ...originalResult,
                      isCorrect: false, // ì˜¤ë¥˜ ì‹œ ì˜¤ë‹µ
                      score_0_1: 0.0,
                      points: 0,
                      feedback: \`AI ì±„ì  ì‹¤íŒ¨: \${error.message}\`
                  };
              }
          });

          const newResults = await Promise.all(gradingPromises);
          
          const updatedAttempt = {
              ...attempt,
              score: newScore, // ğŸ“Œ 100ì  ë§Œì ìœ¼ë¡œ í™˜ì‚°ëœ ìµœì¢… ì ìˆ˜
              answers: JSON.stringify(newResults)
          };
          
          return updatedAttempt;
      };

      /* ğŸ“Œ 4. ë©”ì¸ ì›Œì»¤ í•¸ë“¤ëŸ¬ (ìˆ˜ì •) ğŸ“Œ */
      self.onmessage = async (e) => {
        const { id: taskId, taskType, sourceText, options, settings, DEFAULT_SETTINGS, attempt } = e.data;
        
        try {
          if (taskType === 'grade') {
            // --- AI ì±„ì  ì‘ì—… ---
            const updatedAttempt = await handleAsyncGrading(attempt, settings, DEFAULT_SETTINGS);
            self.postMessage({ 
                status: 'success', 
                taskId, 
                taskType, 
                updatedAttempt, // ì±„ì  ì™„ë£Œëœ attempt ê°ì²´
                options: { quizTitle: attempt.quizTitle } // ì‘ì—… ëª¨ë‹ˆí„° í‘œì‹œìš©
            });
            
          } else {
            // --- AI í€´ì¦ˆ ìƒì„± ì‘ì—… (ê¸°ì¡´) ---
            const quizData = await generateQuizWithAi(sourceText, options, { ...DEFAULT_SETTINGS, ...settings });
            self.postMessage({ 
                status: 'success', 
                taskId, 
                taskType, 
                quizData, 
                options: e.data.options 
            });
          }
        } catch (error) {
          self.postMessage({ status: 'error', taskId, taskType, error: error.message });
        }
      };
    `;
    const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
    const workerUrl = URL.createObjectURL(workerBlob);
    
    
    // --- 3. ê¸°ë³¸ ì„¤ì • ë° í›… (v6 - í”„ë¡¬í”„íŠ¸ ìˆ˜ì •) ---

    // ğŸ“Œ (ìˆ˜ì • 6) ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ (ë¶€ë¶„ ì ìˆ˜ ë° ì¡°ì–¸)
    const DEFAULT_SETTINGS = {
        apiKeys: [{ key: "", rpm: 60 }],
        defaultDifficulty: "Medium",
        defaultQuestionType: "MultipleChoice",
        defaultNumQuestions: 10,
        quizSystemPrompt: `You are an expert quiz generation AI. You must generate a {{NUM_QUESTIONS}}-question quiz based *only* on the provided source text.
- Difficulty: {{DIFFICULTY}}
- Requested Question Type: {{QUESTION_TYPE}}
- Adhere strictly to the provided JSON schema.
- You MUST set 'questionType' for each question (e.g., "MultipleChoice" or "ShortAnswer", "Essay" etc.).
- For "MultipleChoice" questions, provide 'options' (array) and 'correctAnswerIndex' (number).
- ğŸ“Œ (ìˆ˜ì •) For subjective questions (like "ShortAnswer", "Essay", "CaseStudy"), DO NOT provide 'correctAnswerIndex' or 'options'.
- ğŸ“Œ (ìˆ˜ì •) Instead, for subjective questions, you MUST provide detailed 'gradingCriteria' (string). This criteria is a rubric for another AI to use for grading. (ì˜ˆ: "ì •í™•í•œ ìš©ì–´ 'TDD' ì–¸ê¸‰ ì‹œ 1ì , 'í…ŒìŠ¤íŠ¸ ìš°ì„  ì‘ì„±'ì˜ ê°œë… ì„¤ëª… ì‹œ 1ì ")
- {{INCLUDE_SNIPPETS}}
- {{PROVIDE_ANSWER_KEY}}
- {{CUSTOM_INSTRUCTIONS}}`,
        
        /* ğŸ“Œ (ìˆ˜ì •) AI ì±„ì  í”„ë¡¬í”„íŠ¸ (ë¶€ë¶„ ì ìˆ˜) ğŸ“Œ */
        gradingSystemPrompt: `You are a fair and meticulous AI teaching assistant. Your task is to grade a user's answer based *only* on the provided grading criteria (rubric).
- Evaluate the "USER'S ANSWER" strictly against the "GRADING CRITERIA".
- ğŸ“Œ You MUST return a 'score' between 0.0 (completely incorrect) and 1.0 (perfect). Partial credit (e.g., 0.5) is allowed.
- Provide concise, constructive 'feedback' in Korean, explaining *why* that specific score was given based on the criteria.
- Adhere strictly to the JSON output schema: {"score": number, "feedback": string}.`,
        
        /* ğŸ“Œ (ì‹ ê·œ) AI í•™ìŠµ ì¡°ì–¸ í”„ë¡¬í”„íŠ¸ ğŸ“Œ */
        analysisSystemPrompt: `You are a supportive and insightful AI study advisor.
- You will receive a JSON list of a student's incorrect or partially correct answers, including their answer, the grading criteria, and the feedback they received.
- Your task is to analyze these mistakes *holistically*.
- Identify common themes, misunderstandings, or knowledge gaps.
- Provide actionable, high-level study advice in Korean.
- Start with an encouraging remark.
- Use bullet points for clarity.
- Do not just repeat the feedback for each question; synthesize the results into a cohesive study plan.
- Adhere strictly to the JSON output schema: {"studyAdvice": string}.`
    };

    // (v5) IndexedDB ê¸°ë°˜ íŒŒì¼ ì‹œìŠ¤í…œ í›…
    const useFileSystem = (files, dbHelper, refetch) => {
        
        /* ğŸ“Œ (ì‹ ê·œ) ZIP/D&Dë¥¼ ìœ„í•œ í´ë” ìƒì„± í—¬í¼ ğŸ“Œ */
        const findOrCreateFolder = async (fullPath, rootParentId) => {
          let currentParentId = rootParentId;
          const folders = fullPath.split('/').filter(f => f.length > 0);
          
          for (const folderName of folders) {
            // ğŸ“Œ (ìˆ˜ì •) DB ëŒ€ì‹  ë¡œì»¬ files ìƒíƒœë¥¼ ë¨¼ì € í™•ì¸ (ì„±ëŠ¥ ìµœì í™”)
            let existingFolder = files.find(
              f => f.type === 'folder' && f.name === folderName && f.parentId === currentParentId
            );
            
            if (existingFolder) {
              currentParentId = existingFolder.id;
            } else {
              // ğŸ“Œ (ìˆ˜ì •) DBì—ë„ ì—†ìœ¼ë©´ ìƒì„±
              const allFilesDB = await dbHelper.getAll('files');
              existingFolder = allFilesDB.find(
                f => f.type === 'folder' && f.name === folderName && f.parentId === currentParentId
              );

              if (existingFolder) {
                  currentParentId = existingFolder.id;
              } else {
                  const newFolder = {
                    id: crypto.randomUUID(),
                    name: folderName,
                    type: 'folder',
                    parentId: currentParentId,
                    content: null,
                    createdAt: new Date().toISOString()
                  };
                  await dbHelper.add('files', newFolder);
                  currentParentId = newFolder.id;
                  // refetch(); // ì¦ì€ refetch ë°©ì§€. ìƒìœ„ ë¡œì§ì—ì„œ í•œ ë²ˆë§Œ í˜¸ì¶œ
              }
            }
          }
          return currentParentId; // ë§ˆì§€ë§‰ í´ë” ID ë°˜í™˜
        };

        const fileActions = useMemo(() => {
          if (!dbHelper) return {};

          const recursiveDelete = async (parentId) => {
              const allFiles = await dbHelper.getAll('files');
              const children = allFiles.filter(f => f.parentId === parentId);
              for (const child of children) {
                  if (child.type === 'folder') {
                      await recursiveDelete(child.id); // ìì‹ í´ë” ì¬ê·€ ì‚­ì œ
                  }
                  await dbHelper.delete('files', child.id); // íŒŒì¼ ë˜ëŠ” ë¹ˆ í´ë” ì‚­ì œ
              }
          };
          
          // (v5) DnD ì´ë™ ë¡œì§
          const move = async (fileId, newParentId) => {
              if (fileId === newParentId) return; // ìì‹ ì—ê²Œ ë“œë¡­ ë°©ì§€
              
              const file = await dbHelper.get('files', fileId);
              if(file && file.parentId !== newParentId) { 
                  await dbHelper.put('files', { ...file, parentId: newParentId });
                  refetch();
              }
          };

          return {
            create: async (parentId, type, name, content = '') => {
              const docName = name || (type === 'folder' ? 'New Folder' : 'new-file.txt');
              const newFile = {
                id: crypto.randomUUID(),
                name: docName,
                type,
                parentId,
                content: type === 'file' ? content : null,
                createdAt: new Date().toISOString()
              };
              await dbHelper.add('files', newFile);
              // refetch(); // ğŸ“Œ (ìˆ˜ì •) ì¦ì€ refetch ë°©ì§€. ìƒìœ„ ë¡œì§(handleFileDrop)ì—ì„œ ì¼ê´„ í˜¸ì¶œ
              return newFile; // ğŸ“Œ (ìˆ˜ì •) ìƒì„±ëœ ê°ì²´ ë°˜í™˜
            },
            rename: async (fileId, newName) => {
              const file = await dbHelper.get('files', fileId);
              if(file) await dbHelper.put('files', { ...file, name: newName });
              refetch();
            },
            remove: async (fileId, type) => {
              if (type === 'folder') {
                  await recursiveDelete(fileId); // í•˜ìœ„ í•­ëª© ëª¨ë‘ ì‚­ì œ
              }
              await dbHelper.delete('files', fileId); // ë³¸ì¸ ì‚­ì œ
              refetch();
            },
            updateContent: async (fileId, newContent) => {
              const file = await dbHelper.get('files', fileId);
              if(file) await dbHelper.put('files', { ...file, content: newContent });
              refetch(); // ğŸ“Œ (ìˆ˜ì • 2) refetch() ì¶”ê°€
            },
            move: move, // (v5)
            findOrCreateFolder // ğŸ“Œ (ì‹ ê·œ) í—¬í¼ ë…¸ì¶œ
          };
        }, [dbHelper, refetch, files]); // ğŸ“Œ files ì˜ì¡´ì„± ì¶”ê°€

        // í”Œë« ë¦¬ìŠ¤íŠ¸ë¥¼ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ ë³€í™˜
        const fileTree = useMemo(() => {
          const map = {};
          const roots = [];
          files.forEach(file => {
            map[file.id] = { ...file, children: [] };
          });
          Object.values(map).forEach(node => {
            if (node.parentId === 'root') {
              roots.push(node);
            } else if (map[node.parentId]) {
              map[node.parentId].children.push(node);
            }
          });
          return roots;
        }, [files]);

        return { fileTree, fileActions };
    };
    
    // Debounce í›…
    const useDebounce = (value, delay) => {
        const [debouncedValue, setDebouncedValue] = useState(value);
        useEffect(() => {
            const handler = setTimeout(() => { setDebouncedValue(value); }, delay);
            return () => clearTimeout(handler);
        }, [value, delay]);
        return debouncedValue;
    };


    // --- 4. UI ì»´í¬ë„ŒíŠ¸ ---
    
    /* ğŸ“Œ ì‹ ê·œ: í† ìŠ¤íŠ¸ ì‹œìŠ¤í…œ ğŸ“Œ */
    const ToastProvider = ({ children }) => {
        const [toasts, setToasts] = useState([]);

        const show = useCallback((message, type = 'info') => {
            const id = crypto.randomUUID();
            setToasts(prev => [...prev, { id, message, type }]);
            setTimeout(() => {
                setToasts(prev => prev.filter(t => t.id !== id));
            }, 3000);
        }, []);

        const value = useMemo(() => ({ show }), [show]);

        return e(ToastContext.Provider, { value },
            children,
            e(ToastContainer, { toasts })
        );
    };

    const ToastContainer = ({ toasts }) => {
        return e('div', { className: 'toast-container' },
            toasts.map(toast => e('div', { 
                key: toast.id, 
                className: `toast-item ${toast.type}` 
            }, toast.message))
        );
    };


    const Spinner = () => e(
      'div', { className: 'spinner-overlay' },
      e('div', { className: 'spinner' })
    );

    // ì…¸: VSCode ì‚¬ì´ë“œë°”
    const ReactVscodeSidebar = ({ items = [], onActiveChange, activeId, isVisible, children }) => {
      const activityBarTop = e('div', null,
        items.filter(item => !item.isBottom).map((item) => e('button', {
          key: item.id, className: 'vsc-activity-item',
          onClick: () => onActiveChange(item.id),
          'data-active': isVisible && item.id === activeId, 'aria-label': item.label
        }, item.icon))
      );
      const activityBarBottom = e('div', null,
        items.filter(item => item.isBottom).map((item) => e('button', {
          key: item.id, className: 'vsc-activity-item',
          onClick: () => onActiveChange(item.id),
          'data-active': isVisible && item.id === activeId, 'aria-label': item.label
        }, item.icon))
      );
      const activeView = React.Children.toArray(children).find(
        (child) => child.props.viewId === activeId
      );
      const sidebarView = e('div', { 
          className: 'vsc-sidebar-view',
          'data-visible': isVisible
        },
        isVisible && activeView ? e('div', { className: 'vsc-view-content', key: activeId }, activeView) : null
      );
      return e('div', { className: 'vsc-sidebar-container' }, 
        e('div', { className: 'vsc-activity-bar' }, activityBarTop, activityBarBottom), 
        sidebarView
      );
    };
    
    // (v4.1) ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì»´í¬ë„ŒíŠ¸
    const ContextMenu = ({ menuData, handlers, onClose }) => {
        if (!menuData.visible) return null;
        const { node } = menuData;
        const isFolder = node?.type === 'folder';
        const isRoot = !node;

        const handleAction = (action) => {
            onClose();
            action();
        };

        const MenuItem = ({ label, onClick, disabled = false, isDelete = false }) => e(
            'li', {
                className: `context-menu-item ${isDelete ? 'context-menu-item-delete' : ''}`,
                onClick: (e) => { e.stopPropagation(); if (!disabled) handleAction(onClick); }
            }, label
        );

        return e('div', {
            className: 'context-menu',
            style: { top: menuData.y, left: menuData.x },
            onClick: (e) => e.stopPropagation()
        },
            e('ul', { className: 'py-1' },
                !isRoot && e(React.Fragment, null,
                    e(MenuItem, { label: 'ì´ë¦„ ë°”ê¾¸ê¸°', onClick: handlers.onRename }),
                    e(MenuItem, { label: 'ì‚­ì œ', onClick: handlers.onDelete, isDelete: true }),
                    e('hr', { className: 'context-menu-divider' })
                ),
                (isRoot || isFolder) && e(React.Fragment, null,
                    e(MenuItem, { label: 'ìƒˆ íŒŒì¼', onClick: handlers.onCreateFile }),
                    e(MenuItem, { label: 'ìƒˆ í´ë”', onClick: handlers.onCreateFolder })
                )
            )
        );
    };

    // ë·° 1: íŒŒì¼ ê´€ë¦¬ì (v5 - 2ë¶„í•  ë·°, DnD)
    const FileManagerView = ({ viewId }) => {
        // ğŸ“Œ (ìˆ˜ì • 7-1) AI ì±„ì  ì˜ì¡´ì„± ì£¼ì…
        const { 
            files, fileTree, fileActions, setActiveEditorFile, activeEditorFile,
            dbHelper, refetchAllData, setEditingNodeId,
            quizzes, attempts, setModalContent, // (v5)
            handleQuizSubmit,
            userSettings, // ğŸ“Œ ì‹ ê·œ
            dispatchGradingTask, // ğŸ“Œ ì‹ ê·œ
            initiateFileReads, // ğŸ“Œ (íŒ¨ì¹˜)
            processReadsAndStore // ğŸ“Œ (íŒ¨ì¹˜)
        } = useContext(AppContext);
        
        const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, node: null });
        
        // (v5) íŒŒì¼ ê´€ë ¨ í€´ì¦ˆ/ê¸°ë¡ í•„í„°ë§
        const fileQuizzes = useMemo(() => 
            activeEditorFile ? quizzes.filter(q => q.fileId === activeEditorFile.id) : [],
        [quizzes, activeEditorFile]);
        
        const fileAttempts = useMemo(() =>
            activeEditorFile ? attempts.filter(a => a.fileId === activeEditorFile.id) : [],
        [attempts, activeEditorFile]);
        
        
        // ğŸ“Œ (ìˆ˜ì •) íŒŒì¼ Input í•¸ë“¤ëŸ¬
        const handleImportProject = useCallback((event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                if (!window.confirm("í˜„ì¬ í”„ë¡œì íŠ¸ë¥¼ ë®ì–´ì“°ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
                try {
                    const data = JSON.parse(e.target.result);
                    await dbHelper.clear('files');
                    await dbHelper.clear('quizzes');
                    await dbHelper.clear('quizAttempts');
                    
                    for (const file of data.files || []) await dbHelper.put('files', file);
                    for (const quiz of data.quizzes || []) await dbHelper.put('quizzes', quiz);
                    for (const attempt of data.attempts || []) await dbHelper.put('attempts', attempt);
                    if (data.settings) await dbHelper.put('settings', data.settings);
                    
                    refetchAllData(); // ì „ì²´ ë°ì´í„° ìƒˆë¡œê³ ì¹¨
                } catch (err) {
                    console.error("Import failed:", err);
                    alert("ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: " + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = null; // ì¸í’‹ ì´ˆê¸°í™”
        }, [dbHelper, refetchAllData]);

        // ğŸ“Œ (íŒ¨ì¹˜ 6) useEffect (íŒŒì¼ ì—…ë¡œë“œ) ìˆ˜ì •
        useEffect(() => {
            const handleClick = () => setContextMenu({ visible: false });
            window.addEventListener('click', handleClick);
            
            const fileUploadInput = document.getElementById('file-upload-input');
            const projectImportInput = document.getElementById('project-import-input');
            
            // ğŸ“Œ (ìˆ˜ì •) íŒŒì¼ Input í•¸ë“¤ëŸ¬
            const handleFileUploadEvent = (event) => {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ì˜ parentId ê³„ì‚° ë¡œì§ í™œìš©
                const { node } = contextMenu; // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ê°€ ì—´ë ¤ìˆì—ˆë‹¤ë©´ ê·¸ ìœ„ì¹˜
                const parentId = (node && node.type === 'folder') ? node.id : (node ? node.parentId : 'root');
                
                // ğŸ“Œ (íŒ¨ì¹˜) 1. ë™ê¸°ì  ì½ê¸° ì‹œì‘
                const pendingReads = initiateFileReads(files);
                // ğŸ“Œ (íŒ¨ì¹˜) 2. ë¹„ë™ê¸° ì²˜ë¦¬ ìœ„ì„
                processReadsAndStore(pendingReads, parentId);
                
                event.target.value = null; // ì¸í’‹ ì´ˆê¸°í™”
            };

            fileUploadInput.addEventListener('change', handleFileUploadEvent);
            projectImportInput.addEventListener('change', handleImportProject);

            return () => {
                window.removeEventListener('click', handleClick);
                fileUploadInput.removeEventListener('change', handleFileUploadEvent);
                projectImportInput.removeEventListener('change', handleImportProject);
            };
        }, [contextMenu, initiateFileReads, processReadsAndStore, handleImportProject]); // ğŸ“Œ (íŒ¨ì¹˜) ì˜ì¡´ì„± ë°°ì—´ ìˆ˜ì •
        
        const handleContextMenu = (e, node) => {
            e.preventDefault();
            e.stopPropagation();
            setContextMenu({ visible: true, x: e.clientX, y: e.clientY, node: node });
        };
        
        const handleExportProject = async () => {
            const data = {
                files: await dbHelper.getAll('files'),
                quizzes: await dbHelper.getAll('quizzes'),
                attempts: await dbHelper.getAll('quizAttempts'),
                settings: await dbHelper.get('settings', 'userConfig')
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai-quiz-app-export.json';
            a.click();
            URL.revokeObjectURL(url);
        };
        
        // (v5) FileNode ìˆ˜ì • (DnD)
        const FileNode = ({ node, depth, onContextMenu }) => {
            // ğŸ“Œ (íŒ¨ì¹˜ 7) useContext ë³€ê²½
            const { activeEditorFile, editingNodeId, setEditingNodeId, fileActions, initiateFileReads, processReadsAndStore } = useContext(AppContext);
            
            const [isOpen, setIsOpen] = useState(true);
            const [editName, setEditName] = useState(node.name);
            const [isDragOver, setIsDragOver] = useState(false); // (v5)
            
            const isEditing = editingNodeId === node.id;
            
            useEffect(() => {
                if (isEditing) setEditName(node.name);
            }, [isEditing, node.name]);
            
            const handleToggle = (e) => {
                e.stopPropagation();
                if (node.type === 'folder') setIsOpen(!isOpen);
                else setActiveEditorFile(files.find(f => f.id === node.id));
            };
            
            const handleRenameSubmit = (e) => {
                e.stopPropagation(); e.preventDefault();
                if (editName.trim() && editName.trim() !== node.name) {
                    fileActions.rename(node.id, editName.trim());
                }
                setEditingNodeId(null);
            };
            
            // ğŸ“Œ (ìˆ˜ì •) D&D í•¸ë“¤ëŸ¬
            const handleDragStart = (e) => {
                e.stopPropagation();
                e.dataTransfer.setData('fileId', node.id);
                e.dataTransfer.effectAllowed = 'move';
            };
            const handleDragOver = (e) => {
                e.preventDefault(); e.stopPropagation();
                setIsDragOver(true);
                e.dataTransfer.dropEffect = 'move';
            };
            const handleDragLeave = (e) => {
                e.preventDefault(); e.stopPropagation();
                setIsDragOver(false);
            };
            // ğŸ“Œ (íŒ¨ì¹˜ 7) handleDrop ìˆ˜ì •
            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation(); // ğŸ“Œ ì¤‘ìš”: windowì˜ drop í•¸ë“¤ëŸ¬ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
                setIsDragOver(false);
                
                const targetFolderId = (node.type === 'folder') ? node.id : node.parentId;
                
                const fileId = e.dataTransfer.getData('fileId');
                if (fileId) {
                    // 1. ë‚´ë¶€ íŒŒì¼/í´ë” ì´ë™
                    if (fileId !== node.id) {
                        fileActions.move(fileId, targetFolderId);
                    }
                } else if (e.dataTransfer.files.length > 0) {
                    // 2. ğŸ“Œ (ìˆ˜ì •) ì™¸ë¶€ íŒŒì¼ ë“œë¡­
                    // ğŸ“Œ (íŒ¨ì¹˜) 1. ë™ê¸°ì  ì½ê¸° ì‹œì‘
                    const pendingReads = initiateFileReads(e.dataTransfer.files);
                    // ğŸ“Œ (íŒ¨ì¹˜) 2. ë¹„ë™ê¸° ì²˜ë¦¬ ìœ„ì„
                    processReadsAndStore(pendingReads, targetFolderId);
                }
            };

            return e(React.Fragment, null,
                e('div', { 
                    className: 'file-tree-node',
                    style: { paddingLeft: `${depth * 16 + 8}px` },
                    onClick: handleToggle,
                    onContextMenu: (e) => onContextMenu(e, node),
                    'data-active': activeEditorFile?.id === node.id,
                    draggable: true, 
                    onDragStart: handleDragStart,
                    onDragOver: handleDragOver,
                    onDragLeave: handleDragLeave,
                    onDrop: handleDrop, // ğŸ“Œ ìˆ˜ì •ëœ í•¸ë“¤ëŸ¬
                    'data-drag-over': isDragOver,
                    'data-type': node.type // ğŸ“Œ (ì‹ ê·œ) ë“œë¡­ íƒ€ê²Ÿ ì‹ë³„ìš©
                  },
                  e('span', { className: 'file-tree-node-icon' }, 
                    node.type === 'folder' ? (isOpen ? 'â–¼' : 'â–º') : 'ğŸ“„'
                  ),
                  isEditing
                    ? e('form', { onSubmit: handleRenameSubmit, className: 'flex-1 ml-1' },
                        e('input', {
                            key: node.id, type: 'text', value: editName,
                            onChange: (ev) => setEditName(ev.target.value),
                            onBlur: handleRenameSubmit,
                            onClick: (e) => e.stopPropagation(), autoFocus: true,
                            className: 'form-input !p-0 !text-sm'
                        })
                      )
                    : e('span', { className: 'ml-1' }, node.name)
                ),
                isOpen && node.children && node.children.map(child => 
                    e(FileNode, { 
                        key: child.id, 
                        node: child, 
                        depth: depth + 1, 
                        onContextMenu: onContextMenu
                    })
                )
            );
        };
        
        const contextMenuHandlers = useMemo(() => {
            const { node } = contextMenu;
            const parentId = (node && node.type === 'folder') ? node.id : (node ? node.parentId : 'root');
            return {
                onRename: () => { if (node) setEditingNodeId(node.id); },
                onDelete: () => {
                    if (node && window.confirm(`'${node.name}'ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                        fileActions.remove(node.id, node.type);
                        if (activeEditorFile?.id === node.id) setActiveEditorFile(null); // (v5) ì—´ë¦° íŒŒì¼ ì‚­ì œ ì‹œ ë‹«ê¸°
                    }
                },
                onCreateFile: () => fileActions.create(parentId, 'file'),
                onCreateFolder: () => fileActions.create(parentId, 'folder'),
            };
        }, [contextMenu, fileActions, setEditingNodeId, activeEditorFile]);
        
        return e('div', { 
            viewId, 
            className: 'flex flex-col h-full vsc-view-panes', // (v5) 2ë¶„í•  ë·°
            onContextMenu: (e) => handleContextMenu(e, null)
           },
            // (v5) ìƒë‹¨: íŒŒì¼ íŠ¸ë¦¬
            e('div', { className: 'vsc-view-pane' },
                e('div', { className: 'view-header' },
                    e('h3', { className: 'border-b-0 p-0 m-0' }, 'íŒŒì¼ íƒìƒ‰ê¸°'),
                    e('div', { className: 'flex gap-1' },
                        e('button', { title: "ìƒˆ í´ë”", className: 'view-header-icon', onClick: () => fileActions.create('root', 'folder') }, 'ğŸ“+'),
                        e('button', { title: "íŒŒì¼ ì—…ë¡œë“œ", className: 'view-header-icon', onClick: () => document.getElementById('file-upload-input').click() }, 'â¬†ï¸'),
                        e('button', { title: "ë‚´ë³´ë‚´ê¸°", className: 'view-header-icon', onClick: handleExportProject }, 'ğŸ’¾'),
                        e('button', { title: "ê°€ì ¸ì˜¤ê¸°", className: 'view-header-icon', onClick: () => document.getElementById('project-import-input').click() }, 'ğŸ“¥')
                    )
                ),
                e('div', { className: 'vsc-view-pane-content full' }, 
                    e('div', { className: 'file-tree-list' },
                        fileTree.map(node => e(FileNode, { 
                            key: node.id, 
                            node: node, 
                            depth: 0, 
                            onContextMenu: handleContextMenu
                        }))
                    )
                )
            ),
            
            // (v5) í•˜ë‹¨: íŒŒì¼ ìƒì„¸ (í€´ì¦ˆ/ê¸°ë¡)
            activeEditorFile && e('div', { className: 'vsc-view-pane' },
                e('div', { className: 'vsc-view-pane-header' }, 
                    `íŒŒì¼ ìƒì„¸: ${activeEditorFile.name}`
                ),
                e('div', { className: 'vsc-view-pane-content' },
                    e('h4', { className: 'text-md font-semibold mt-0 mb-2' }, 'ìƒì„±ëœ í€´ì¦ˆ'),
                    fileQuizzes.length === 0 && e('p', { className: 'text-sm text-gray-400' }, 'ì´ íŒŒì¼ë¡œ ìƒì„±ëœ í€´ì¦ˆê°€ ì—†ìŠµë‹ˆë‹¤.'),
                    fileQuizzes.map(quiz => e('div', { 
                        key: quiz.id, className: 'list-item',
                        onClick: () => setModalContent(e(QuizTaker, { 
                            quiz, 
                            onClose: () => setModalContent(null),
                            onQuizSubmit: handleQuizSubmit // ğŸ“Œ (ìˆ˜ì • 7) onQuizSubmit ì „ë‹¬
                        }))
                    }, e('div', { className: 'list-item-title' }, quiz.title))),
                    
                    e('h4', { className: 'text-md font-semibold mt-4 mb-2' }, 'í’€ì´ ê¸°ë¡'),
                    fileAttempts.length === 0 && e('p', { className: 'text-sm text-gray-400' }, 'ì´ íŒŒì¼ì˜ í€´ì¦ˆ í’€ì´ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.'),
                    fileAttempts.map(attempt => e('div', { 
                        key: attempt.id, className: 'list-item',
                        // ğŸ“Œ (ìˆ˜ì • 7-2) AI ì±„ì  ì˜ì¡´ì„± ì£¼ì…
                        onClick: () => setModalContent(e(QuizResult, { 
                            attempt, 
                            quiz: quizzes.find(q => q.id === attempt.quizId), 
                            onClose: () => setModalContent(null),
                            userSettings,
                            dbHelper,
                            refetchAllData,
                            dispatchGradingTask // ğŸ“Œ ì‹ ê·œ
                        }))
                    }, e('div', { className: 'list-item-title' }, `${attempt.quizTitle} (${attempt.score.toFixed(1)} / ${attempt.total})`))) // ğŸ“Œ (ìˆ˜ì •) 100ì  ë§Œì 
                )
            ),
            
            e(ContextMenu, {
                menuData: contextMenu,
                onClose: () => setContextMenu({ visible: false }),
                handlers: contextMenuHandlers
            })
        );
    };

    // ë·° 2: í€´ì¦ˆ ìƒì„±ê¸° (v5 - ì›ë¬¸ ì œê±°)
    const QuizGeneratorView = ({ viewId }) => {
      // (v5) í€´ì¦ˆ ì˜µì…˜ ìƒíƒœë¥¼ Contextì—ì„œ ê°€ì ¸ì˜´
      const { quizOptions, setQuizOptions } = useContext(AppContext);

      const handleSubmit = (e) => { e.preventDefault(); };
      
      const questionTypes = [
          "MultipleChoice", "ShortAnswer", "TrueFalse", "FillInTheBlank",
          "Essay", "CaseStudy", "Matching", "Sequencing", "CodeSnippet"
      ];

      return e('form', { viewId, onSubmit: handleSubmit, className: 'flex flex-col h-full' },
        e('h3', { className: 'view-header' }, 'í€´ì¦ˆ ì˜µì…˜'),
        e('div', { className: 'view-content-scroll' },
          // (v5) ì›ë¬¸ textarea ì œê±°ë¨
          e('div', { className: 'grid grid-cols-2 gap-4' },
            e('div', { className: 'form-group' },
              e('label', { htmlFor: 'num-questions', className: 'form-label' }, 'ì§ˆë¬¸ ìˆ˜'),
              e('input', {
                id: 'num-questions', type: 'number', className: 'form-input',
                value: quizOptions.numQuestions, 
                onChange: (ev) => setQuizOptions(o => ({...o, numQuestions: parseInt(ev.target.value, 10)}))
              })
            ),
            e('div', { className: 'form-group' },
              e('label', { htmlFor: 'difficulty', className: 'form-label' }, 'ë‚œì´ë„'),
              e('select', { 
                  id: 'difficulty', className: 'form-select',
                  value: quizOptions.difficulty, 
                  onChange: (ev) => setQuizOptions(o => ({...o, difficulty: ev.target.value}))
                },
                e('option', { value: 'Easy' }, 'ì‰¬ì›€'),
                e('option', { value: 'Medium' }, 'ë³´í†µ'),
                e('option', { value: 'Hard' }, 'ì–´ë ¤ì›€')
              )
            )
          ),
          e('div', { className: 'form-group' },
            e('label', { htmlFor: 'question-type', className: 'form-label' }, 'ì§ˆë¬¸ ìœ í˜•'),
            e('select', {
                id: 'question-type', className: 'form-select',
                value: quizOptions.questionType, 
                onChange: (ev) => setQuizOptions(o => ({...o, questionType: ev.target.value}))
              },
              questionTypes.map(type => e('option', { key: type, value: type }, type))
            )
          ),
          e('div', { className: 'form-group' },
            e('label', { className: 'form-label' }, 'ì¶”ê°€ ì§€ì¹¨ (ì„ íƒ ì‚¬í•­)'),
            e('input', {
              type: 'text', className: 'form-input',
              value: quizOptions.customInstructions, 
              onChange: (ev) => setQuizOptions(o => ({...o, customInstructions: ev.target.value})),
              placeholder: 'ì˜ˆ: ì½”ë“œ ì˜ˆì œì— ì§‘ì¤‘í•˜ì„¸ìš”'
            })
          ),
          e('div', { className: 'form-group space-y-2' },
            e('label', { className: 'form-checkbox-label' },
              e('input', {
                type: 'checkbox', className: 'form-checkbox',
                checked: quizOptions.includeSnippets, 
                onChange: (ev) => setQuizOptions(o => ({...o, includeSnippets: ev.target.checked}))
              }),
              'ì½”ë“œ ìŠ¤ë‹ˆí« í¬í•¨ (Include Code Snippets)'
            ),
            e('label', { className: 'form-checkbox-label' },
              e('input', {
                type: 'checkbox', className: 'form-checkbox',
                checked: quizOptions.provideAnswerKey, 
                onChange: (ev) => setQuizOptions(o => ({...o, provideAnswerKey: ev.target.checked}))
              }),
              'ì •ë‹µ í‚¤ ì œê³µ (Provide Answer Key)'
            )
          )
        )
        // (v5) ìƒì„± ë²„íŠ¼ ì œê±°ë¨
      );
    };
    
    // ë·° 3: í€´ì¦ˆ ê¸°ë¡ (v5 - ê¸€ë¡œë²Œ í’€ì´ ê¸°ë¡ë§Œ)
    const QuizHistoryView = ({ viewId }) => {
      // ğŸ“Œ (ìˆ˜ì • 8) AI ì±„ì  ì˜ì¡´ì„± ì£¼ì…
      const { quizzes, attempts, setModalContent, userSettings, dbHelper, refetchAllData, dispatchGradingTask } = useContext(AppContext);
      
      const showAttemptResult = (attempt) => {
          setModalContent(e(QuizResult, { 
              attempt, 
              quiz: quizzes.find(q => q.id === attempt.quizId),
              onClose: () => setModalContent(null),
              /* ğŸ“Œ ì‹ ê·œ: ì˜ì¡´ì„± ì£¼ì… ğŸ“Œ */
              userSettings,
              dbHelper,
              refetchAllData,
              dispatchGradingTask // ğŸ“Œ ì‹ ê·œ
          }));
      };
      
      return e('div', { viewId, className: 'flex flex-col h-full' },
        e('h3', { className: 'view-header' }, 'ì „ì²´ í’€ì´ ê¸°ë¡'),
        e('div', { className: 'view-content-scroll' },
          attempts.length === 0 && e('p', { className: 'text-sm text-gray-400' }, 'í’€ì´ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.'),
          attempts.map(attempt => e('div', { 
              key: attempt.id, 
              className: 'list-item',
              onClick: () => showAttemptResult(attempt)
            },
            e('div', { className: 'list-item-title' }, attempt.quizTitle),
            e('div', { className: 'flex justify-between' },
                e('span', { className: 'list-item-sub' }, `ì ìˆ˜: ${attempt.score.toFixed(1)} / ${attempt.total}`), // ğŸ“Œ (ìˆ˜ì •) 100ì  ë§Œì 
                e('span', { className: 'list-item-sub' }, 
                    new Date(attempt.completedAt).toLocaleDateString()
                )
            )
          ))
          // (v5) ìƒì„±ëœ í€´ì¦ˆ ëª©ë¡ ì œê±°ë¨
        )
      );
    };
    
    // ë·° 4: ì‘ì—… ëª¨ë‹ˆí„° (v3)
    const TaskMonitorView = ({ viewId }) => {
        const { taskQueue } = useContext(AppContext);
        
        return e('div', { viewId, className: 'flex flex-col h-full' },
            e('h3', { className: 'view-header' }, 'ì‘ì—… ëª¨ë‹ˆí„°'),
            e('div', { className: 'view-content-scroll' },
                taskQueue.length === 0 && e('p', { className: 'text-sm text-gray-400' }, 'í™œì„± ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.'),
                taskQueue.map(task => e('div', { key: task.id, className: 'list-item' },
                    e('div', { className: 'list-item-title' }, 
                      // ğŸ“Œ (ìˆ˜ì •) ì‘ì—… ìœ í˜•ì— ë”°ë¼ ì œëª© ë¶„ê¸°
                      task.taskType === 'grade' 
                        ? `[ì±„ì ] ${task.options.quizTitle}` 
                        : `[ìƒì„±] ${task.options.sourceFileName}`
                    ),
                    e('div', { className: 'flex justify-between items-center' },
                        e('span', { className: 'list-item-sub' }, 
                          task.taskType === 'grade'
                            ? `í€´ì¦ˆ ì±„ì  ì‘ì—…`
                            : `ìœ í˜•: ${task.options.questionType} (${task.options.numQuestions} ë¬¸ì œ)`
                        ),
                        task.status === 'processing' && e('span', { className: 'list-item-badge' }, 'ì²˜ë¦¬ ì¤‘...'),
                        task.status === 'success' && e('span', { className: 'list-item-badge success' }, 'ì™„ë£Œ'),
                        task.status === 'error' && e('span', { className: 'list-item-badge error' }, 'ì˜¤ë¥˜')
                    )
                ))
            )
        );
    };

    // ë·° 5: ë©”ì¸ ì»¨í…ì¸  ì—ë””í„° (v5 - í—¤ë” ì¶”ê°€)
    // ğŸ“Œ (ìˆ˜ì • 3) MainContentEditor ì „ì²´ ìˆ˜ì •
    const MainContentEditor = () => {
        const { 
            activeEditorFile, fileActions, 
            dispatchTask, quizOptions // (v5)
        } = useContext(AppContext);
        const [content, setContent] = useState("");
        const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'editing', 'saving'
        
        // íŒŒì¼ ë³€ê²½ ì‹œ, contentì™€ saveStatusë¥¼ ë¦¬ì…‹
        useEffect(() => {
            setContent(activeEditorFile?.content || "");
            setSaveStatus('saved'); // ìƒˆ íŒŒì¼ì€ 'ì €ì¥ë¨' ìƒíƒœë¡œ ì‹œì‘
        }, [activeEditorFile]);
        
        const debouncedContent = useDebounce(content, 1000);
        
        // ë””ë°”ìš´ìŠ¤ ì €ì¥ ë¡œì§ì— ìƒíƒœ ë³€ê²½ ì¶”ê°€
        useEffect(() => {
            if (activeEditorFile && debouncedContent !== activeEditorFile.content) {
                setSaveStatus('saving'); // ì €ì¥ ì‹œì‘
                fileActions.updateContent(activeEditorFile.id, debouncedContent)
                    .then(() => {
                        // fileActions.updateContentê°€ refetchë¥¼ íŠ¸ë¦¬ê±°í•˜ë¯€ë¡œ,
                        // ì´ .then()ì€ refetch ì´í›„ ì‹¤í–‰ë  else if ë¸”ë¡ê³¼
                        // ì¤‘ë³µë˜ê±°ë‚˜ ë ˆì´ìŠ¤ ì»¨ë””ì…˜ì„ ì¼ìœ¼í‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                        // (ìˆ˜ì • 2)ë¡œ ì¸í•´ ì´ .then()ì€ ì‚¬ì‹¤ìƒ ì¦‰ì‹œ 'saved'ë¥¼ í˜¸ì¶œí•˜ê²Œ ë¨
                        setSaveStatus('saved'); // ì €ì¥ ì™„ë£Œ
                    });
            } else if (saveStatus === 'editing' && activeEditorFile && debouncedContent === activeEditorFile.content) {
                // ì‚¬ìš©ìê°€ ì…ë ¥ì„ ë©ˆì·„ìœ¼ë‚˜ ë³€ê²½ ì‚¬í•­ì´ ì—†ëŠ” ê²½ìš° (ì˜ˆ: ì¼ë‹¤ ì§€ì›€)
                setSaveStatus('saved');
            } else if (activeEditorFile && debouncedContent === activeEditorFile.content) {
                // refetch ì´í›„ ì´ ì¡°ê±´ì´ trueê°€ ë˜ì–´ ìƒíƒœë¥¼ 'saved'ë¡œ ëŒë¦¼
                setSaveStatus('saved');
            }
        }, [debouncedContent, activeEditorFile, fileActions]); // ğŸ“Œ saveStatus ì˜ì¡´ì„± ì œê±°

        // í€´ì¦ˆ ìƒì„± í•¸ë“¤ëŸ¬ (ìš”êµ¬ì‚¬í•­ 2)
        const handleGenerateQuiz = () => {
            if (!activeEditorFile) return;
            if (!content.trim()) { // âœ¨ ìˆ˜ì •: ë¡œì»¬ 'content' ìƒíƒœ ì‚¬ìš©
                alert("íŒŒì¼ì— ì›ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }
            dispatchTask({
                taskType: 'generate', // ğŸ“Œ (ì‹ ê·œ) ì‘ì—… ìœ í˜• ëª…ì‹œ
                sourceText: content, // âœ¨ ìˆ˜ì •: ë¡œì»¬ 'content' ìƒíƒœ ì‚¬ìš©
                options: {
                    ...quizOptions,
                    fileId: activeEditorFile.id,
                    sourceFileName: activeEditorFile.name
                }
            });
        };
        
        // ì €ì¥ ìƒíƒœ ë©”ì‹œì§€ ë§µ
        const statusMessages = {
          'saved': 'ì €ì¥ë¨',
          'editing': 'ìˆ˜ì • ì¤‘...',
          'saving': 'ì €ì¥ ì¤‘...'
        };

        if (!activeEditorFile) {
            return e('div', { className: 'main-editor-placeholder' }, 'íŒŒì¼ íƒìƒ‰ê¸°(ğŸ“„)ì—ì„œ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.');
        }

        return e('div', { className: 'flex flex-col h-full' },
            // (v5) ì—ë””í„° í—¤ë”
            e('div', { className: 'main-editor-header' },
                e('span', { className: 'main-editor-title' }, activeEditorFile.name),
                e('button', { 
                    className: 'main-editor-action-btn',
                    onClick: handleGenerateQuiz,
                    disabled: saveStatus !== 'saved' // ì €ì¥ ì¤‘ì— ë²„íŠ¼ ë¹„í™œì„±í™” (ì„ íƒì )
                }, 'âœ¨ í€´ì¦ˆ ìƒì„±')
            ),
            // í…ìŠ¤íŠ¸ ì—ë””í„°
            e('textarea', {
                key: activeEditorFile.id,
                className: 'main-editor',
                value: content,
                // onChangeì— ìƒíƒœ ë³€ê²½ ì¶”ê°€
                onChange: (ev) => {
                    setContent(ev.target.value);
                    setSaveStatus('editing');
                }
            }),
            // ì‹ ê·œ í‘¸í„° ì¶”ê°€
            e('div', { className: 'main-editor-footer' }, statusMessages[saveStatus])
        );
    };
    
    // ë·° 6: ì„¤ì • ëª¨ë‹¬ (v4 - í”„ë¡¬í”„íŠ¸ íƒ­ ì¶”ê°€)
    const SettingsModal = ({ onClose }) => {
        const { userSettings, saveSettings } = useContext(AppContext);
        const [activeTab, setActiveTab] = useState('Quiz Defaults');
        
        // (v5) í€´ì¦ˆ ì˜µì…˜ì€ ì´ì œ ì „ì—­ ìƒíƒœì´ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì œê±°
        const [apiKeys, setApiKeys] = useState([]);
        const [newApiKey, setNewApiKey] = useState("");
        const [quizSystemPrompt, setQuizSystemPrompt] = useState("");
        const [gradingSystemPrompt, setGradingSystemPrompt] = useState(""); // ğŸ“Œ (ì‹ ê·œ)
        const [analysisSystemPrompt, setAnalysisSystemPrompt] = useState(""); // ğŸ“Œ (ì‹ ê·œ)
        const [defaultSettings, setDefaultSettings] = useState({}); // (v5)
        
        // ì„¤ì • ë¡œë“œ
        useEffect(() => {
            if (userSettings) {
                setApiKeys(userSettings.apiKeys || DEFAULT_SETTINGS.apiKeys);
                setQuizSystemPrompt(userSettings.quizSystemPrompt || DEFAULT_SETTINGS.quizSystemPrompt);
                setGradingSystemPrompt(userSettings.gradingSystemPrompt || DEFAULT_SETTINGS.gradingSystemPrompt); // ğŸ“Œ (ì‹ ê·œ)
                setAnalysisSystemPrompt(userSettings.analysisSystemPrompt || DEFAULT_SETTINGS.analysisSystemPrompt); // ğŸ“Œ (ì‹ ê·œ)
                // (v5)
                setDefaultSettings({
                    defaultDifficulty: userSettings.defaultDifficulty || DEFAULT_SETTINGS.defaultDifficulty,
                    defaultQuestionType: userSettings.defaultQuestionType || DEFAULT_SETTINGS.defaultQuestionType,
                    defaultNumQuestions: userSettings.defaultNumQuestions || DEFAULT_SETTINGS.defaultNumQuestions
                });
            }
        }, [userSettings]);
        
        const handleAddApiKey = () => {
            if (newApiKey.trim()) {
                setApiKeys([...apiKeys, { key: newApiKey.trim(), rpm: 60 }]);
                setNewApiKey("");
            }
        };
        
        const handleRemoveApiKey = (index) => {
            setApiKeys(apiKeys.filter((_, i) => i !== index));
        };
        
        const handleDefaultChange = (key, value) => {
            setDefaultSettings(prev => ({...prev, [key]: value}));
        };

        const handleSave = () => {
            saveSettings({
                ...userSettings, // ì´ì „ ì„¤ì • ìœ ì§€
                apiKeys,
                ...defaultSettings, // (v5)
                quizSystemPrompt,
                gradingSystemPrompt, // ğŸ“Œ (ì‹ ê·œ)
                analysisSystemPrompt // ğŸ“Œ (ì‹ ê·œ)
            });
            onClose();
        };

        const renderTabContent = () => {
            if (activeTab === 'API Keys') {
                return e('div', null,
                    e('h3', { className: 'text-lg font-semibold mb-4' }, 'API Configuration'),
                    e('div', { className: 'form-group' },
                        e('label', { htmlFor: 'api-key-input', className: 'form-label' }, 'New API Key'),
                        e('div', { className: 'flex gap-2' },
                            e('input', { 
                                id: 'api-key-input', type: 'password', className: 'form-input flex-grow',
                                value: newApiKey, onChange: (ev) => setNewApiKey(ev.target.value)
                            }),
                            e('button', { type: 'button', onClick: handleAddApiKey, className: 'modal-button-secondary' }, 'Add')
                        )
                    ),
                    e('div', { className: 'mt-6' },
                        e('label', { className: 'form-label' }, 'Saved Keys'),
                        apiKeys.map((key, index) => e('div', { key: index, className: 'api-key-item' },
                            e('span', { className: 'font-mono' }, `**********${key.key.slice(-4)}`),
                            e('button', { onClick: () => handleRemoveApiKey(index), className: 'api-key-delete-btn' }, 'Remove')
                        ))
                    )
                );
            }
            if (activeTab === 'Quiz Defaults') {
                return e('div', null,
                    e('h3', { className: 'text-lg font-semibold mb-4' }, 'Default Quiz Generation'),
                    e('div', { className: 'grid grid-cols-2 gap-4' },
                        e('div', { className: 'form-group' },
                            e('label', { htmlFor: 'def-difficulty', className: 'form-label' }, 'Default Difficulty'),
                            e('select', { 
                                id: 'def-difficulty', className: 'form-select',
                                value: defaultSettings.defaultDifficulty, 
                                onChange: (ev) => handleDefaultChange('defaultDifficulty', ev.target.value)
                            },
                                e('option', { value: 'Easy' }, 'ì‰¬ì›€'),
                                e('option', { value: 'Medium' }, 'ë³´í†µ'),
                                e('option', { value: 'Hard' }, 'ì–´ë ¤ì›€')
                            )
                        ),
                        e('div', { className: 'form-group' },
                            e('label', { htmlFor: 'def-q-type', className: 'form-label' }, 'Default Question Type'),
                            e('select', {
                                id: 'def-q-type', className: 'form-select',
                                value: defaultSettings.defaultQuestionType, 
                                onChange: (ev) => handleDefaultChange('defaultQuestionType', ev.target.value)
                            },
                                e('option', { value: 'MultipleChoice' }, 'MultipleChoice'),
                                e('option', { value: 'ShortAnswer' }, 'ShortAnswer'),
                                e('option', { value: 'TrueFalse' }, 'TrueFalse'),
                                e('option', { value: 'FillInTheBlank' }, 'FillInTheBlank')
                            )
                        )
                    ),
                    e('div', { className: 'form-group' },
                        e('label', { htmlFor: 'def-num-q', className: 'form-label' }, 'Default Number of Questions'),
                        e('input', {
                            id: 'def-num-q', type: 'number', className: 'form-input',
                            value: defaultSettings.defaultNumQuestions, 
                            onChange: (ev) => handleDefaultChange('defaultNumQuestions', parseInt(ev.target.value, 10))
                        })
                    )
                );
            }
            // (v4) í”„ë¡¬í”„íŠ¸ ì„¤ì • íƒ­
            if (activeTab === 'Prompts') {
                return e('div', { className: 'flex flex-col h-full' },
                    e('h3', { className: 'text-lg font-semibold mb-4' }, 'Quiz System Prompt'),
                    e('p', { className: 'text-xs text-gray-500 mb-4' }, 'ë³€ìˆ˜: {{DIFFICULTY}}, {{QUESTION_TYPE}}, {{NUM_QUESTIONS}}, {{CUSTOM_INSTRUCTIONS}} ë“±'),
                    e('textarea', {
                        className: 'form-textarea flex-grow h-full',
                        style: { height: '150px' },
                        value: quizSystemPrompt,
                        onChange: (e) => setQuizSystemPrompt(e.target.value)
                    }),
                    /* ğŸ“Œ (ì‹ ê·œ) AI ì±„ì  í”„ë¡¬í”„íŠ¸ ğŸ“Œ */
                    e('h3', { className: 'text-lg font-semibold mb-4 mt-6' }, 'Grading System Prompt'),
                    e('p', { className: 'text-xs text-gray-500 mb-4' }, 'ë³€ìˆ˜: (UserQueryì—ì„œ ìë™ ì£¼ì…ë¨)'),
                    e('textarea', {
                        className: 'form-textarea flex-grow h-full',
                        style: { height: '150px' },
                        value: gradingSystemPrompt,
                        onChange: (e) => setGradingSystemPrompt(e.target.value)
                    }),
                    /* ğŸ“Œ (ì‹ ê·œ) AI ì¡°ì–¸ í”„ë¡¬í”„íŠ¸ ğŸ“Œ */
                    e('h3', { className: 'text-lg font-semibold mb-4 mt-6' }, 'Analysis System Prompt'),
                    e('p', { className: 'text-xs text-gray-500 mb-4' }, 'ë³€ìˆ˜: (UserQueryì—ì„œ ìë™ ì£¼ì…ë¨)'),
                    e('textarea', {
                        className: 'form-textarea flex-grow h-full',
                        style: { height: '150px' },
                        value: analysisSystemPrompt,
                        onChange: (e) => setAnalysisSystemPrompt(e.target.value)
                    })
                );
            }
            return null;
        };
        
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', onClick: (e) => e.stopPropagation() },
                e('div', { className: 'modal-header' },
                    e('h2', null, 'Settings'),
                    e('button', { className: 'modal-close-btn', onClick: onClose }, 'Ã—')
                ),
                e('div', { className: 'modal-body' },
                    e('nav', { className: 'settings-nav' },
                        e('div', { 
                            className: 'settings-nav-item', 'data-active': activeTab === 'Quiz Defaults',
                            onClick: () => setActiveTab('Quiz Defaults')
                        }, 'Quiz Defaults'),
                        e('div', { 
                            className: 'settings-nav-item', 'data-active': activeTab === 'API Keys',
                            onClick: () => setActiveTab('API Keys')
                        }, 'API Keys'),
                        e('div', { 
                            className: 'settings-nav-item', 'data-active': activeTab === 'Prompts',
                            onClick: () => setActiveTab('Prompts')
                        }, 'Prompts')
                    ),
                    e('div', { className: 'settings-content' }, renderTabContent())
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: onClose }, 'Cancel'),
                    e('button', { className: 'modal-button-primary', onClick: handleSave }, 'Save Changes')
                )
            )
        );
    };
    
    // ë·° 7: í€´ì¦ˆ í’€ì´ ëª¨ë‹¬ (v6 - ë‹¤í˜•ì„± ë Œë”ë§)
    // ğŸ“Œ (ìˆ˜ì • 9) QuizTakerì˜ handleSubmit ìˆ˜ì • (100ì  ë§Œì )
    const QuizTaker = ({ quiz, onClose, onQuizSubmit }) => {
        const [questions, setQuestions] = useState([]);
        const [currentAnswers, setCurrentAnswers] = useState({});
        
        useEffect(() => {
            try {
                const parsedQuestions = JSON.parse(quiz.questions);
                setQuestions(parsedQuestions);
            } catch (e) { console.error("í€´ì¦ˆ ì§ˆë¬¸ íŒŒì‹± ì˜¤ë¥˜:", e); }
        }, [quiz]);

        // (v6) ë‹¤í˜•ì„± í•¸ë“¤ëŸ¬ (ê°’ ë˜ëŠ” ì¸ë±ìŠ¤ ì €ì¥)
        const handleAnswerChange = (qIndex, value) => {
            setCurrentAnswers(prev => ({ ...prev, [qIndex]: value }));
        };

        const handleSubmit = () => {
            const pointsPerQuestion = 100 / questions.length;
            let initialScore = 0;
            
            const userAnswers = questions.map((q, qIndex) => {
                let isCorrect = false; 
                const selectedAnswer = currentAnswers[qIndex];
                let points = 0;
                let score_0_1 = 0.0;

                // ğŸ“Œ (v6) ë‹¤í˜•ì„± ì±„ì 
                switch (q.questionType) {
                    case 'MultipleChoice':
                        isCorrect = (selectedAnswer === q.correctAnswerIndex);
                        if (isCorrect) {
                            initialScore += pointsPerQuestion;
                            points = pointsPerQuestion;
                            score_0_1 = 1.0;
                        }
                        break;
                    case 'ShortAnswer':
                    case 'Essay':
                    case 'CaseStudy':
                    default: 
                        isCorrect = null; // 'ì±„ì  ëŒ€ê¸°' ìƒíƒœ
                        score_0_1 = null;
                        points = 0;
                        break;
                }
                
                return {
                    questionType: q.questionType,
                    questionText: q.questionText,
                    options: q.options,
                    selectedAnswer: selectedAnswer,
                    correctAnswerIndex: q.correctAnswerIndex, 
                    gradingCriteria: q.gradingCriteria, 
                    isCorrect: isCorrect,
                    score_0_1: score_0_1, // ğŸ“Œ 0-1 ìŠ¤ì¼€ì¼ ì ìˆ˜
                    points: points, // ğŸ“Œ 100ì  ë§Œì  ê¸°ì¤€ íšë“ ì ìˆ˜
                    maxPoints: pointsPerQuestion // ğŸ“Œ 100ì  ë§Œì  ê¸°ì¤€ ë¬¸í•­ ë°°ì 
                };
            });

            const result = {
                id: crypto.randomUUID(),
                quizId: quiz.id,
                fileId: quiz.fileId, // (v5)
                quizTitle: quiz.title,
                score: initialScore, // ğŸ“Œ (ìˆ˜ì •) ê°ê´€ì‹ ì ìˆ˜ë§Œ ìš°ì„  ë°˜ì˜
                total: 100, // ğŸ“Œ (ìˆ˜ì •) 100ì  ë§Œì 
                answers: JSON.stringify(userAnswers), // ìƒì„¸ ê²°ê³¼ ì €ì¥
                completedAt: new Date().toISOString()
            };
            
            onQuizSubmit(result);
        };
        
        // (v6) ë‹¤í˜•ì„± ì§ˆë¬¸ ë Œë”ëŸ¬
        const renderQuestion = (q, qIndex) => {
            switch (q.questionType) {
                case 'MultipleChoice':
                    return e('div', { className: 'options-container' },
                        (q.options || []).map((option, oIndex) => e('label', { key: oIndex, className: 'quiz-option-label' },
                            e('input', {
                                type: 'radio',
                                name: `question-${qIndex}`,
                                checked: currentAnswers[qIndex] === oIndex,
                                onChange: () => handleAnswerChange(qIndex, oIndex)
                            }),
                            option
                        ))
                    );
                case 'ShortAnswer':
                case 'FillInTheBlank':
                case 'Essay':
                case 'CaseStudy':
                default:
                    // ğŸ“Œ (ìˆ˜ì •) ì£¼ê´€ì‹/ì—ì„¸ì´í˜•ì„ ìœ„í•´ textareaë¡œ ë³€ê²½
                    const isLongAnswer = ['Essay', 'CaseStudy'].includes(q.questionType);
                    return e('div', { className: 'form-group' },
                        isLongAnswer
                          ? e('textarea', {
                              className: 'form-textarea',
                              rows: 4,
                              value: currentAnswers[qIndex] || "",
                              onChange: (ev) => handleAnswerChange(qIndex, ev.target.value)
                            })
                          : e('input', {
                              type: 'text',
                              className: 'form-input',
                              value: currentAnswers[qIndex] || "",
                              onChange: (ev) => handleAnswerChange(qIndex, ev.target.value)
                            })
                    );
            }
        };
        
        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', style: { maxWidth: '800px' }, onClick: (e) => e.stopPropagation() },
                e('div', { className: 'modal-header' },
                    e('h2', null, quiz.title)
                ),
                e('div', { className: 'modal-body', style: { padding: '24px', display: 'block' } },
                    questions.map((q, qIndex) => e('div', { key: qIndex, className: 'quiz-question-card' },
                        e('p', { className: 'quiz-question-text' }, `${qIndex + 1}. ${q.questionText}`),
                        renderQuestion(q, qIndex)
                    ))
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: onClose }, 'Cancel'),
                    e('button', { className: 'modal-button-primary', onClick: handleSubmit }, 'Submit Quiz')
                )
            )
        );
    };
    
    // ë·° 8: í€´ì¦ˆ ê²°ê³¼ ëª¨ë‹¬ (v6 - ë‹¤í˜•ì„± ë Œë”ë§)
    // ğŸ“Œ (ìˆ˜ì • 10) QuizResult ì „ë©´ ìˆ˜ì • (ë¹„ë™ê¸° ì‘ì—… ìœ„ì„ + AI ì¡°ì–¸)
    const QuizResult = ({ attempt, quiz, onClose, dispatchGradingTask, userSettings }) => {
        const { setModalContent } = useContext(AppContext);
        const toast = useToast(); // ğŸ“Œ (ì‹ ê·œ) í† ìŠ¤íŠ¸ í›… ì‚¬ìš©
        const [results, setResults] = useState([]);
        const [analysis, setAnalysis] = useState(null); // ğŸ“Œ (ì‹ ê·œ) AI ì¡°ì–¸
        const [isAnalyzing, setIsAnalyzing] = useState(false); // ğŸ“Œ (ì‹ ê·œ) AI ì¡°ì–¸ ë¡œë”©
        
        useEffect(() => {
            try { setResults(JSON.parse(attempt.answers)); }
            catch(e) { console.error("ê²°ê³¼ íŒŒì‹± ì˜¤ë¥˜", e); }
        }, [attempt]);
        
        /* ğŸ“Œ (ì‹ ê·œ) AI ì „ì²´ ì±„ì  ì‹¤í–‰ í•¨ìˆ˜ (ì‘ì—… ìœ„ì„) ğŸ“Œ */
        const handleGradeAllSubjective = async () => {
            // 1. ì‘ì—… ìœ„ì„
            dispatchGradingTask(attempt);
            // 2. í† ìŠ¤íŠ¸ ì•Œë¦¼
            toast.show("AI ì±„ì ì„ ì‹œì‘í•©ë‹ˆë‹¤. (ì‘ì—… ëª¨ë‹ˆí„° ğŸ“Š)", 'info');
            // 3. ëª¨ë‹¬ ì¦‰ì‹œ ë‹«ê¸°
            onClose();
        };
        
        /* ğŸ“Œ (ì‹ ê·œ) AI í•™ìŠµ ì¡°ì–¸ ì‹¤í–‰ í•¨ìˆ˜ ğŸ“Œ */
        const handleGetAdvice = async () => {
            setIsAnalyzing(true);
            setAnalysis(null);
            try {
                // ì ìˆ˜ê°€ 1.0 (ë§Œì )ì´ ì•„ë‹Œ ëª¨ë“  ë¬¸ì œ í•„í„°ë§
                const incorrectOrPartial = results.filter(r => r.score_0_1 < 1.0);
                if (incorrectOrPartial.length === 0) {
                    setAnalysis("ëª¨ë“  ë¬¸ì œë¥¼ ì™„ë²½í•˜ê²Œ ë§í˜”ìŠµë‹ˆë‹¤! í›Œë¥­í•©ë‹ˆë‹¤.");
                    return;
                }
                
                const adviceData = await analyzeResultsWithAi(incorrectOrPartial, userSettings);
                setAnalysis(adviceData.studyAdvice);
                
            } catch (err) {
                console.error("AI ì¡°ì–¸ ìƒì„± ì‹¤íŒ¨:", err);
                toast.show(`âŒ ì¡°ì–¸ ìƒì„± ì‹¤íŒ¨: ${err.message}`, 'error');
            } finally {
                setIsAnalyzing(false);
            }
        };


        const retryIncorrect = () => {
            alert("ì˜¤ë‹µ ë‹¤ì‹œ í’€ê¸° ê¸°ëŠ¥ì€ êµ¬í˜„ ì¤‘ì…ë‹ˆë‹¤.");
        };
        
        // ğŸ“Œ ë‹¤í˜•ì„± ê²°ê³¼ ë Œë”ëŸ¬ (ë¶€ë¶„ ì ìˆ˜ ë°˜ì˜)
        const renderResultAnswer = (res, index) => {
            // 1. AI ì±„ì  ëŒ€ê¸° ì¤‘ (ì£¼ê´€ì‹)
            if (res.isCorrect === null) {
                return e(React.Fragment, null,
                    e('p', { className: 'result-answer yours' }, 
                        `ì œì¶œí•œ ë‹µ: ${res.selectedAnswer || 'N/A'}`
                    ),
                    e('p', { className: 'result-answer correct text-xs mt-2' }, 
                        `[ì±„ì  ê¸°ì¤€] ${res.gradingCriteria || 'N/A'}`
                    ),
                    e('p', { className: 'text-sm text-yellow-400 mt-2' }, 'AI ì±„ì  ëŒ€ê¸° ì¤‘...')
                );
            }
            
            // 2. ì±„ì  ì™„ë£Œ (ê°ê´€ì‹ ë˜ëŠ” ì£¼ê´€ì‹)
            let answerContent;
            switch(res.questionType) {
                case 'MultipleChoice':
                    answerContent = e(React.Fragment, null,
                        e('p', { className: 'result-answer correct' }, 
                            `ì •ë‹µ: ${res.options[res.correctAnswerIndex]}`
                        ),
                        !res.isCorrect && e('p', { className: 'result-answer yours' }, 
                            `ì„ íƒí•œ ë‹µ: ${res.options[res.selectedAnswer] || 'N/A'}`
                        )
                    );
                    break;
                default: // ShortAnswer ë“±
                    answerContent = e(React.Fragment, null,
                        e('p', { className: 'result-answer correct font-bold text-lg' }, 
                            `ì ìˆ˜: ${res.points.toFixed(1)} / ${res.maxPoints.toFixed(1)}`
                        ),
                        e('p', { className: 'result-answer yours mt-2' }, 
                            `ì œì¶œí•œ ë‹µ: ${res.selectedAnswer || 'N/A'}`
                        )
                    );
                    break;
            }

            return e(React.Fragment, null, 
                answerContent,
                /* ğŸ“Œ AI ì²¨ì‚­ í”¼ë“œë°± í‘œì‹œ ğŸ“Œ */
                res.feedback && e('div', { className: 'mt-2 p-2 bg-gray-800 rounded' },
                    e('p', { className: 'text-xs font-semibold text-blue-300' }, 'AI ì²¨ì‚­:'),
                    e('p', { className: 'text-sm' }, res.feedback)
                )
            );
        };
        
        // ğŸ“Œ ì±„ì í•  ì£¼ê´€ì‹ ë¬¸ì œê°€ ìˆëŠ”ì§€ í™•ì¸
        const hasSubjectiveToGrade = useMemo(() => {
            return results.some(r => r.isCorrect === null);
        }, [results]);

        return e('div', { className: 'modal-overlay', onClick: onClose },
            e('div', { className: 'modal-container', onClick: (e) => e.stopPropagation() },
                e('div', { className: 'modal-header' },
                    e('h2', null, 'í€´ì¦ˆ ê²°ê³¼: ' + attempt.quizTitle),
                    e('button', { className: 'modal-close-btn', onClick: onClose }, 'Ã—')
                ),
                /* ğŸ“Œ ìˆ˜ì •: style={{ display: 'block' }} ì¶”ê°€ ğŸ“Œ */
                e('div', { className: 'modal-body quiz-result-body', style: { display: 'block' } },
                    e('div', { className: 'quiz-result-score mb-6' }, 
                        `ì ìˆ˜: ${attempt.score.toFixed(1)} / ${attempt.total}` // ğŸ“Œ 100ì  ë§Œì , ì†Œìˆ˜ì 
                    ),
                    results.map((res, index) => e('div', { 
                        key: index, 
                        // ğŸ“Œ (ìˆ˜ì •) ì±„ì  ëŒ€ê¸°(null)ëŠ” ì¤‘ë¦½ìƒ‰(íšŒìƒ‰)ìœ¼ë¡œ í‘œì‹œ
                        className: `result-question ${res.isCorrect === true ? 'result-question-correct' : (res.isCorrect === false ? 'result-question-incorrect' : 'bg-gray-700')}`
                    },
                        e('p', { className: 'result-question-text' }, `${index + 1}. ${res.questionText}`),
                        renderResultAnswer(res, index)
                    )),
                    
                    /* ğŸ“Œ (ì‹ ê·œ) AI í•™ìŠµ ì¡°ì–¸ ì„¹ì…˜ ğŸ“Œ */
                    isAnalyzing && e('div', { className: 'spinner-overlay !relative !h-10 !bg-transparent mt-4' }, 
                        e('div', { className: 'spinner !w-6 !h-6' })
                    ),
                    analysis && e('div', { className: 'ai-advice-container' },
                        e('h3', { className: 'ai-advice-header' }, 'ğŸ§  AI í•™ìŠµ ì¡°ì–¸'),
                        e('p', { className: 'ai-advice-body' }, analysis)
                    )
                ),
                e('div', { className: 'modal-footer' },
                    e('button', { className: 'modal-button-secondary', onClick: retryIncorrect }, 'í‹€ë¦° ë¬¸ì œ ë‹¤ì‹œ í’€ê¸°'),
                    /* ğŸ“Œ AI ì±„ì  ë²„íŠ¼ (ë¹„ë™ê¸°) ğŸ“Œ */
                    hasSubjectiveToGrade && e('button', { 
                        className: 'modal-button-primary', 
                        onClick: handleGradeAllSubjective,
                    }, 'âœ¨ ì „ì²´ AI ì±„ì '),
                    /* ğŸ“Œ (ì‹ ê·œ) AI ì¡°ì–¸ ë²„íŠ¼ ğŸ“Œ */
                    !hasSubjectiveToGrade && !analysis && e('button', {
                        className: 'modal-button-primary',
                        onClick: handleGetAdvice,
                        disabled: isAnalyzing
                    }, 'ğŸ§  AI í•™ìŠµ ì¡°ì–¸ ë°›ê¸°'),
                    e('button', { className: 'modal-button-primary', onClick: onClose }, 'ë‹«ê¸°')
                )
            )
        );
    };


    // --- 5. ë©”ì¸ ì•± ì»´í¬ë„ŒíŠ¸ (v6 - ë²„ê·¸ ìˆ˜ì •) ---
    const App = () => {
      // (v4) DB í—¬í¼
      const dbHelper = useMemo(() => new IdbHelper('AIQuizAppDB', 1, DB_STORES_CONFIG), []); // (v5) ìŠ¤í‚¤ë§ˆ ì£¼ì…
      
      // ğŸ“Œ ì‹ ê·œ: í† ìŠ¤íŠ¸ í›…
      const toast = useToast(); 
      
      // ì „ì—­ ìƒíƒœ
      const [isLoading, setIsLoading] = useState(true);
      const [userSettings, setUserSettings] = useState(DEFAULT_SETTINGS);
      const [modalContent, setModalContent] = useState(null);
      
      // UI ìƒíƒœ
      const [activeViewId, setActiveViewId] = useState('files');
      const [isSidebarVisible, setIsSidebarVisible] = useState(true);
      const [activeEditorFile, setActiveEditorFile] = useState(null);
      const [editingNodeId, setEditingNodeId] = useState(null);
      const [isDragOverlayVisible, setIsDragOverlayVisible] = useState(false); // ğŸ“Œ ì‹ ê·œ
      
      // (v5) í€´ì¦ˆ ì˜µì…˜ ìƒíƒœ (ê¸€ë¡œë²Œ)
      const [quizOptions, setQuizOptions] = useState({
          numQuestions: 10,
          difficulty: "Medium",
          questionType: "MultipleChoice",
          includeSnippets: false,
          provideAnswerKey: true,
          customInstructions: ""
      });
      
      // ë°ì´í„° ìƒíƒœ
      const quizWorker = useMemo(() => new Worker(workerUrl), []);
      const [taskQueue, setTaskQueue] = useState([]);
      const [files, setFiles] = useState([]);
      const [quizzes, setQuizzes] = useState([]);
      const [attempts, setAttempts] = useState([]);

      // (v4) ë°ì´í„° ë¡œë“œ ë° ìƒˆë¡œê³ ì¹¨
      const refetchAllData = useCallback(async () => {
          if (!dbHelper.db) return;
          try {
              const [filesData, quizzesData, attemptsData, settingsData] = await Promise.all([
                  dbHelper.getAll('files'),
                  dbHelper.getAll('quizzes'),
                  dbHelper.getAll('quizAttempts'),
                  dbHelper.get('settings', 'userConfig')
              ]);
              setFiles(filesData);
              setQuizzes(quizzesData);
              setAttempts(attemptsData); // ğŸ“Œ (í™•ì¸)
              
              const newSettings = settingsData || DEFAULT_SETTINGS;
              setUserSettings(newSettings);
              
              // (v5) í€´ì¦ˆ ì˜µì…˜ ìƒíƒœë¥¼ ìœ ì € ì„¤ì •ìœ¼ë¡œ ì´ˆê¸°í™”
              setQuizOptions(prev => ({
                  ...prev,
                  numQuestions: newSettings.defaultNumQuestions || prev.numQuestions,
                  difficulty: newSettings.defaultDifficulty || prev.difficulty,
                  questionType: newSettings.defaultQuestionType || prev.questionType,
              }));
              
          } catch (e) {
              console.error("ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", e);
          }
      }, [dbHelper]);

      // 1. (v4) DB ì´ˆê¸°í™”
      useEffect(() => {
        dbHelper.init().then(() => {
            refetchAllData().then(() => setIsLoading(false));
        });
      }, [dbHelper, refetchAllData]);
      
      
      // ğŸ“Œ (ìˆ˜ì •) Web Worker ë¦¬ìŠ¤ë„ˆ (AI ì±„ì  ê²°ê³¼ ì²˜ë¦¬)
      useEffect(() => {
        quizWorker.onmessage = (e) => {
          const { status, taskId, taskType, quizData, updatedAttempt, error, options } = e.data; 
          
          setTaskQueue(prev => prev.map(task => 
              task.id === taskId ? { ...task, status, error } : task
          ));
          
          if (status === 'success') {
            if (taskType === 'grade' && updatedAttempt) {
                // --- AI ì±„ì  ì™„ë£Œ ---
                dbHelper.put('quizAttempts', updatedAttempt).then(() => {
                    refetchAllData();
                    if (toast) toast.show('âœ… AI ì±„ì ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                });
            } else if (taskType === 'generate' && quizData) {
                // --- AI í€´ì¦ˆ ìƒì„± ì™„ë£Œ (ê¸°ì¡´) ---
                const newQuiz = {
                    id: crypto.randomUUID(),
                    title: quizData.title,
                    sourceText: "N/A", 
                    fileId: options.fileId, 
                    sourceFileName: options.sourceFileName,
                    questions: JSON.stringify(quizData.questions),
                    createdAt: new Date().toISOString(),
                    questionCount: quizData.questions.length,
                    options: options
                };
                dbHelper.add('quizzes', newQuiz).then(() => {
                    refetchAllData();
                    if (toast) toast.show('âœ¨ í€´ì¦ˆ ìƒì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.', 'success');
                });
            }
          } else if (status === 'error') {
              console.error(`Task ${taskId} (${taskType}) failed: ${error}`);
              if (toast) toast.show(`âŒ ì‘ì—… ì‹¤íŒ¨: ${error}`, 'error');
          }
        };
        return () => { quizWorker.onmessage = null; };
      }, [quizWorker, dbHelper, refetchAllData, toast]); // ğŸ“Œ toast ì˜ì¡´ì„± ì¶”ê°€
      
      // (v4) íŒŒì¼ ì‹œìŠ¤í…œ í›…
      const { fileTree, fileActions } = useFileSystem(files, dbHelper, refetchAllData);

      /* ğŸ“Œ (íŒ¨ì¹˜ 1) ì‹ ê·œ: íŒŒì¼ ì½ê¸° ë™ê¸° ì‹œì‘ í—¬í¼ ğŸ“Œ */
      const initiateFileReads = (files) => {
         return Array.from(files).map(file => {
             const fileName = file.name;
             const ext = fileName.split('.').pop().toLowerCase();
             let contentPromise;

             if (['zip', 'pdf', 'docx'].includes(ext)) {
                 contentPromise = file.arrayBuffer(); // Read as buffer
             } else if (['txt', 'md', 'js', 'css', 'html', 'json', 'xml', 'py', 'java', 'c', 'cpp', 'cs', 'go'].includes(ext)) {
                 contentPromise = file.text(); // Read as text
             } else {
                 contentPromise = Promise.resolve(null); // For HWP etc.
             }
             
             return { fileName, contentPromise, ext };
         });
      };

      /* ğŸ“Œ ì‹ ê·œ: íŒŒì¼ ì²˜ë¦¬ ë¡œì§ (v9) */
      
      // (zip)
      const processZip = async (fileName, fileContent, parentId) => {
        toast.show(`ì••ì¶• í•´ì œ ì¤‘: ${fileName}`, 'info');
        try {
          const zip = await JSZip.loadAsync(fileContent); // ğŸ“Œ (ìˆ˜ì •) JSZip (ëŒ€ë¬¸ì)
          
          // 1. ëª¨ë“  í´ë” ê²½ë¡œ ì¶”ì¶œ ë° ì •ë ¬ (ì•”ì‹œì /ëª…ì‹œì  ê²½ë¡œ ëª¨ë‘)
          const allFolderPaths = new Set();
          Object.keys(zip.files).forEach(p => {
              if (zip.files[p].dir) {
                  allFolderPaths.add(p);
              } else {
                  const parts = p.split('/');
                  parts.pop(); // filename
                  let currentPath = '';
                  for (const part of parts) {
                      if (!part) continue;
                      currentPath += part + '/';
                      allFolderPaths.add(currentPath);
                  }
              }
          });

          const sortedFolderPaths = Array.from(allFolderPaths)
              .filter(p => p && !p.startsWith('__MACOSX/'))
              .sort((a, b) => a.split('/').length - b.split('/').length);

          // 2. ëª¨ë“  í´ë” ìˆœì°¨ì ìœ¼ë¡œ ìƒì„±
          const createdFolderIds = new Map();
          createdFolderIds.set('root', parentId); // Zip's root maps to the target parentId

          for (const folderPath of sortedFolderPaths) {
              const parts = folderPath.replace(/\/$/, '').split('/');
              const folderName = parts[parts.length - 1];
              const parentPath = parts.slice(0, -1).join('/') + (parts.length > 1 ? '/' : '');
              const parentFolderId = createdFolderIds.get(parentPath || 'root');

              if (parentFolderId && folderName && !createdFolderIds.has(folderPath)) {
                  // ğŸ“Œ (ìˆ˜ì •) fileActions.createê°€ refetchë¥¼ í˜¸ì¶œí•˜ë¯€ë¡œ, findOrCreateFolder í—¬í¼ ëŒ€ì‹  ì§ì ‘ ìƒì„±
                  const newFolder = await dbHelper.add('files', {
                      id: crypto.randomUUID(),
                      name: folderName,
                      type: 'folder',
                      parentId: parentFolderId,
                      content: null,
                      createdAt: new Date().toISOString()
                  });
                  createdFolderIds.set(folderPath, newFolder);
              }
          }
          await refetchAllData(); // ğŸ“Œ í´ë” ìƒì„± í›„ 1ì°¨ ë™ê¸°í™”

          // 3. ëª¨ë“  íŒŒì¼ ìƒì„±
          for (const [relativePath, zipEntry] of Object.entries(zip.files)) {
              if (!zipEntry.dir && !zipEntry.name.startsWith('__MACOSX/') && zipEntry.name) {
                  const parts = zipEntry.name.split('/');
                  const fileName = parts.pop();
                  const parentPath = parts.join('/') + (parts.length > 0 ? '/' : '');
                  const parentFolderId = createdFolderIds.get(parentPath || 'root');

                  if (parentFolderId && fileName) {
                      const content = await zipEntry.async("string");
                      await fileActions.create(parentFolderId, 'file', fileName, content);
                  }
              }
          }
          toast.show(`âœ… ${fileName} ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ`, 'success');

        } catch (err) {
          console.error("ZIP ì²˜ë¦¬ ì˜¤ë¥˜:", err);
          toast.show(`âŒ ZIP ì²˜ë¦¬ ì‹¤íŒ¨: ${err.message}`, 'error');
          refetchAllData(); // ğŸ“Œ ì‹¤íŒ¨ ì‹œì—ë„ ë™ê¸°í™”
        }
      };

      // (pdf)
      const processPdf = async (fileName, fileContent, parentId) => {
        toast.show(`PDF í…ìŠ¤íŠ¸ ì¶”ì¶œ ì¤‘: ${fileName}`, 'info');
        try {
          const arrayBuffer = fileContent;
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
          let allText = "";
          
          for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            allText += textContent.items.map(item => item.str).join(' ') + '\n\n';
          }
          
          await fileActions.create(parentId, 'file', `${fileName}.txt`, allText);
          toast.show(`âœ… PDF í…ìŠ¤íŠ¸ ì¶”ì¶œ ì™„ë£Œ`, 'success');

        } catch (err) {
          console.error("PDF ì²˜ë¦¬ ì˜¤ë¥˜:", err);
          toast.show(`âŒ PDF ì²˜ë¦¬ ì‹¤íŒ¨: ${err.message}`, 'error');
        }
      };
      
      // (docx)
      const processDocx = async (fileName, fileContent, parentId) => {
        toast.show(`DOCX í…ìŠ¤íŠ¸ ì¶”ì¶œ ì¤‘: ${fileName}`, 'info');
        try {
          const arrayBuffer = fileContent;
          const result = await mammoth.extractRawText({ arrayBuffer });
          await fileActions.create(parentId, 'file', `${fileName}.txt`, result.value);
          toast.show(`âœ… DOCX í…ìŠ¤íŠ¸ ì¶”ì¶œ ì™„ë£Œ`, 'success');
        } catch (err) {
          console.error("DOCX ì²˜ë¦¬ ì˜¤ë¥˜:", err);
          toast.show(`âŒ DOCX ì²˜ë¦¬ ì‹¤íŒ¨: ${err.message}`, 'error');
        }
      };

      // (text)
      const processText = async (fileName, fileContent, parentId) => {
        try {
          await fileActions.create(parentId, 'file', fileName, fileContent);
        } catch (err) {
          console.error("í…ìŠ¤íŠ¸ íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜:", err);
          toast.show(`âŒ ${fileName} ì½ê¸° ì‹¤íŒ¨`, 'error');
        }
      };
      
      // (hwp/binary)
      const processBinary = (fileName, parentId) => {
        const message = fileName.endsWith('.hwp') 
          ? "HWP íŒŒì¼ì€ í…ìŠ¤íŠ¸ ì¶”ì¶œì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. íŒŒì¼ë§Œ ì €ì¥í•©ë‹ˆë‹¤."
          : "í…ìŠ¤íŠ¸ê°€ ì•„ë‹Œ íŒŒì¼ì…ë‹ˆë‹¤. íŒŒì¼ë§Œ ì €ì¥í•©ë‹ˆë‹¤.";
        toast.show(message, 'info');
        // ë¹ˆ íŒŒì¼ë¡œ ìƒì„±
        fileActions.create(parentId, 'file', fileName, `[${fileName}] - í…ìŠ¤íŠ¸ë¥¼ ì½ì„ ìˆ˜ ì—†ëŠ” ë°”ì´ë„ˆë¦¬ íŒŒì¼ì…ë‹ˆë‹¤.`);
      };

      // íŒŒì¼ ì²˜ë¦¬ ë¼ìš°í„°
      const processFile = (fileName, fileContent, parentId) => {
        const ext = fileName.split('.').pop().toLowerCase();
        switch (ext) {
          case 'zip':
            processZip(fileName, fileContent, parentId);
            break;
          case 'pdf':
            processPdf(fileName, fileContent, parentId);
            break;
          case 'docx':
            processDocx(fileName, fileContent, parentId);
            break;
          case 'txt':
          case 'js':
          case 'css':
          case 'html':
          case 'json':
          case 'md':
          case 'xml':
          case 'py':
          case 'java':
          case 'c':
          case 'cpp':
          case 'cs':
          case 'go':
            processText(fileName, fileContent, parentId);
            break;
          default:
            processBinary(fileName, parentId); // .hwp ë“± ê¸°íƒ€
            break;
        }
      };
      
      // ğŸ“Œ (íŒ¨ì¹˜ 2) ë“œë¡­ í•¸ë“¤ëŸ¬ -> ë¹„ë™ê¸° ì²˜ë¦¬ í•¨ìˆ˜ë¡œ ë³€ê²½
      const processReadsAndStore = useCallback(async (pendingReads, parentId) => {
          toast.show(`íŒŒì¼ ${pendingReads.length}ê°œ ì²˜ë¦¬ ì‹œì‘...`, 'info');

          // 1. (ìˆ˜ì •) ì´ë¯¸ ì‹œì‘ëœ Promiseë“¤ì„ await
          const readResults = await Promise.all(pendingReads.map(async (read) => {
              try {
                  const content = await read.contentPromise;
                  return { ...read, content, parentId }; // parentIdë¥¼ ì „ë‹¬
              } catch (err) {
                  console.error(`Error reading file ${read.fileName}:`, err);
                  toast.show(`âŒ ${read.fileName} ì½ê¸° ì‹¤íŒ¨: ${err.message}`, 'error');
                  return null;
              }
          }));

          // 2. (ìˆ˜ì •) ë©”ëª¨ë¦¬ì— ë¡œë“œëœ ì»¨í…ì¸ ë¥¼ ìˆœíšŒí•˜ë©° DBì— ì €ì¥
          for (const fileData of readResults) {
              if (fileData) { // nullì´ ì•„ë‹Œ (ì„±ê³µí•œ) íŒŒì¼ë§Œ ì²˜ë¦¬
                  // processFileì€ App ìŠ¤ì½”í”„ì— ì •ì˜ë˜ì–´ ìˆìŒ
                  processFile(fileData.fileName, fileData.content, fileData.parentId);
              }
          }
          
          // ğŸ“Œ (ìˆ˜ì •) ì¼ê´„ refetchë¥¼ create ë‚´ë¶€ì—ì„œ í•˜ë„ë¡ ë³€ê²½í–ˆìœ¼ë¯€ë¡œ, ì—¬ê¸°ì„œëŠ” í† ìŠ¤íŠ¸ë§Œ
          setTimeout(() => {
              refetchAllData(); // ğŸ“Œ ìµœì¢… ë™ê¸°í™”
              toast.show('âœ… íŒŒì¼ ê°€ì ¸ì˜¤ê¸° ì™„ë£Œ.', 'success');
          }, 1500); // ğŸ“Œ ë¹„ë™ê¸° ìƒì„± ì‘ì—…ì´ ì™„ë£Œë  ì‹œê°„ì„ ì¤Œ

      }, [fileActions, refetchAllData, toast]); // ğŸ“Œ 'processFile'ì€ ìŠ¤ì½”í”„ í•¨ìˆ˜ì´ë¯€ë¡œ ì˜ì¡´ì„± ë¶ˆí•„ìš”
      
      // (ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ)
      useEffect(() => {
        const dragEnter = (e) => {
          e.preventDefault();
          e.stopPropagation();
          // ğŸ“Œ íŒŒì¼ì´ ìˆì„ ë•Œë§Œ ì˜¤ë²„ë ˆì´ í‘œì‹œ
          if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
            setIsDragOverlayVisible(true);
          }
        };
        const dragOver = (e) => {
          e.preventDefault();
          e.stopPropagation();
        };
        const dragLeave = (e) => {
          e.preventDefault();
          e.stopPropagation();
          // ë·°í¬íŠ¸ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš°
          if (!e.relatedTarget || e.relatedTarget.nodeName === "HTML") {
            setIsDragOverlayVisible(false);
          }
        };
        // ğŸ“Œ (íŒ¨ì¹˜ 3) window.drop ìˆ˜ì •
        const drop = (e) => {
          e.preventDefault();
          e.stopPropagation();
          setIsDragOverlayVisible(false);
          
          // FileNode ë‚´ë¶€ ë“œë¡­ì€ FileNodeì˜ onDropì—ì„œ ì²˜ë¦¬ë¨ (ì´ë²¤íŠ¸ ì „íŒŒ ì¤‘ë‹¨)
          // ì—¬ê¸°ëŠ” window(ìµœìƒìœ„) ë“œë¡­, ì¦‰ rootì— ë“œë¡­ëœ ê²½ìš°
          // ğŸ“Œ (ìˆ˜ì •) 1. ë™ê¸°ì ìœ¼ë¡œ íŒŒì¼ ì½ê¸° ì‹œì‘
          const pendingReads = initiateFileReads(e.dataTransfer.files);
          // ğŸ“Œ (ìˆ˜ì •) 2. ë¹„ë™ê¸° ì²˜ë¦¬ëŠ” 'fire and forget'
          processReadsAndStore(pendingReads, 'root');
        };

        window.addEventListener('dragenter', dragEnter);
        window.addEventListener('dragover', dragOver);
        window.addEventListener('dragleave', dragLeave);
        window.addEventListener('drop', drop);

        return () => {
          window.removeEventListener('dragenter', dragEnter);
          window.removeEventListener('dragover', dragOver);
          window.removeEventListener('dragleave', dragLeave);
          window.removeEventListener('drop', drop);
        };
      }, [processReadsAndStore]); // ğŸ“Œ (íŒ¨ì¹˜ 4) ì˜ì¡´ì„± ë³€ê²½

      // --- í•¸ë“¤ëŸ¬ ---
      
      // ì„¤ì • ì €ì¥
      const handleSaveSettings = useCallback(async (newSettings) => {
          const settingsToSave = { ...newSettings, id: 'userConfig' };
          await dbHelper.put('settings', settingsToSave);
          setUserSettings(settingsToSave);
          // (v5) ì €ì¥ ì‹œ í€´ì¦ˆ ì˜µì…˜ ìƒíƒœë„ ì—…ë°ì´íŠ¸
          setQuizOptions(prev => ({
              ...prev,
              numQuestions: settingsToSave.defaultNumQuestions || prev.numQuestions,
              difficulty: settingsToSave.defaultDifficulty || prev.difficulty,
              questionType: settingsToSave.defaultQuestionType || prev.questionType,
          }));
      }, [dbHelper]);

      // ì‚¬ì´ë“œë°” í† ê¸€
      const handleActivityChange = (id) => {
          if (id === 'settings') {
              setModalContent(e(SettingsModal, { onClose: () => setModalContent(null) }));
              return;
          }
          if (id === activeViewId && isSidebarVisible) setIsSidebarVisible(false);
          else { setIsSidebarVisible(true); setActiveViewId(id); }
      };
      
      // í€´ì¦ˆ ìƒì„± ì‘ì—… ë””ìŠ¤íŒ¨ì¹˜
      const dispatchTask = useCallback((taskData) => {
          const taskId = crypto.randomUUID();
          const newTask = { ...taskData, id: taskId, status: 'processing', taskType: 'generate' }; // ğŸ“Œ taskType ëª…ì‹œ
          setTaskQueue(prev => [newTask, ...prev]);
          // (v4) ì›Œì»¤ì— ê¸°ë³¸ ì„¤ì •(í”„ë¡¬í”„íŠ¸ í¬í•¨) í•¨ê»˜ ì „ë‹¬
          quizWorker.postMessage({ ...newTask, settings: userSettings, DEFAULT_SETTINGS });
          handleActivityChange('tasks'); // ì‘ì—… ëª¨ë‹ˆí„° íƒ­ìœ¼ë¡œ ì´ë™
          if (toast) toast.show('âœ¨ í€´ì¦ˆ ìƒì„±ì„ ì‹œì‘í•©ë‹ˆë‹¤.', 'info');
      }, [quizWorker, userSettings, toast]); // ğŸ“Œ toast ì˜ì¡´ì„± ì¶”ê°€
      
      /* ğŸ“Œ (ì‹ ê·œ) AI ì±„ì  ì‘ì—… ë””ìŠ¤íŒ¨ì¹˜ ğŸ“Œ */
      const dispatchGradingTask = useCallback((attempt) => {
          const taskId = crypto.randomUUID();
          const newTask = { 
              id: taskId, 
              status: 'processing', 
              taskType: 'grade', // ğŸ“Œ ì‘ì—… ìœ í˜•: ì±„ì 
              options: { quizTitle: attempt.quizTitle } // ëª¨ë‹ˆí„° í‘œì‹œìš©
          };
          setTaskQueue(prev => [newTask, ...prev]);
          // ì›Œì»¤ì— ì±„ì  ì‘ì—… ì „ì†¡
          quizWorker.postMessage({ ...newTask, attempt, settings: userSettings, DEFAULT_SETTINGS });
          handleActivityChange('tasks'); // ì‘ì—… ëª¨ë‹ˆí„° íƒ­ìœ¼ë¡œ ì´ë™
      }, [quizWorker, userSettings]); // ğŸ“Œ toast ì˜ì¡´ì„± ì œê±° (QuizResultì—ì„œ ì§ì ‘ í˜¸ì¶œ)

      // í€´ì¦ˆ ì œì¶œ
      const handleQuizSubmit = async (result) => {
          try {
              await dbHelper.add('quizAttempts', result);
              await refetchAllData(); // ğŸ“Œ await ì¶”ê°€
              
              setModalContent(e(QuizResult, {
                  attempt: result,
                  quiz: quizzes.find(q => q.id === result.quizId),
                  onClose: () => setModalContent(null),
                  /* ğŸ“Œ (ì‹ ê·œ) AI ì±„ì  ì˜ì¡´ì„± ì£¼ì… ğŸ“Œ */
                  userSettings,
                  dbHelper,
                  refetchAllData,
                  dispatchGradingTask // ğŸ“Œ ì‹ ê·œ
              }));
          } catch (err) { console.error("í€´ì¦ˆ ì œì¶œ ì˜¤ë¥˜:", err); }
      };

      // ğŸ“Œ (íŒ¨ì¹˜ 5) ì»¨í…ìŠ¤íŠ¸ ê°’
      const contextValue = {
          dbHelper,
          refetchAllData,
          userSettings,
          saveSettings: handleSaveSettings,
          files,
          quizzes,
          attempts,
          taskQueue,
          dispatchTask,
          dispatchGradingTask, // ğŸ“Œ ì‹ ê·œ
          processReadsAndStore, // ğŸ“Œ (íŒ¨ì¹˜)
          initiateFileReads, // ğŸ“Œ (íŒ¨ì¹˜)
          fileTree,
          fileActions,
          activeEditorFile,
          setActiveEditorFile,
          setModalContent,
          editingNodeId,
          setEditingNodeId,
          quizOptions, // (v5)
          setQuizOptions, // (v5)
          handleQuizSubmit,
          toast // ğŸ“Œ ì‹ ê·œ
      };

      // ì‚¬ì´ë“œë°” ì•„ì´í…œ
      const sidebarItems = [
        { id: 'files', label: 'íŒŒì¼ íƒìƒ‰ê¸°', icon: 'ğŸ“„' },
        { id: 'quiz-generator', label: 'í€´ì¦ˆ ìƒì„± ì˜µì…˜', icon: 'âœ¨' }, // (v5) ì´ë¦„ ë³€ê²½
        { id: 'history', label: 'ì „ì²´ í’€ì´ ê¸°ë¡', icon: 'ğŸ“š' }, // (v5) ì´ë¦„ ë³€ê²½
        { id: 'tasks', label: 'ì‘ì—… ëª¨ë‹ˆí„°', icon: 'ğŸ“Š' },
        { id: 'user', label: 'ì‚¬ìš©ì', icon: 'ğŸ‘¤', isBottom: true },
        { id: 'settings', label: 'ì„¤ì •', icon: 'âš™ï¸', isBottom: true },
      ];
      
      if (isLoading) {
        return e('div', { className: 'flex items-center justify-center h-screen' }, e(Spinner));
      }

      return e(AppContext.Provider, { value: contextValue },
        e('div', { className: 'flex h-screen' },
          e(ReactVscodeSidebar, {
            items: sidebarItems,
            onActiveChange: handleActivityChange,
            activeId: activeViewId,
            isVisible: isSidebarVisible
          },
            // ë·° ì»¨í…ì¸  (Children)
            e(FileManagerView, { viewId: 'files' }),
            e(QuizGeneratorView, { viewId: 'quiz-generator' }),
            e(QuizHistoryView, { viewId: 'history' }),
            e(TaskMonitorView, { viewId: 'tasks' })
          ),
          
          e('div', { className: 'main-content' }, 
            e(MainContentEditor, null)
          ),
          
          // ëª¨ë‹¬ ì»¨í…ì¸  (ì„¤ì •, í€´ì¦ˆ í’€ì´, í€´ì¦ˆ ê²°ê³¼)
          modalContent,
          
          /* ğŸ“Œ ì‹ ê·œ: ë“œë˜ê·¸ ì˜¤ë²„ë ˆì´ ğŸ“Œ */
          isDragOverlayVisible && e('div', { className: 'drag-overlay' }, 'ì—¬ê¸°ì— íŒŒì¼ ë†“ê¸°')
        )
      );
    };

    // --- 6. ì•± ë§ˆìš´íŠ¸ ---
    const root = createRoot(document.getElementById('root'));
    // ğŸ“Œ (ì‹ ê·œ) ì•±ì„ ToastProviderë¡œ ê°ì‹¸ê¸°
    root.render(e(ToastProvider, null, e(App)));
    
  </script>
</body>
</html>
