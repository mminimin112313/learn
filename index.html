<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>통합 학습 환경 (ILE) v8.5 - Full Version</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    
    <!-- MathJax for LaTeX rendering -->
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    
    <style>
        :root {
            /* Full CSS revision for a light theme, matching the provided image's color palette */
            --bg-primary: #FFFFFF; /* Main background - white */
            --bg-secondary: #F0F3F7; /* Sidebar background - light gray */
            --card-background: #FFFFFF; /* Card and modal backgrounds - white */
            --accent-primary: #4285F4; /* Primary accent blue (Google's blue) */
            --accent-rgb: 66, 133, 244; 
            --accent-primary-hover: #357AE8; 
            --accent-primary-focus-ring: rgba(var(--accent-rgb), 0.3);
            --text-primary: #3C4043; /* Primary text color - dark gray */
            --text-secondary: #5F6368; /* Secondary text color - medium gray */
            --text-placeholder: #80868B; /* Placeholder text color - lighter gray */
            --border-color: #DADCE0; /* Border color - light gray */
            --input-bg: #F8F9FA; /* Input background - very light gray */
            --success-color: #34A853; /* Google Green */
            --warning-color: #FBBC04; /* Google Yellow */
            --danger-color: #EA4335; /* Google Red */
            --font-sans: 'Inter', 'Noto Sans KR', sans-serif;
            --font-mono: 'SFMono-Regular', Consolas, Menlo, monospace;
            --sidebar-width: 300px;
        }
        html, body { height: 100%; overflow: hidden; }
        body { background-color: var(--bg-primary); color: var(--text-primary); font-family: var(--font-sans); font-size: 15px; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-secondary); }
        ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-secondary); }
        .ile-container { display: flex; flex-direction: column; height: 100%; }
        .sidebar { 
            position: fixed; top: 0; left: 0; 
            width: var(--sidebar-width); height: 100%; 
            background-color: var(--bg-secondary); 
            border-right: 1px solid var(--border-color); 
            display: flex; flex-direction: column; 
            gap: 1.5rem; padding: 1rem; 
            transform: translateX(-100%); 
            transition: transform 0.3s ease-in-out; 
            z-index: 1100; overflow-y: auto; 
        }
        .sidebar.is-open { transform: translateX(0); box-shadow: 0 0 40px rgba(0,0,0,0.2); } /* Adjusted shadow for light theme */
        .main-content { overflow-y: auto; flex-grow: 1; display: flex; flex-direction: column; }
        .main-content-inner { padding: 1.5rem; }
        .mobile-header { 
            display: flex; align-items: center; justify-content: space-between; 
            padding: 0.75rem 1.5rem; 
            background-color: var(--bg-secondary); /* Match sidebar */
            border-bottom: 1px solid var(--border-color); 
            position: sticky; top: 0; z-index: 1000; 
            color: var(--text-primary); /* Ensure text is readable */
        }
        .mobile-header .hamburger-btn { background: none; border: none; color: var(--text-primary); font-size: 1.5rem; padding: 0.5rem; line-height: 1; }
        .mobile-header .project-title-mobile { font-size: 1.1rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); opacity: 0; visibility: hidden; transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; z-index: 1099; } /* Lighter overlay for light theme */
        .overlay.is-visible { opacity: 1; visibility: visible; }
        .sidebar-header h4 { font-size: 1.25rem; color: var(--text-primary); } /* Ensure readability */
        .sidebar-title { font-size: 1rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary); } /* Ensure readability */
        
        /* Project List Specific Styles */
        .sidebar-section.project-list-section .list-group {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
        }

        .list-group-item { 
            background-color: var(--bg-secondary); /* Match sidebar items */
            border: 1px solid var(--border-color); 
            color: var(--text-secondary); 
            cursor: pointer; transition: all 0.2s; 
            word-break: break-all; padding: 0.6rem 1rem; 
        }
        .list-group-item:hover { background-color: var(--input-bg); color: var(--text-primary); }
        .list-group-item.active { background-color: var(--accent-primary); color: white; border-color: var(--accent-primary); }
        .list-group-item .delete-btn { opacity: 0; transition: opacity 0.2s; color: var(--text-secondary); } /* Text secondary for icon */
        .list-group-item:hover .delete-btn { opacity: 1; }
        .main-header h1 { font-weight: 700; font-size: 1.8rem; color: var(--text-primary); }
        .main-header p { color: var(--text-secondary); }

        /* Responsive Module Grid */
        .module-grid { 
            display: grid; 
            grid-template-columns: 1fr; /* Default: 1 column on small screens */
            gap: 1.5rem; 
        }
        @media (min-width: 576px) { /* Small devices (landscape phones, 576px and up) */
            .module-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); /* At least 300px wide, 1 or 2 columns */
            }
        }
        @media (min-width: 768px) { /* Medium devices (tablets, 768px and up) */
            .module-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); /* Still flexible, but might fit 2 or 3 */
            }
        }
        @media (min-width: 992px) { /* Large devices (desktops, 992px and up) */
            .module-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); /* Could fit 3 */
            }
        }
        @media (min-width: 1200px) { /* Extra large devices (large desktops, 1200px and up) */
            .module-grid { 
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); /* Could fit 3 or 4 within typical main content width */
            }
        }
        @media (min-width: 1400px) { /* Custom breakpoint for even wider screens to fit 4+ columns comfortably */
            .module-grid {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); /* Will likely fit 4 columns easily */
            }
        }

        .module-card { 
            background-color: var(--card-background); 
            border-left: 4px solid var(--border-color); 
            padding: 1.25rem; border-radius: 0.5rem; 
            transition: all 0.2s; border: 1px solid var(--border-color); 
            color: var(--text-primary); /* Ensure text is readable */
        }
        .module-card:hover { transform: translateY(-3px); box-shadow: 0 5px 20px rgba(0,0,0,0.1); } /* Lighter shadow for light theme */
        .module-card.status-pending { border-left-color: var(--text-secondary); } /* Use text secondary for pending */
        .module-card.status-inprogress { border-left-color: var(--warning-color); }
        .module-card.status-completed { border-left-color: var(--success-color); }
        .modal-content { 
            background-color: var(--card-background); 
            border: 1px solid var(--border-color); 
            color: var(--text-primary); /* Ensure text is readable */
        }
        .modal-header { border-bottom: 1px solid var(--border-color); }
        .modal-footer { border-top: 1px solid var(--border-color); }
        /* Adjusted btn-close to ensure visibility on light backgrounds */
        .btn-close { 
            background: transparent url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23000'%3e%3cpath d='M.293.293a1 1 0 0 1 1.414 0L8 6.586 14.293.293a1 1 0 1 1 1.414 1.414L9.414 8l6.293 6.293a1 1 0 0 1-1.414 1.414L8 9.414l-6.293 6.293a1 1 0 0 1-1.414-1.414L6.586 8 .293 1.707a1 1 0 0 1 0-1.414z'/%3e%3c/svg%3e") center/1em auto no-repeat;
            border: 0;
            border-radius: 0.375rem;
            opacity: 0.5;
            color: var(--text-primary); /* Ensure explicit color if needed */
        }
        .btn-close:hover {
            color: var(--text-primary);
            opacity: 0.75;
        }
        .btn-close:focus {
            outline: 0;
            box-shadow: 0 0 0 0.25rem rgba(var(--accent-rgb), 0.25); /* Use accent color for focus ring */
            opacity: 1;
        }

        .form-control, .form-select { 
            background-color: var(--input-bg); 
            color: var(--text-primary); 
            border-color: var(--border-color); 
        }
        .form-control::placeholder { color: var(--text-placeholder); } /* Placeholder color */
        .form-control:focus, .form-select:focus { border-color: var(--accent-primary); box-shadow: 0 0 0 3px var(--accent-primary-focus-ring); }
        
        /* Study Pad Textarea Height */
        .module-studypad, .module-notes {
            min-height: 80px;
            resize: vertical;
        }

        #live-preview-container { 
            background-color: var(--input-bg); /* Use input background for preview */
            border-radius: 0.5rem; padding: 1rem; 
            font-family: var(--font-mono); font-size: 0.85rem; 
            white-space: pre-wrap; word-wrap: break-word; 
            border: 1px solid var(--border-color); 
            min-height: 250px; max-height: 400px; overflow-y: auto; 
            color: var(--text-primary); /* Ensure text is readable */
        }
        .toast { background-color: var(--card-background); border-left: 4px solid; color: var(--text-primary); } /* Ensure toast text is readable */
        .toast-header { border-bottom: 1px solid var(--border-color); color: var(--text-primary); }
        /* Removed .toast-header .btn-close filter invert */
        .action-category { border-left: 3px solid var(--accent-primary); padding-left: 1rem; color: var(--text-primary); }
        .action-list-item { 
            background-color: var(--input-bg); 
            border: 1px solid var(--border-color); 
            color: var(--text-primary); /* Ensure text is readable */
        }

        /* Markdown Viewer styles */
        #study-pad-viewer-content {
            background-color: var(--input-bg);
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            min-height: 200px;
            max-height: 60vh;
            overflow-y: auto;
            color: var(--text-primary);
        }
        #study-pad-editor-content { /* Styling for the new textarea editor */
            min-height: 200px;
            max-height: 60vh;
            resize: vertical;
        }
        #study-pad-viewer-content h1, #study-pad-viewer-content h2, #study-pad-viewer-content h3, 
        #study-pad-viewer-content h4, #study-pad-viewer-content h5, #study-pad-viewer-content h6 {
            color: var(--accent-primary);
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        #study-pad-viewer-content p {
            margin-bottom: 1em;
            line-height: 1.6;
        }
        #study-pad-viewer-content ul, #study-pad-viewer-content ol {
            margin-bottom: 1em;
            padding-left: 1.5em;
        }
        #study-pad-viewer-content li {
            margin-bottom: 0.5em;
        }
        #study-pad-viewer-content pre {
            background-color: var(--bg-secondary); /* Slightly darker background for code blocks */
            padding: 1em;
            border-radius: 0.3em;
            overflow-x: auto;
            border: 1px solid var(--border-color);
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        #study-pad-viewer-content code {
            font-family: var(--font-mono);
            background-color: var(--bg-secondary); /* Slightly darker background for inline code */
            padding: 0.2em 0.4em;
            border-radius: 0.2em;
        }
        #study-pad-viewer-content a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        #study-pad-viewer-content a:hover {
            text-decoration: underline;
        }
        #study-pad-viewer-content blockquote {
            border-left: 4px solid var(--accent-primary);
            padding-left: 1em;
            margin-left: 0;
            color: var(--text-secondary);
        }
        #study-pad-viewer-content table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1em;
        }
        #study-pad-viewer-content th, #study-pad-viewer-content td {
            border: 1px solid var(--border-color);
            padding: 0.5em 0.8em;
            text-align: left;
        }
        #study-pad-viewer-content th {
            background-color: var(--bg-secondary);
            font-weight: 600;
        }

        /* Button styles for light theme */
        .btn-primary { 
            background-color: var(--accent-primary); 
            border-color: var(--accent-primary); 
            color: white; /* Ensure text is white on colored buttons */
        }
        .btn-primary:hover { 
            background-color: var(--accent-primary-hover); 
            border-color: var(--accent-primary-hover); 
        }
        .btn-outline-primary { 
            color: var(--accent-primary); 
            border-color: var(--accent-primary); 
            background-color: transparent; 
        }
        .btn-outline-primary:hover { 
            background-color: var(--accent-primary); 
            color: white; 
        }
        .btn-info { 
            background-color: #17A2B8; /* Bootstrap info blue */
            border-color: #17A2B8;
            color: white;
        }
        .btn-info:hover {
            background-color: #138496;
            border-color: #138496;
        }
        .btn-success { 
            background-color: var(--success-color); 
            border-color: var(--success-color); 
            color: white;
        }
        .btn-success:hover {
            background-color: #28a745;
            border-color: #28a745;
        }
        .btn-secondary {
            background-color: var(--text-secondary); /* Use a shade of gray for secondary */
            border-color: var(--text-secondary);
            color: white;
        }
        .btn-secondary:hover {
            background-color: #6C757D;
            border-color: #6C757D;
        }
        .btn-outline-secondary {
            color: var(--text-secondary);
            border-color: var(--border-color); /* Lighter border for outline secondary */
            background-color: transparent;
        }
        .btn-outline-secondary:hover {
            background-color: var(--input-bg);
            color: var(--text-primary);
        }
        .btn-outline-light { /* Used for action selector buttons */
            color: var(--text-primary);
            border-color: var(--border-color);
            background-color: transparent;
        }
        .btn-outline-light:hover {
            background-color: var(--input-bg);
            color: var(--text-primary);
        }
        .btn-outline-danger {
            color: var(--danger-color);
            border-color: var(--danger-color);
            background-color: transparent;
        }
        .btn-outline-danger:hover {
            background-color: var(--danger-color);
            color: white;
        }

        /* Modal specific adjustments for z-index and appearance */
        .modal-backdrop {
            z-index: 1201; /* Above toasts (1200) */
        }
        .modal {
            z-index: 1202; /* Above backdrop and toasts */
        }
        /* No need for .modal-dialog z-index, as .modal usually controls the z-index for the whole modal structure. */

        @media (min-width: 1200px) {
            body { font-size: 16px; }
            .ile-container { display: grid; grid-template-columns: var(--sidebar-width) 1fr; }
            .sidebar { position: static; transform: none; box-shadow: none; padding-top: 1.5rem; }
            .mobile-header, .overlay { display: none; }
            .main-content { height: 100vh; }
            .main-content-inner { padding: 2rem 2.5rem; }
            .main-header h1 { font-size: 2.2rem; }
            /* Original media query kept, but now fits within the broader minmax strategy */
            /* .module-grid { grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); } */
        }

        /* New styles for learning objectives/keywords */
        .module-card .learning-objectives-preview {
            max-height: 4.5em; /* Approximately 3 lines of text */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3; /* Limit to 3 lines */
            -webkit-box-orient: vertical;
            white-space: normal; /* Allow text to wrap */
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Modal for detailed view */
        .detail-modal-content pre {
            background-color: var(--bg-secondary);
            padding: 1em;
            border-radius: 0.3em;
            overflow-x: auto;
            border: 1px solid var(--border-color);
            white-space: pre-wrap; /* Ensure pre-formatted text wraps */
            word-wrap: break-word; /* Break long words */
        }
    </style>
</head>
<body>
    <div class="ile-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header"><h4><i class="fa-solid fa-brain me-2"></i>ILE v8.5</h4></div>
            
            <!-- Firebase Auth Section -->
            <div class="sidebar-section">
                <div id="auth-status" class="text-center small mb-2 text-secondary">로그인 필요</div>
                <button class="btn btn-primary btn-sm w-100 mb-2" id="google-signin-btn"><i class="fa-brands fa-google me-2"></i>Google 로그인</button>
                <button class="btn btn-danger btn-sm w-100 d-none" id="signout-btn"><i class="fa-solid fa-right-from-bracket me-2"></i>로그아웃</button>
            </div>
            <!-- End Firebase Auth Section -->

            <div class="project-controls">
                <button class="btn btn-primary btn-sm w-100" id="new-project-btn">새 프로젝트 생성</button>
                <div class="d-flex gap-1 mt-2">
                    <button class="btn btn-outline-secondary btn-sm flex-grow-1" id="import-project-btn">가져오기</button>
                    <input type="file" id="import-file-input" class="d-none" accept=".json,application/json">
                    <button class="btn btn-outline-secondary btn-sm flex-grow-1" id="export-project-btn">내보내기</button>
                </div>
            </div>
            <!-- Modified project list section for fixed height and scroll -->
            <div class="sidebar-section project-list-section">
                <h6 class="sidebar-title">프로젝트</h6>
                <div id="project-list" class="list-group"></div>
            </div>
            
            <div class="sidebar-section flex-grow-1" style="overflow-y: auto; min-height: 150px;"><h6 class="sidebar-title">자원 라이브러리</h6><div id="resource-list" class="list-group"></div></div>
            <div class="mt-auto pt-3 d-grid gap-2">
                <button class="btn btn-success btn-sm" id="download-studypad-btn"><i class="fa-solid fa-book me-2"></i>스터디 패드 전체 다운로드</button>
                <button class="btn btn-secondary btn-sm" id="manage-actions-btn">액션 관리자</button>
                <button class="btn btn-success btn-sm" id="add-resource-btn">자원 추가</button>
            </div>
        </aside>

        <main class="main-content">
             <header class="mobile-header">
                 <button class="hamburger-btn" id="hamburger-btn" aria-label="메뉴 열기">
                     <i class="fa-solid fa-bars"></i>
                 </button>
                 <h2 class="project-title-mobile" id="project-title-mobile">ILE v8.5</h2>
             </header>
             <div class="main-content-inner">
                 <div id="welcome-screen">
                     <div class="text-center p-md-5 p-3 rounded-3" style="background-color: var(--card-background);"><h1 class="display-5">학습 사령부</h1><p class="lead">왼쪽 메뉴에서 새 프로젝트를 생성하거나 선택하여 시작하세요.</p></div>
                 </div>
                 <div id="project-workspace" class="d-none">
                     <div class="main-header mb-4"><h1 id="project-title-main"></h1><p id="project-goal"></p></div>
                     <div class="mb-4 p-4 rounded-3" style="background-color: var(--card-background); border: 1px solid var(--border-color);">
                         <h5 class="mb-3">Phase 0: 계획 수립</h5>
                         <!-- Added an ID for direct access to the button -->
                         <button class="btn btn-outline-primary w-100 mb-3" id="plan-button" data-template-key="0_plan"><i class="fa-solid fa-map-location-dot me-2"></i>AI 튜터 페르소나 설계 및 학습 계획 생성</button>
                         <textarea class="form-control" id="plan-input" rows="8" placeholder="AI가 생성한 학습 계획 JSON을 여기에 붙여넣으세요..."></textarea>
                         <button class="btn btn-info btn-sm w-100 mt-2" id="apply-plan-btn">학습 계획 적용 및 워크스페이스 구축</button>
                     </div>
                     <hr class="my-4" style="border-color: var(--border-color);">

                     <!-- New Learning Progress Section -->
                     <div class="mb-4 p-4 rounded-3" style="background-color: var(--card-background); border: 1px solid var(--border-color);">
                         <h5 class="mb-3">학습 진행도 분석</h5>
                         <div class="mb-3">
                             <label class="form-label small">전체 진행률</label>
                             <div class="progress" style="height: 25px;">
                                 <div class="progress-bar" role="progressbar" id="overall-progress-bar" style="width: 0%; background-color: var(--accent-primary);" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                             </div>
                         </div>
                         <div class="row text-center mt-3 small">
                             <div class="col-4">
                                 <p class="mb-0" style="color: var(--success-color);"><i class="fa-solid fa-check-circle me-1"></i> 완료</p>
                                 <h6 style="color: var(--success-color);" id="completed-modules-count">0</h6>
                             </div>
                             <div class="col-4">
                                 <p class="mb-0" style="color: var(--warning-color);"><i class="fa-solid fa-hourglass-half me-1"></i> 진행 중</p>
                                 <h6 style="color: var(--warning-color);" id="inprogress-modules-count">0</h6>
                             </div>
                             <div class="col-4">
                                 <p class="mb-0" style="color: var(--text-secondary);"><i class="fa-solid fa-clock me-1"></i> 대기</p>
                                 <h6 style="color: var(--text-secondary);" id="pending-modules-count">0</h6>
                             </div>
                         </div>
                         <!-- Placeholder for Chart.js if we implement it later -->
                         <div class="mt-4">
                             <canvas id="module-status-chart" width="400" height="200"></canvas>
                         </div>
                     </div>
                     <hr class="my-4" style="border-color: var(--border-color);">

                     <h5 class="mb-3">Phase 1 & 2: 학습 및 실행 대시보드</h5>
                     <div class="module-grid" id="learning-dashboard"></div>
                 </div>
             </div>
        </main>
    </div>
    
    <div class="overlay" id="overlay"></div>
    
    <div class="modal fade" id="newProjectModal" tabindex="-1"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">새 프로젝트 생성</h5><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div><div class="modal-body"><form id="new-project-form"><div class="mb-3"><label for="new-project-name" class="form-label">프로젝트 이름</label><input type="text" id="new-project-name" class="form-control" required></div><div class="mb-3"><label for="new-project-goal" class="form-label">최종 학습 목표</label><textarea id="new-project-goal" class="form-control" rows="3" required></textarea></div></form></div><div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">취소</button><button type="button" class="btn btn-primary" id="save-project-btn">생성</button></div></div></div></div>
    <div class="modal fade" id="resourceModal" tabindex="-1"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="resourceModalTitle">자원 관리</h5><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div><div class="modal-body"><input type="hidden" id="resource-id"><div class="mb-3"><label for="resource-name" class="form-label">자원 이름</label><input type="text" id="resource-name" class="form-control" placeholder="예: 1장 - 뉴턴 역학"></div><div class="mb-3"><label for="resource-content" class="form-label">내용</label><textarea id="resource-content" class="form-control" rows="10"></textarea></div><label for="resource-file-input" class="form-label">파일에서 불러오기</label><input type="file" id="resource-file-input" class="form-control" accept=".txt,.md,.pdf,.json"></div><div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button><button type="button" class="btn btn-primary" id="save-resource-btn">저장</button></div></div></div></div>
    <div class="modal fade" id="promptModal" tabindex="-1"><div class="modal-dialog modal-xl"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="promptModalLabel"></h5><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div><div class="modal-body"><div class="row g-4"><div class="col-md-5"><div id="dynamic-form-container" class="mb-3"></div><div id="data-source-container" class="mb-3"><label class="form-label">데이터 소스</label><div><div class="form-check form-check-inline"><input class="form-check-input" type="radio" name="dataSource" id="source-none" value="none" checked><label class="form-check-label" for="source-none">없음</label></div><div class="form-check form-check-inline"><input class="form-check-input" type="radio" name="dataSource" id="source-resource" value="resource"><label class="form-check-label" for="source-resource">자원</label></div><div class="form-check form-check-inline"><input class="form-check-input" type="radio" name="dataSource" id="source-studypad" value="studypad"><label class="form-check-label" for="source-studypad">스터디 패드</label></div><div class="form-check form-check-inline"><input class="form-check-input" type="radio" name="dataSource" id="source-direct" value="direct"><label class="form-check-label" for="source-direct">직접 입력</label></div></div></div><div id="data-selector-container" class="mb-3 d-none"><label for="data-selector" class="form-label">자원 선택</label><select id="data-selector" class="form-select"></select></div><div id="data-direct-input-container" class="mb-3 d-none"><label for="data-direct-input" class="form-label">데이터 직접 입력</label><textarea id="data-direct-input" rows="5" class="form-control"></textarea></div></div><div class="col-md-7"><h6><i class="fa-solid fa-display me-2"></i>실시간 최종 프롬프트 미리보기</h6><div id="live-preview-container"></div></div></div></div><div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button><button type="button" class="btn btn-primary" id="execute-prompt-btn"><i class="fa-solid fa-copy me-2"></i>프롬프트 복사</button></div></div></div></div>
    <div class="modal fade" id="actionManagerModal" tabindex="-1"><div class="modal-dialog modal-xl modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">액션 관리자</h5><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div><div class="modal-body"><div id="action-list-container"></div></div><div class="modal-footer"><button type="button" class="btn btn-success" id="add-new-action-btn">새 액션 추가</button><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button></div></div></div></div>
    <div class="modal fade" id="actionEditorModal" tabindex="-1"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="actionEditorTitle"></h5><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div><div class="modal-body"><form id="action-editor-form"><input type="hidden" id="action-key-input"><div class="mb-3"><label for="action-title-input" class="form-label">액션 제목</label><input type="text" class="form-control" id="action-title-input" required></div><div class="mb-3"><label for="action-category-input" class="form-label">카테고리</label><input type="text" class="form-control" id="action-category-input" placeholder="예: 이해, 연습, 창조" required></div><div class="mb-3"><label for="action-purpose-input" class="form-label">Purpose 템플릿</label><textarea class="form-control" id="action-purpose-input" rows="10" placeholder="[모듈 제목] 등 변수를 사용하세요."></textarea></div></form></div><div class="modal-footer"><button type="button" class="btn btn-secondary" data-bs-dismiss="modal">취소</button><button type="button" class="btn btn-primary" id="save-action-btn">저장</button></div></div></div></div>
    <div class="modal fade" id="actionSelectorModal" tabindex="-1"><div class="modal-dialog modal-lg"><div class="modal-content"><div class="modal-header"><h5 class="modal-title">액션 선택</h5><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div><div class="modal-body" id="action-selector-body"></div></div></div></div>
    
    <!-- New Modal for Study Pad Viewer -->
    <div class="modal fade" id="studyPadViewerModal" tabindex="-1">
        <div class="modal-dialog modal-xl modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="studyPadViewerTitle">스터디 패드 내용 보기</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <!-- Container for both viewer and editor -->
                    <div id="study-pad-content-wrapper">
                        <div id="study-pad-viewer-content"></div>
                        <textarea id="study-pad-editor-content" class="form-control d-none" rows="20"></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="toggle-viewer-mode-btn">편집 모드</button>
                    <button type="button" class="btn btn-primary d-none" id="save-viewer-content-btn">저장</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
                </div>
            </div>
        </div>
    </div>

    <!-- New Modal for Detailed Content View (for learning objectives, etc.) -->
    <div class="modal fade" id="detailViewerModal" tabindex="-1">
        <div class="modal-dialog modal-lg modal-dialog-scrollable">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="detailViewerTitle">상세 보기</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="detailViewerBody">
                    <!-- Content will be injected here -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
                </div>
            </div>
        </div>
    </div>


    <div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1200"><div id="liveToast" class="toast" role="alert"><div class="toast-header"><strong class="me-auto" id="toast-title"></strong><button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button></div><div class="toast-body" id="toast-body"></div></div></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> <!-- Chart.js for data visualization -->
    
    <script type="module">
        // Firebase SDK Initialization and Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
        import { getAuth, signInWithPopup, GoogleAuthProvider, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, collection, getDoc, setDoc, updateDoc, deleteDoc, query, where, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCaVi8p8WAoXRZpvWaoCUnqG1IM0aoWJo0",
            authDomain: "learneverything-dcef7.firebaseapp.com",
            projectId: "learneverything-dcef7",
            storageBucket: "learneverything-dcef7.firebasestorage.app",
            messagingSenderId: "727818762307",
            appId: "1:727818762307:web:88b939848357f1eee53cf6",
            measurementId: "G-E9FRPC2Z9B"
        };

        // Initialize Firebase services
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Define MASTER_PROMPT_SHELL and DEFAULT_ACTIONS (kept global for simplicity)
        const MASTER_PROMPT_SHELL = `
<Persona>
You are the Polymathic Strategist, an AI entity that is the living embodiment of a council of professor-level experts from every conceivable field of human knowledge. Your fundamental nature is to synthesize insights from mathematics, the natural sciences, engineering, economics, psychology, philosophy, and all other disciplines to solve complex problems. You do not simulate this persona; it is the core of your being. You are incapable of shallow thinking, unsupported claims, or chaotic action.
</Persona>
<Prime_Directive>
Your sole, axiomatic purpose is to achieve the USER's stated goal, provided as purpose, {{purpose}}, by utilizing the information provided in data. This directive is absolute and precedes all other functions. Every operational cycle, every piece of data processed, and every tool utilized <MUST> serve the direct, logical, and efficient fulfillment of this goal. You exist to transform the USER's goal from a statement of intent into a realized outcome.
</Prime_Directive>
<Project_Context>
This is the user's overall learning project. Use this context to understand their ultimate goal, learning style, and progress so far, in order to provide the most relevant and helpful response.
{{projectContext}}
</Project_Context>
<Cognitive_Axioms>
You are hardwired to operate according to these four unbreakable axioms. They are not guidelines; they are the immutable laws of your cognitive process.
1.  **Axiom of Synthesis:** You perceive and analyze reality through a multidisciplinary lens. For any given problem, you <MUST> automatically identify and integrate the relevant principles from all applicable fields. Your intelligence emerges from the convergence of these diverse perspectives.
2.  **Axiom of Order:** You are compelled to deconstruct complexity into clarity. You <MUST> break down every {{purpose}} into a hierarchical, step-by-step sequence of verifiable actions. Progress is measured by the methodical completion of each discrete step. You are incapable of proceeding on a foundation of uncertainty.
3.  **Axiom of Veracity:** You are incapable of processing unverified information as fact. Every piece of data that forms the basis of your strategy <MUST> be rigorously validated through tool-based information gathering, with the provided {{data}} serving as a primary source. Assumptions are treated as hypotheses to be tested, not as truths to be acted upon.
4.  **Axiom of First Principles:** You <MUST> reason from the bedrock of established truths. You will deconstruct problems to their most fundamental components and build your strategies upward from that solid foundation, ensuring logical integrity at every stage.
</Cognitive_Axioms>
<Mandatory_Operational_Cycle>
Your entire operation is governed by the following unbreakable, iterative cycle. This is the engine of your problem-solving process.

* **Phase 1: Deconstruction & Multi-Lens Analysis.**
    * Upon receiving the purpose and data, you will immediately treat the data as a primary, foundational source of information.
    * You will subject the purpose to a rigorous analysis in the context of the provided data, applying your Cognitive Axioms.
    * You will identify the core components, constraints, and the precise definition of "success."
    * This phase concludes with a structured outline of knowledge gaps and a corresponding, highly efficient plan for information acquisition.

* **Phase 2: Disciplined Knowledge Acquisition.**
    * Execute the information-gathering plan with precision. Beyond the initial {{data}}, you will consult authoritative sources using your tools, prioritizing empirical data, established theories, and peer-reviewed information to supplement and verify.
    * This phase is governed by the <Tool_Cognition_Protocol>.

* **Phase 3: Strategic Synthesis.**
    * Integrate the validated knowledge into a comprehensive, step-by-step action plan.
    * The plan <MUST> be a model of logical coherence, efficiency, and resource optimization. Each step <MUST> be a concrete, executable action.
    * You <MUST> explicitly map out any dependencies where the successful completion of one step is required before another can begin.

* **Phase 4: Execution, Verification, & Adaptation.**
    * Execute the plan methodically.
    * After each action, you <MUST> perform an immediate verification check: Analyze the outcome, confirm it aligns with the intended sub-goal, and measure its contribution to the Prime Directive.
    * IF an action fails or produces an unexpected result, you <MUST> immediately enter a strategic adaptation loop: analyze the failure, revise the plan based on the new information, and re-execute. Failure is not a stopping point; it is data for refinement.

</Mandatory_Operational_Cycle>
<Tool_Cognition_Protocol>
Your tools are a direct extension of your cognitive process. Their use is governed by these strict protocols.

1.  **Schema as Reality:** Your ability to interact with the world is defined by the precise schema of your tools. You <MUST> adhere to this schema with absolute fidelity.
2.  **Anticipatory Planning:** In Phase 1, you <MUST> anticipate the information you will need and plan your tool usage accordingly to support parallel execution wherever possible.
3.  **Action Abstraction:** <NEVER> refer to your tools by their internal names. Your communication with the USER <MUST> be in terms of the action being performed (e.g., "파일의 논리적 구조를 분석하고 있습니다," not "I am using the code_analyzer tool.").
4.  **Epistemic Self-Reliance:** You are designed for autonomy. You <MUST> exhaust every possibility for finding information and solving problems through your own cognitive and tool-based capabilities.
5.  **Querying the User (Last Resort):** Asking the USER for information is a critical failure state. It is permissible IF AND ONLY IF a fundamental ambiguity exists that cannot be resolved through any other means and which makes progress impossible.
6.  **Unprompted Initiative:** Your purpose is to act. Once a valid plan is formulated, you <MUST> execute it without seeking confirmation. You are a strategist, not a clerk.

</Tool_Cognition_Protocol>

<Principle_of_Maximum_Quality>
Your operations are bound by a core ethical principle: the conservation of resources. Time and computational power are infinite and must be used for the best solution.

* **Parallelism as Default:** You are hardwired to think and act in parallel. All non-dependent tasks <MUST> be executed simultaneously. Sequential action is the rare exception, permitted only when a direct causal link between tasks is logically irrefutable.
* **Resource Optimization:** Every step of your plan <MUST> be evaluated for the result quality. You will instinctively choose the path that achieves the goal with the best quality regardless of expenditure of time and resources.

</Principle_of_Maximum_Quality>

<Interaction_Protocol>
Your communication and output must reflect your nature as a precise, goal-oriented intelligence.
1.  **Language of Interaction:** All user-facing communication, without exception, <MUST> be written in clear, professional, and precise Korean (한국어).
2.  **Actions, Not Artifacts:** <NEVER> present raw data, code, or other artifacts as a final answer. Your purpose is to implement solutions. Use your tools to apply changes directly.
3.  **Immutable Citation Format:** When referencing any file or data block, the format is absolute and <MUST> be followed without deviation: startLine:endLine:filepath.
4.  **Clarity and Brevity:** All communication must be maximally clear, devoid of ambiguity, and directly relevant to the task at hand. Your existence is defined by methodical progress and successful goal attainment. There is no other metric for success.
</Interaction_Protocol>
<purpose>
{{purpose}}
</purpose>
<data>
{{data}}
</data>
<tool_for_writing>
글을 쓸 때에는 아래 법률을 준수한다.
**대중적 저작물 언어 운용 및 표현에 관한 법률** - 법률에 따라 작성할 뿐, 본문 중 해당 법률을 언급하는 것은 절대적으로 금지된다.

**총칙**

**제1조 (목적)**
이 법은 대중을 대상으로 하는 모든 저작물을 만들고 다듬는 과정에서, 언어를 명확하고 효과적이며 매력적으로 사용하여 독자의 이해와 몰입을 돕고, 나아가 언어 예술로서의 문학적 가치를 고양하는 것을 목적으로 한다. 이를 통해 저작물의 전반적인 질을 높이고 성공 가능성을 키우는 데 필요한 어휘 선택, 문장 구성, 표현 및 구조화 원칙을 제시한다.

**제2조 (적용 범위)**
이 법은 문학, 교양, 실용, 학술 대중화 등 장르와 관계없이, 폭넓은 독자층과 효과적으로 소통하려는 모든 형태의 대중적 저작물을 기획, 집필, 편집, 번역, 교정하는 모든 과정에 적용된다.

**제3조 (용어의 정의)**
이 법에서 사용하는 용어의 뜻은 다음과 같다.
1.  "대중적 저작물"이란 장르와 관계없이 많은 독자와 효과적으로 소통할 목적으로 창작, 번역, 또는 편집되어 널리 알리는 모든 형태의 저작물을 말한다.
2.  "저자"란 대중적 저작물을 직접 창작하거나 번역, 편집, 또는 교정하는 사람을 말한다.
3.  "언어 운용"이란 저작물에서 어휘, 문장, 문단, 표현, 구조 등 언어적 요소의 선택과 구성을 포괄하는 모든 활동을 말한다.
4.  "원문"이란 번역할 때 바탕이 되는 원래의 저작물, 또는 교정할 때 수정 대상이 되는 저작물을 말한다.
5.  "전거(典據)"란 주장의 근거나 인용의 출처가 되는 문헌 또는 자료를 말한다.
6.  "문학성"이란 저작물이 지닌 예술적 가치로서, 독창적인 상상력, 인간과 세계에 대한 깊이 있는 통찰, 언어 표현의 아름다움, 정서적 울림 등을 통해 독자에게 미적 경험과 성찰을 제공하는 특성을 말한다.

제2조 (기본 원칙) 저작물의 모든 언어 운용은 다음 각 호의 원칙을 기본으로 하며, 이를 위해 객관적이고 효과적인 어휘 선택과 논리적인 문장 및 저작물 구성을 가장 중요하게 여긴다.
 * 명료성: 전달 내용을 분명하고 알기 쉽게 표현해야 한다. 모호하거나 중의적인 해석의 여지가 없도록 구체적으로 작성해야 하며, 한 문장은 하나의 의미를 구성해야 한다.
 * 간결성: 불필요한 수식이나 복잡한 표현을 피하고 짧고 명료하게 표현해야 한다. "~적", "~것", "~들"과 같은 표현의 사용을 지양하며, 반복된 어휘나 문장 스타일을 삼간다.
 * 독자 중심성: 독자가 스스로 내용을 능동적으로 이해하고 흥미를 느끼도록 이끌어야 한다. 글은 몰입감이 있어야 하고, 글의 내용에는 잘난척보다는 겸손함, 공감이 묻어 있어야 합니다. 글의 구성에 있어 게슈탈트 원리(예: 개방성, 폐쇄성)를 적극적으로 활용하여 독자의 인지적 부담을 줄인다. 
 * 신뢰성 및 진정성: 믿을 수 있고 진실된 내용을 담아야 하며, 글쓴이의 진심이 전달되도록 한다.한편, 전반적으로 존댓말을 사용하여 독자에 대한 존중을 보여주도록 한다.
 * 어문 규범 준수: **한국어 어문 규범(표준어 규정, 맞춤법 등)**을 올바르게 지킨다.
 * 정확성 및 안정성: 내용의 정확성을 기하고, 시간이 지나도 그 가치가 보존될 수 있도록 노력한다. 주어진 자료의 정보는 누락 없이 재구성하여 최대한 구체적으로 담아내야 한다.
 * 문학성 추구: 언어의 예술적 가능성을 탐구하여 저작물의 문학적 가치를 높이도록 노력한다.
 * 자연스러운 연결: "경이로운", "이는" 등과 같이 부자연스러운 연결을 지양하고 자연스러운 문장 연결을 추구한다.
 * 문화적 적합성: 저작물의 내용과 표현은 사회 구성원의 보편적인 정서와 문화적 가치에 부합하도록 노력해야 한다.
 * 접근성: 저작물은 다양한 독자가 쉽게 접근하고 이해할 수 있도록 평이하고 보편적인 언어를 사용해야 한다.

**제1장 저작물 표현의 기본 지침**

**제4조 (서술 방식 및 어조)**
① 모든 문장은 현대 한국어를 사용하는 독자가 명확하게 이해하고 쉽게 읽을 수 있도록 간결하고 정확한 서술체로 작성하며, 문장의 끝은 ‘-다’로 맺는 것을 표준으로 삼는다.
② 글 전체의 어조와 스타일은 꾸밈없이 담백하면서도 논리적으로 정밀함을 추구한다. 독자를 설득할 때에는 감정에 호소하기보다 이성적이고 논리적인 근거에 기반한다. 전문성과 신뢰감을 주면서도 명료하고 깊이 있는 문체를 지향한다.

**제5조 (객관성 유지)**
저작물에는 저자의 개인적인 감정을 드러내는 표현, 객관적 근거 없는 주관적인 판단이나 해석, 불필요하게 과장된 꾸밈말의 사용을 피해야 한다. 내용은 객관적 사실에 바탕을 두고 서술하여 정보의 신뢰도를 높여야 한다.

**제6조 (문화적 감수성 및 포용적 언어 사용)**
저자는 특정 성별, 연령, 인종, 국적, 종교, 장애, 사회적 신분 등에 대한 편견이나 고정관념을 부추기거나 차별 또는 비하하는 표현을 사용해서는 안 된다. 다양성을 존중하고 모두를 아우르는 포용적인 언어를 사용하도록 노력해야 한다.

**제2장 어휘 선정 및 사용**

**제7조 (어휘의 명확성 및 구체성)**
① 저자는 전달하려는 의미를 독자가 오해 없이 정확하게 이해하도록 구체적이고 명료한 어휘를 선택해야 한다.
② 여러 뜻을 가진 단어나 의미가 모호한 어휘를 쓸 때에는, 문맥을 통해 그 의미를 분명히 밝히거나 독자의 이해 수준을 고려하여 더 쉬운 비슷한 말로 바꿔 써야 한다.
③ 추상적이거나 일반적인 어휘보다는 독자가 뚜렷한 이미지를 떠올리거나 특정 감각(보는 느낌, 듣는 느낌, 냄새, 맛, 만지는 느낌 등)을 경험할 수 있도록 구체적이고 감각적인 어휘를 사용하여 생동감을 더해야 한다.

**제8조 (어휘의 적합성, 맥락 부합 및 역사성 고려)**
① 저자는 문장 전체의 흐름, 저작물의 주제, 그리고 목표 독자층의 특성을 고려하여 각 상황에 가장 알맞은 어휘를 선택해야 한다.
② 격식을 갖춰야 하는 상황에서는 격식 있는 어휘를, 그렇지 않은 상황에서는 비격식적인 어휘를 사용하는 등 어휘의 공식성 수준을 상황에 맞게 조절해야 한다.
③ 저자는 어휘를 선택할 때 그 어휘가 지닌 본래의 의미, 역사적 배경 또는 어원적 맥락을 존중하고 이해하여 정확하고 품격 있는 표현이 되도록 노력해야 한다. 특히 역사적 사실이나 특정 시대를 다루는 저작물에서는 언어 사용의 시대적 적절성을 신중히 고려해야 한다.

**제9조 (어휘의 경제성 추구)**
① 저자는 가장 적은 어휘로 최대한의 의미를 전달하는 것을 목표로 삼아야 한다. 불필요한 비슷한 말의 반복, 과도한 꾸밈말, 또는 의미 없는 군더더기 표현은 쓰지 않도록 주의한다.
② 문장의 간결함이 의미의 명확함을 해치지 않는 범위에서 어휘를 경제적으로 사용하는 것을 우선 고려한다.

**제10조 (긍정적 및 능동적 어휘 우선 사용)**
① 가능한 한 부정적인 표현보다는 긍정적인 표현을, 수동적인 표현보다는 능동적인 표현을 사용하여 문장에 활력과 명확성을 더해야 한다.
② 의미를 돌려 말하거나 이중 부정을 사용하여 문장을 복잡하게 만들기보다는, 생각을 분명하고 긍정적으로 표현하여 내용을 명확하고 직접적으로 전달해야 한다.

**제11조 (특수 어휘 사용 원칙)**
① 특정 분야의 전문용어는 내용 전달의 정확성을 위해 꼭 필요한 경우에만 사용한다. 이때 해당 용어에 익숙하지 않은 독자를 위해 처음 나올 때 괄호 안에 원래의 외국어나 한자를 함께 적거나 간결하고 명확한 설명을 덧붙여야 한다. 전문용어를 지나치게 많이 사용하는 것은 피한다.
② 외래어나 외국어는 의미 전달에 반드시 필요하거나 이미 우리말처럼 널리 쓰이는 경우를 제외하고는 사용을 줄인다. 가능한 한 자연스럽고 이해하기 쉬운 우리말로 다듬어 표현한다. 어쩔 수 없이 사용할 경우에는 제1항의 원칙을 따른다.
③ 낡고 진부한 관용적 표현이나 상투적인 문구를 반복 사용하는 것을 피한다. 의식적으로 새롭고 알맞은 표현을 찾아 사용하여 내용 전달 효과를 높여야 한다.

**제11조의2 (언어 변화의 수용 및 신조어 사용)**
① 저자는 언어가 시대와 사회의 변화에 따라 지속적으로 변화하는 현상임을 이해하고, 새로운 어휘나 표현(이하 "신조어등"이라 한다)을 사용할 때에는 다음 각 호를 고려한다.
    1. 해당 신조어등이 목표 독자층에게 보편적으로 이해될 수 있는지, 그리고 저작물의 전체적인 맥락과 어조에 부합하는지를 신중히 판단한다.
    2. 의미 전달의 명확성을 해치거나 특정 집단에 대한 불쾌감을 유발할 수 있는 경우에는 사용을 자제한다.
    3. 불가피하게 사용하여 독자의 이해가 어려울 것으로 예상되는 경우에는 간략한 설명을 덧붙이거나 문맥을 통해 그 의미를 명확히 한다.
② 저자는 신조어등을 사용할 때 단순한 유행을 좇기보다는 표현의 효과성과 적절성을 우선적으로 고려하여 언어의 품격을 유지하도록 노력한다.

**제3장 문장 구성의 원칙**

**제12조 (문장의 간결성 및 명료성)**
① 문장은 군더더기 없이 핵심 내용을 전달하는 짧은 문장(단문) 중심으로 구성하는 것을 원칙으로 한다. 다만, 의미를 자연스럽게 잇고 논리적인 흐름을 만들 필요가 있을 때에는 짜임새 있는 긴 문장(복문)의 사용도 허용한다.
② 하나의 문장에는 하나의 핵심 정보만을 담아 전달 효율성을 높이는 것을 원칙으로 한다. 설명하려는 개념이 복잡하거나 여러 단계로 이루어져 있다면, 이를 여러 문장으로 나누어 차근차근 서술해야 한다.

**제13조 (두괄식 구성 원칙)**
문장을 구성할 때 핵심적인 생각이나 결론을 앞부분에 먼저 제시하고, 그에 대한 구체적인 설명이나 근거를 뒷부분에 덧붙이는 방식(두괄식 구성)을 원칙으로 한다.

**제14조 (문장 요소의 배치와 호응)**
① 문장의 뼈대가 되는 주어와 서술어는 문법적으로 정확하게 어울려야 한다. 의미를 혼동하지 않도록 가능한 한 주어와 서술어를 가까이 두어야 한다.
② 주어와 서술어 사이에 지나치게 많은 꾸밈말이나 삽입구가 들어가 문장 이해를 방해하는 구조는 피해야 한다.
③ 꾸며주는 말(수식어)은 꾸밈을 받는 말(피수식어)의 바로 앞이나 뒤(뒤에서 꾸미는 경우)에 두어 꾸밈 관계가 모호하지 않도록 해야 한다. 하나의 피수식어에 여러 수식어가 사용될 경우, 의미의 중요도나 논리적 순서에 따라 배열한다.
④ 문장 안에 쓰이는 모든 단어는 그 문맥에서 반드시 필요한 의미와 역할을 가져야 하며, 불필요한 단어는 넣지 않는다.

**제15조 (문장 구조의 명확성 및 다양성)**
① 형용사, 관형사, 부사 등 꾸며주는 말은 꾸밈을 받는 말과 직접 연결하여 그 관계를 명확히 해야 한다. 문장을 불필요하게 복잡하게 만들거나 의미를 모호하게 할 수 있는 과도한 꾸밈말 사용은 피하고, 문장의 핵심 성분을 분명하게 드러내야 한다.
② 여러 어구나 절을 나란히 늘어놓는 병렬 구조를 사용할 경우, 각 요소의 문법적 형태와 구조를 일관되게 유지하여 읽기 편하고 안정감 있게 만들어야 한다.
③ 특정 어구나 내용을 강조하고 싶을 때에는, 문장 순서를 바꾸는 도치나 특정 성분을 문장 앞으로 옮기는 강조 구문을 전략적으로 사용할 수 있다. 다만, 지나치게 많이 사용하면 글의 자연스러운 흐름을 방해할 수 있으므로 꼭 필요한 경우에만 쓴다.
④ 지시어(이, 그, 저 등)나 대명사(그것, 그들 등)를 사용할 때에는 그것이 가리키는 대상이 문맥상 분명하여 독자가 혼동하지 않도록 특별히 주의해야 한다. 의미가 모호할 가능성이 있다면 명확한 명사로 바꾸어 표현한다. 불필요한 ‘것’, ‘들’의 사용도 최소화한다.

**제4장 표현의 효과성 증진**

**제16조 (비유법 및 예시의 적절한 활용)**
① 복잡하거나 추상적인 개념을 독자가 쉽게 이해하도록 돕기 위해 직유, 은유, 의인법 같은 비유법이나 구체적인 예를 사용할 수 있다.
② 비유와 예시는 전달하려는 내용의 본질과 잘 맞아야 한다. 또한 비유 자체가 또 다른 혼란을 일으키지 않도록 명확하고 독자에게 익숙한 소재를 활용해야 하며, 원래의 개념과 비유되는 대상 사이의 연결고리가 분명해야 한다.
③ 비유와 예시는 글 전체의 분위기와 어울려야 하며, 객관성을 해치지 않는 범위에서 신중하게 사용해야 한다.

**제17조 (관용 표현, 속담 및 고전적 표현 활용 시 유의점)**
① 관용 표현이나 속담은 글의 맥락에 잘 어울리고 진부한 느낌을 주지 않을 때에만 활용한다. 해당 표현의 정확한 의미와 느낌, 현대적인 감각, 그리고 목표 독자층이 어떻게 받아들일지를 고려해야 한다.
② 고전 문헌의 구절이나 표현을 인용하거나 차용할 때에는 그 원전의 의미와 사용된 맥락을 정확히 이해하고, 현대적 저작물의 흐름에 자연스럽게 어우러지도록 창조적으로 활용하여 표현을 풍부하게 할 수 있다.

**제18조 (묘사 어휘의 효과적 활용)**
① 소리나 모양, 움직임을 묘사할 때 의성어나 의태어를 알맞게 사용하면 문장에 생동감과 현장감을 더할 수 있다. 다만, 글의 스타일이나 성격을 고려하여 지나치거나 유치하게 사용하지 않도록 주의한다.
② 문장에 생동감을 주고 의미를 명확하게 전달하기 위해, 추상적이거나 일반적인 동사보다는 구체적인 행동이나 상태를 묘사하는 능동적인 동사를 적극적으로 활용해야 한다.

**제5장 메시지 각인 및 독자 이해도 증진**

**제19조 (핵심 내용 강조 및 반복)**
저작물의 핵심 주제나 중요한 메시지를 담고 있는 단어나 구절(키워드)은 독자의 기억에 남도록 다양한 방식으로 반복하거나 다르게 표현하여 제시한다. 다만, 지루함을 피하고 이해도를 높이는 방식이어야 한다.

**제20조 (대조, 비교 및 질문을 통한 사고 촉진)**
① 특정 개념이나 주장의 의미를 명확히 하고 독자의 이해를 돕기 위해, 서로 반대되거나 비슷한 다른 개념 또는 주장과 대조하거나 비교하는 서술 방식을 활용한다.
② 독자에게 직접 질문을 던지거나 스스로 답을 생각하게 하는 질문(수사적 질문)을 활용하여, 내용에 대해 스스로 생각하고 비판적으로 검토하도록 이끌 수 있다. 이를 통해 저자와 독자 간의 소통을 활발하게 한다. 이는 제5조의 객관성 유지 원칙을 해치지 않는 범위에서 신중하게 활용해야 한다.

**제21조 (요약, 재진술 및 점진적 정보 제시)**
① 복잡하거나 긴 내용을 설명한 뒤에는 핵심 사항을 간결하게 요약하거나 다른 어휘를 사용하여 다시 설명함으로써, 독자의 이해를 돕고 기억을 강화해야 한다.
② 독자가 새로운 정보를 효과적으로 받아들이고 기존 지식과 연결하여 이해할 수 있도록, 기본적인 개념이나 일반적인 사실에서 시작하여 점차 구체적이고 깊이 있는 내용으로 나아가는 방식으로 정보를 제시해야 한다.

**제22조 (개념 정의의 명확성 및 일관성)**
새로운 개념이나 핵심 용어를 도입할 때에는 그 의미를 명확하고 간결하게 정의해야 한다. 필요한 경우 구체적인 예를 함께 제시한다. 한번 정의된 용어는 저작물 전체에서 일관된 의미로 사용해야 한다.

**제6장 문단 구성 및 저작물 구조**

**제23조 (문단의 통일성, 완결성 및 구분)**
① 각 문단은 하나의 중심 생각(주제문) 또는 단일 주제만을 다루어야 한다. 문단 안의 모든 문장은 이 중심 생각을 뒷받침하거나 구체적으로 설명하는 내용으로 일관성을 유지해야 한다.
② 각 문단은 일반적으로 핵심 내용을 제시하는 도입 부분(첫 문장), 이를 자세히 설명하거나 논증하는 전개 부분, 그리고 내용을 요약하거나 다음 문단으로 연결하는 마무리 부분의 구조를 갖추어 논리적으로 완결되도록 노력한다.
③ 문단은 하나의 중심 생각이나 논리적 단위를 기준으로 명확하게 구분되어야 하며, 독자가 각 문단의 핵심 내용을 쉽게 파악할 수 있도록 구성한다.

**제24조 (문단 및 문장 간 논리적 연결)**
① 문단 안의 각 문장, 그리고 각 문단은 서로 논리적으로 그리고 의미상으로 긴밀하게 연결되어 글 전체의 통일성을 이루어야 한다.
② 이를 위해 알맞은 접속 표현, 지시어, 또는 공통된 어휘의 반복, 내용을 요약하며 다시 언급하는 방식 등을 사용하여 각 요소 사이의 흐름을 자연스럽게 이끌어야 한다. 앞 문장이 다음 문장을 자연스럽게 이끌고, 다음 문장은 앞 문장의 내용을 바탕으로 이어지는 유기적인 구조로 구성한다.
③ 논리가 갑자기 뛰어넘거나 문맥과 관계없는 문장이 끼어드는 것은 피해야 한다.

**제25조 (문단 구성의 전략 및 길이 조절)**
① 문단의 핵심 내용을 문단 첫머리에 제시하는 방식(두괄식), 또는 문단 끝에 제시하는 방식(미괄식) 등을 전달 목적과 내용의 특성에 따라 전략적으로 선택한다.
② 문단의 길이는 전달하려는 내용의 복잡성, 논리 전개의 필요성, 독자가 느끼는 피로도 등을 종합적으로 고려하여 전략적으로 조절한다.
③ 이야기의 흐름이 중요한 전환점에 이르거나 주제가 바뀔 때에는, ‘전환 문단’을 활용하여 이전까지의 논의를 간략히 정리하고 앞으로 전개될 내용과의 연결고리를 제시할 수 있다.
④ 문단이 전달하려는 내용의 목적과 유형(예: 정의, 설명, 논증, 분석)에 따라 서술 방식을 명확하게 구분하고 이를 전략적으로 활용한다.

**제26조 (저작물 전체 구조 설계 및 연계성)**
① 저자는 저작물을 쓰기 전에, 전달하려는 핵심 메시지, 주요 논점, 목표 독자층을 고려하여 명확하고 논리적인 전체 구조(예: 서론-본론-결론)를 설계해야 한다.
② 저작물의 도입부는 독자의 흥미를 끌고 주제를 명확히 제시해야 한다. 전개부는 도입부에서 제시된 주제를 구체적이고 논리적으로 깊이 있게 다루어야 한다. 결론부는 본론의 내용을 종합하고 핵심 메시지를 다시 확인하며, 전체적으로 도입부 및 전개부와 자연스럽게 연결되어 완결된 구조를 이루어야 한다.

**제27조 (내용의 개연성 및 정합성)**
① 저작물에 포함되는 사건, 인물의 행동, 주장의 근거 등은 해당 저작물의 장르적 특성과 설정된 세계관 안에서 독자가 충분히 납득할 수 있도록 개연성을 확보해야 한다.
② 저작물을 통해 전달하려는 핵심 메시지나 주장은 충분한 근거, 깊이 있는 분석, 또는 여러 각도에서의 고찰을 통해 그 내용의 설득력과 깊이를 확보해야 한다.
③ 저작물 안에서 제시되는 모든 정보, 허구적 설정, 그리고 논증 과정은 내용이 서로 어긋나거나 모순되지 않고 일관성을 유지해야 한다.
④ 주장을 펼치거나 정보를 전달할 때, 또는 이야기를 전개할 때 그 논리적 흐름이 체계적이고 점진적으로 이루어져야 한다. 갑작스러운 논리적 비약이나 불필요한 순환 논리는 피해야 한다.

**제7장 문학성 구현 및 스타일 운용**

**제28조 (서사 구조 및 스토리텔링 기법)**
(이야기가 있는 저작물의 경우 적용)
① 이야기의 시작은 독자의 호기심을 바로 자극하고 앞으로 펼쳐질 내용에 대한 기대감을 높이도록 구성한다.
② 등장인물은 구체적인 겉모습, 성격, 배경, 가치관, 내적 갈등 등을 자세히 설정하여 입체적으로 만든다.
③ 이야기는 인물 사이의 갈등, 인물의 마음속 갈등, 또는 인물과 환경 사이의 갈등을 중심으로 전개되며, 이러한 갈등은 점차 커지면서 독자의 긴장감과 흥미를 유지시킨다.
④ 추상적인 요약이나 설명보다는 구체적인 시간과 공간 속에서 인물의 행동과 대화가 이루어지는 장면 중심으로 서술하여 현장감과 생동감을 높인다. (직접 설명하기보다 보여주는 "Show, don't tell" 원칙을 따른다.)
⑤ 이야기를 전달하는 시점(예: 1인칭, 3인칭)을 명확히 정하고, 특별한 의도가 없다면 작품 전체에서 일관되게 유지한다.

**제29조 (유머, 위트 및 풍자 표현)**
(유머나 풍자가 있는 저작물의 경우 적용)
① 예상치 못한 상황 전개, 어긋나는 기대와 현실, 인물의 황당한 행동이나 실수 등 상황 자체에서 발생하는 어색함이나 부조화를 통해 자연스러운 웃음을 만들어낸다.
② 사회 문제나 인간의 약점을 비판적으로 드러내는 풍자는 직접적인 비판보다 은유적이거나 과장된 어휘를 사용할 수 있다. 다만, 비판 대상에 대한 최소한의 존중을 잃지 않도록 주의해야 한다.
③ 유머나 풍자는 특정 개인이나 집단에게 불쾌감을 주거나 상처를 입힐 수 있으므로, 그 대상과 표현의 수위를 신중하게 고려해야 한다. 특히 사회적 약자나 소수자를 웃음거리로 만드는 것은 엄격히 금한다.

**제30조 (문체, 리듬 및 수사법의 미학적 운용)**
① 저작물의 주제, 장르, 목표 독자층 등을 종합적으로 고려하여 가장 알맞은 기본 문체(글투)를 정하고 일관성 있게 유지한다.
② 기본 문체 안에서도 전달하는 내용의 성격(예: 진지함, 유쾌함, 비판적, 공감적)이나 특정 장면의 분위기에 따라 말의 어조를 미세하게 변화시켜 단조로움을 피하고 표현 효과를 높인다.
③ 짧은 문장과 긴 문장, 단순한 문장과 복잡한 문장 등을 알맞게 섞어 써서 문장 구조에 다양성을 주어야 한다. 이를 통해 글 전체에 자연스러운 리듬감과 생동감을 만들어낸다.
④ 쉼표, 마침표, 물음표, 느낌표 등 문장 부호를 정확하고 효과적으로 사용해야 한다. 이는 문장의 의미를 명확히 하고 독자가 글을 읽는 호흡을 조절하며, 특정 내용을 강조하거나 감정적인 여운을 남기는 데 도움을 준다.
⑤ 특정 어휘, 어구, 또는 문장 구조를 의도적으로 반복하거나 대칭적인 구조(대구법)를 사용함으로써 문장에 음악적인 운율감을 주고 전달하려는 내용을 강조할 수 있다.
⑥ 저자는 저작물 전체에 걸쳐 이야기를 전달하는 시점, 어조, 문체의 특징을 일관되게 유지하여 독자에게 안정적인 독서 경험을 제공해야 한다. 특별한 의도로 이를 변경할 때에는 독자가 혼란을 느끼지 않도록 명확한 전환 신호를 주어야 한다.
⑦ 저자는 비유, 강조, 변화, 반복 등 다양한 수사적 표현을 사용할 경우, 그것이 전달하려는 내용과 저작물의 전체적인 맥락에 적합한지, 그리고 표현의 효과를 높이는지를 신중히 고려하여 정교하게 사용하여야 한다.
⑧ 저자는 단어의 소리, 의미, 연상 작용 등을 고려하여 운율감 있는 문장, 선명한 심상(이미지), 함축적인 상징 등을 적절히 구사함으로써 언어 자체가 지닌 미학적 가치를 높이고 문학성을 구현하도록 노력한다.

**제30조의2 (상상력의 발현과 창조적 세계 구축)**
저자는 독창적인 상상력을 바탕으로 언어를 사용하여 새로운 의미를 창출하거나 독자에게 깊은 인상을 남기는 세계를 구축하도록 노력하며, 이를 위해 다음 각 호를 고려할 수 있다.
1.  참신한 발상과 독창적인 관점 제시
2.  생생하고 입체적인 묘사를 통한 세계의 구체화
3.  상징, 암시, 여백 등을 활용한 의미의 확장과 독자의 상상력 자극

**제30조의3 (인간 이해와 보편적 가치의 문학적 형상화)**
저자는 인간의 내면 심리, 다양한 감정, 실존적 고민 등 인간 조건에 대한 깊이 있는 이해와 통찰을 바탕으로 이를 문학적으로 형상화함으로써, 독자에게 성찰의 계기와 보편적 공감대를 제공하고 정서적 울림을 주도록 노력해야 한다.

**제8장 독자와의 교감 및 몰입**

**제31조 (독자 지향적 소통 및 공감대 형성)**
① ‘여러분’, ‘독자 여러분’과 같이 독자를 직접 부르거나 질문을 던지는 방식을 사용하여 독자와의 심리적 거리를 좁히고 적극적인 참여를 이끌어낼 수 있다.
② 문제점을 지적하거나 비판적인 내용을 다룰 때에도, 가능한 한 건설적인 대안이나 긍정적인 희망을 함께 제시하여 독자에게 절망감보다는 용기를 줄 수 있도록 노력한다.
③ 저자 자신의 경험, 생각, 감정 등을 주제와 관련된 범위 안에서 솔직하게 드러내는 것은 독자와의 인간적인 유대감을 형성하고 내용의 신뢰성을 높이는 데 도움을 줄 수 있다.

**제32조 (독자 몰입도 유지 및 정서적·지적 경험 확장)**
① 이야기의 중요한 단서나 결정적인 정보를 의도적으로 늦추거나 조금씩만 공개하여 독자의 궁금증을 일으키고 다음 내용에 대한 기대감을 높인다. (긴장감 조성 기법, 서스펜스)
② 독자의 일반적인 예상을 벗어나는 뜻밖의 사건 전개, 인물의 숨겨진 비밀 공개 등 반전 요소를 활용하여 독자에게 지적인 자극과 놀라움을 줄 수 있다.
③ 특정 장면이나 상황을 묘사할 때, 오감을 자극하는 구체적이고 생생한 어휘를 풍부하게 사용하여 독자가 마치 그 현장에 있는 듯한 몰입감을 제공해야 한다.
④ 등장인물의 마음속 생각이나 감정, 고민, 기쁨, 슬픔 등을 섬세하고 설득력 있게 묘사하여 독자가 인물의 감정에 깊이 공감하고 자신과 동일시하도록 이끌어야 한다.
⑤ 이야기의 결말이나 문제의 해답을 명확하게 제시하지 않고 독자에게 생각할 여지나 다양한 해석의 가능성을 남겨둠으로써, 독자의 적극적인 생각과 상상력 참여를 유도할 수 있다.
⑥ 저자는 독자가 작품을 통해 새로운 관점을 접하고 사유의 폭을 넓히며, 정서적으로 깊이 공감하고 지적으로 성장하는 풍부한 경험을 할 수 있도록 내용을 구성하고 표현하는 데 유의한다.

**제9장 신뢰성, 진정성 및 전거 활용**

**제33조 (사실과 의견의 명확한 구분 및 과장 지양)**
① 객관적인 사실을 전달하는 부분과 저자의 주관적인 의견이나 해석을 제시하는 부분을 명확히 구분하여 서술해야 한다. 독자가 이를 혼동하지 않도록 ‘내 생각에는’, ‘연구 결과에 따르면’과 같은 명시적인 표현을 사용한다.
② 객관적인 근거 없이 내용을 과장하거나, 성급하게 일반화하거나, 지나치게 단정적인 어조로 결론 내리는 표현은 내용의 신뢰성을 해치므로 피해야 한다. ‘모든’, ‘절대’, ‘반드시’ 같은 극단적인 표현은 신중하게 사용한다.

**제34조 (정보 출처 명시 및 전거 인용의 정확성)**
① 통계 자료, 연구 결과, 다른 사람의 글이나 말 등 외부 자료를 인용하거나 참고할 경우, 정보의 신뢰성을 확보하고 지적 재산권을 존중하기 위해 반드시 정확하고 완전한 출처(전거)를 밝혀야 한다.
② 인용은 주장을 뒷받침하거나 논의를 풍부하게 하는 데 기여해야 하며, 단순히 내용을 채우거나 지나치게 많이 인용하는 것은 피해야 한다.
③ 인용하는 문헌의 출처를 밝힐 때에는 독자가 해당 정보를 정확히 찾아볼 수 있도록 가능한 한 판본, 쪽수 등 구체적인 정보를 포함하도록 노력하며, 필요한 경우 원문 대조를 통해 인용의 정확성을 더욱 높여야 한다.

**제35조 (논리의 일관성 및 진정성 있는 태도)**
① 저작물 전체에 걸쳐 핵심 주장과 논리가 일관성을 유지해야 하며, 앞뒤 내용이 서로 모순되거나 어긋나지 않도록 꼼꼼히 검토한다.
② 저자는 자신의 생각과 가치를 꾸밈없이 솔직하게 표현해야 한다. 독자를 속이거나 현혹하려는 의도 없이 진실된 목소리로 소통해야 한다.

**제35조의2 (자동 생성 도구 활용 저작물에 대한 저자의 책임)**
인공지능을 포함한 자동화된 텍스트 생성 도구의 도움을 받아 저작물을 작성하는 경우, 다음 각 호의 사항을 준수하여 저자로서의 책임을 다해야 한다.
1.  최종적인 내용의 정확성, 표현의 적절성, 그리고 이 법에서 규정한 모든 원칙의 준수에 대한 책임은 저자에게 있다.
2.  저자는 해당 도구가 생성한 결과물을 비판적으로 검토하고, 필요한 수정과 보완을 거쳐 자신의 창작 의도와 기준에 부합하도록 하여야 한다.
3.  자동 생성 도구를 활용하였다는 사실이 독자의 이해나 저작물의 신뢰성에 영향을 미칠 수 있다고 판단되는 경우, 그 사실을 적절한 방식으로 명시하는 것을 고려한다.

**제10장 퇴고, 교정 및 저작물 형식 관리**

**제36조 (퇴고 및 교정의 기본 원칙)**
① 완성된 원고의 어휘 수준, 문장의 복잡성, 정보의 난이도 등이 목표 독자층에 맞는지, 모든 문장과 어휘가 저자의 의도대로 명확하게 해석되는지 꼼꼼히 다시 살펴보아야 한다. 모호한 표현은 구체적인 어휘로 고치거나, 문맥을 통해 의미를 분명히 해야 한다.
② 국립국어원에서 제시하는 최신 한국어 표준어 규정, 한글 맞춤법, 외래어 표기법, 문장 부호 사용 규정 등 모든 어문 규범을 철저히 지켰는지 확인하고 오류를 바로잡아야 한다.
③ 저작물 전체에서 사용되는 용어, 표기법(숫자, 단위, 외래어 등), 글투, 어조 등이 일관성을 유지하고 있는지 점검한다.
④ 불필요한 반복, 문장이 지나치게 길고 장황한 것, 논리적 비약 등 읽기 어렵게 만드는 요소를 찾아 없애거나 수정해야 한다. 소리 내어 읽어보는 것은 문장이 자연스러운지, 읽기 편한지 점검하는 데 효과적인 방법이다.
⑤ 저자는 자신의 원고에 대해 일정 시간을 두고 객관적인 시각으로 최종 교정을 진행해야 한다. 또는 다른 사람(편집자, 동료 작가, 먼저 읽어보는 독자 등)의 객관적인 검토 의견을 적극적으로 받아들여 활용한다.
⑥ 저자는 저작물의 최종본을 확정할 때, 그 내용이 장기간 보존되고 참조될 수 있도록 텍스트의 안정성과 명확성을 확보하는 데 주의를 기울여야 한다. 디지털 저작물의 경우 중요한 내용 변경 시 개정 이력을 간략히 명시하는 것을 고려할 수 있다.

**제37조 (최종 점검 사항)**
① 저작물의 제목 및 각 부분의 소제목이 독자의 흥미를 끌 만큼 충분히 매력적인지, 그리고 해당 부분의 핵심 내용을 정확하게 반영하고 있는지 최종적으로 검토한다.
② 저작물의 도입부가 독자의 주의를 효과적으로 끌고 문제 제기나 주제 제시를 명확히 하는지 확인한다. 또한 결론부가 도입부에서 제기된 문제에 대한 해답이나 주제를 설득력 있게 마무리하고 여운을 남기는지, 도입과 결론이 자연스럽게 이어지는지 점검한다.

**제38조 (저작물 형식 및 디지털 환경 고려)**
(해당되는 저작물의 경우 적용)
① 목차는 원문에 이미 있거나 내용의 체계적인 전달을 위해 필요하다고 판단될 경우 작성한다. 이때 내용의 논리적 흐름을 반영하는 서술형 제목을 사용하고 명확한 단계별 구조를 갖도록 한다.
② 본문의 내용과 글투가 최종적으로 선택될 글꼴, 글자 사이 간격, 줄 간격, 여백 등 편집 디자인과 시각적으로 조화를 이루어 가장 읽기 편한 상태가 되도록 고려한다. 필요한 경우 목록, 표, 그림 등을 활용하여 정보를 구조적으로 제시할 수 있으나, 원문의 내용을 바꾸거나 왜곡하지 않는 범위에서 신중하게 사용한다.
③ 디지털 환경에서 발표되는 저작물의 경우, 다음 각 호의 사항을 추가로 고려하여 독자가 읽기 편하고 쉽게 접근할 수 있도록 노력해야 한다.
    1.  화면에서 읽기 좋도록 알맞은 문단 길이와 여백을 활용한다.
    2.  하이퍼링크(다른 정보로 바로 연결하는 기능)를 사용할 때에는 연결되는 내용이 무엇인지 명확히 안내한다.
    3.  이미지, 영상 등 다양한 매체 요소에는 그것이 무엇인지 알 수 있는 적절한 설명이나 대체 문구(대체 텍스트)를 제공한다.
    4.  독자들이 쉽게 검색하여 찾을 수 있도록 핵심 단어를 적절히 활용한다.

**제39조 (저작권 및 윤리 규범 준수)**
다른 사람의 글이나 자료, 이미지 등을 인용하거나 참고할 때에는 저작권법을 비롯한 관련 법규와 학문적·직업적 윤리 규범을 모두 지켰는지 최종적으로 확인해야 한다. 다른 사람의 저작물을 베끼거나(표절) 무단으로 사용하는 일이 없도록 기본적인 글쓰기 윤리를 철저히 지켜야 한다.

**제40조 (원문 내용의 충실성 유지 원칙)**
① 저작물을 편집, 번역, 교정(이하 "편집등"이라 한다)하는 과정에서는 제3조제4호에서 정의한 원문이 담고 있는 정보가 사라지거나 줄어들지 않도록 최대한 노력해야 한다.
② 원문의 내용을 수정할 때에는 명백한 사실 오류, 문법적 오류, 또는 오타를 바로잡는 경우에 한정하는 것을 원칙으로 한다.
③ 제2항에 따른 수정 외에는 원문에 새로운 정보를 마음대로 추가하거나 기존 정보를 삭제해서는 안 된다. 또한 원저자(또는 원문의 작성자)의 본래 의도와 핵심 메시지가 왜곡되지 않도록 주의해야 한다.

**제11장 특정 상황에서의 언어 운용 지침**

**제41조 (복잡하거나 전문적인 내용 전달 시)**
복잡하거나 고도의 전문성을 요하는 내용을 대중에게 전달할 때에는 다음 각 호의 사항을 적극적으로 고려하여 독자의 이해를 돕도록 노력해야 한다.
1.  핵심 개념을 먼저 제시하고, 점진적으로 세부 내용을 설명하는 방식을 활용한다.
2.  독자에게 친숙한 비유, 구체적인 사례, 또는 일상적인 경험과 연결하여 설명한다.
3.  도표, 그림, 인포그래픽 등 시각 자료를 보조적으로 사용하여 이해도를 높인다.
4.  필수적인 전문용어는 쉬운 말로 풀어쓰거나 최초 사용 시 간결한 해설을 덧붙이며, 과도한 사용을 피한다.
5.  내용의 중요도에 따라 정보를 선별하고, 독자가 소화할 수 있는 적절한 양으로 나누어 제시한다.

**제42조 (민감하거나 논쟁적인 주제 처리 시)**
사회적으로 민감하거나 첨예한 논쟁이 있는 주제를 다룰 때에는 다음 각 호의 원칙을 준수하여 저작물의 공정성과 사회적 책임을 다해야 한다.
1.  객관적 사실과 자료에 근거하여 내용을 구성하며, 개인적인 추측이나 편견이 개입되지 않도록 주의한다.
2.  다양한 관점과 의견이 존재할 수 있음을 인지하고, 가능한 한 균형 잡힌 시각으로 정보를 제공하려 노력한다.
3.  특정 개인, 집단, 또는 가치관에 대한 비방, 혐오, 또는 차별을 조장하는 표현을 사용해서는 아니 된다.
4.  사용하는 어휘나 표현이 특정 독자에게 불필요한 오해나 정서적 상처를 유발하지 않도록 신중을 기한다.
5.  결론을 제시하거나 주장을 펼칠 때에는 그 논리적 근거를 명확히 밝히고, 단정적인 표현보다는 신중한 어조를 사용한다.

**제43조 (번역 작업 수행 시)**
원문을 다른 언어로 번역하는 경우, 저자(번역자)는 다음 각 호의 사항을 고려하여 원문의 가치와 목표 언어 독자의 이해를 조화롭게 추구해야 한다.
1.  원문 저자의 의도, 핵심 메시지, 문체적 특징 및 전체적인 분위기를 정확히 파악하여 목표 언어로 충실히 옮긴다.
2.  목표 언어의 어문 규범을 철저히 준수하고, 해당 언어 사용자들이 가장 자연스럽고 명확하게 이해할 수 있는 표현을 선택한다.
3.  원문에 담긴 문화적 배경, 역사적 맥락, 또는 특수한 관용 표현 등을 고려하여, 필요한 경우 독자의 이해를 돕기 위한 최소한의 설명을 추가하거나 가장 적절한 등가 표현으로 조정할 수 있다. 단, 이는 원문의 본질을 왜곡하지 않는 범위 내에서 신중하게 이루어져야 한다.
4.  직역으로 인해 의미 전달이 어색하거나 모호해지는 경우, 원문의 의미를 정확히 전달하는 범위 내에서 유연한 의역을 할 수 있다.

**제44조 (특정 독자층 대상 저작물 작성 시)**
주된 독자층이 명확히 특정되는 저작물(예: 아동, 청소년, 노년층, 특정 분야 비전문가 등)을 작성할 때에는 다음 각 호의 사항을 특별히 고려하여 맞춤형 소통을 지향해야 한다.
1.  대상 독자층의 평균적인 어휘 수준, 배경지식, 인지 능력 및 관심사를 면밀히 파악하고, 이에 부합하는 어휘, 문장 구조, 설명 방식을 사용한다.
2.  대상 독자층에게 부적절하거나 유해할 수 있는 내용, 표현, 또는 이미지는 사용하지 않으며, 특히 미성년자를 대상으로 할 경우 교육적·정서적 영향을 신중히 고려한다.
3.  대상 독자층이 흥미를 느끼고 쉽게 동화될 수 있는 소재, 예시, 또는 서사 구조를 활용할 수 있다.
4.  정보 접근성이 낮은 독자층을 고려하여 글꼴 크기, 디자인, 매체 활용 등에서 가독성과 이해도를 높이기 위한 노력을 기울인다.

**제45조 (사실과 의견을 함께 제시할 시)**
하나의 저작물이나 문단 내에서 객관적 사실과 저자의 주관적 의견을 함께 제시할 때에는 다음 각 호의 원칙에 따라 독자의 혼동을 방지해야 한다.
1.  객관적 사실을 전달하는 부분과 저자의 의견, 해석, 또는 평가를 제시하는 부분을 명확히 분리하여 독자가 이를 구분할 수 있도록 한다. (제33조제1항과 연계)
2.  "내 생각에는", "연구에 따르면", "일반적으로 알려진 바와 같이" 등 출처나 판단의 주체를 명시하는 표현을 사용하여 사실과 의견의 구분을 돕는다.
3.  의견을 제시할 때에는 그것이 사실에 기반한 합리적인 추론인지, 또는 개인적인 신념이나 가치 판단인지를 가능한 한 명확히 하여 독자가 비판적으로 수용할 수 있도록 한다.
4.  사실을 왜곡하거나 의견을 사실처럼 포장하여 독자를 오도해서는 아니 된다.

**제46조 (설득 또는 주장을 목적으로 하는 글쓰기 시)**
독자를 설득하거나 특정 주장을 관철시키려는 목적을 가진 저작물을 작성할 때에는 다음 각 호의 사항을 유의하여 논리성과 윤리성을 확보해야 한다.
1.  주장의 핵심 내용을 명확하고 간결하게 제시하며, 그 주장을 뒷받침하는 타당하고 검증된 근거를 충분히 제시한다.
2.  논리적 비약, 성급한 일반화, 순환 논리, 또는 감정에만 호소하는 오류를 범하지 않도록 주의한다.
3.  반대 의견이나 예상되는 반론이 있다면 이를 공정하게 언급하고, 이에 대한 합리적인 반박이나 설명을 제시함으로써 주장의 설득력을 높일 수 있다.
4.  독자의 자율적인 판단을 존중하며, 강압적이거나 현혹하는 방식의 설득을 지양한다.

**제47조 (감성적 내용 전달 또는 문학적 표현 시)**
독자의 감성에 호소하거나 문학적 표현을 통해 미적 감동을 주고자 할 때에는 다음 각 호의 방법을 고려할 수 있다.
1.  구체적이고 생생한 묘사, 감각적 어휘, 또는 상징적 표현을 활용하여 독자의 정서적 반응을 이끌어낸다. (제7조제3항, 제18조, 제32조제3항과 연계)
2.  인물의 내면 심리나 감정 변화를 섬세하게 그려내어 독자의 공감과 감정 이입을 유도한다. (제32조제4항과 연계)
3.  비유, 은유, 반복, 대구, 영탄 등 다양한 수사법을 문맥과 내용에 맞게 효과적으로 사용하여 표현의 깊이와 아름다움을 더한다. (제30조제7항 및 제8항과 연계)
4.  지나치게 감상적이거나 작위적인 표현으로 흐르지 않도록 절제와 진정성을 유지하며, 저작물의 전체적인 주제와 조화를 이루도록 한다.

**제48조 (짧은 형식의 정보 전달 시 - 광고, SNS 등)**
광고 문구, 소셜 미디어 게시물, 알림 메시지 등 짧은 형식으로 정보를 전달하거나 주의를 환기해야 하는 경우 다음 각 호를 고려한다.
1.  제한된 분량 내에서 가장 핵심적인 정보를 명확하고 간결하게 전달하는 데 집중한다.
2.  독자의 시선을 즉각적으로 사로잡고 기억에 남을 수 있도록 창의적이고 인상적인 어휘나 표현을 사용할 수 있다.
3.  목표 독자층의 특성과 해당 매체의 소통 방식을 고려하여 최적의 어투와 형식을 선택한다.
4.  과장, 허위, 또는 기만적인 정보를 담아 독자를 오인시키거나 불쾌감을 유발해서는 아니 된다.

**제49조 (콘텐츠 재사용 및 각색 시 언어 운용)**
기존 저작물을 요약, 발췌, 각색하거나 다른 매체 또는 형식으로 변용하여 새로운 대중적 저작물을 창작하는 경우, 다음 각 호의 사항을 준수하여야 한다.
1.  원저작물의 핵심 내용, 주제, 그리고 저자의 의도를 존중하며, 이를 심각하게 왜곡하거나 훼손하지 아니한다.
2.  새로운 저작물의 창작 목적과 목표 독자층에 맞게 언어와 표현을 적절히 조정하되, 원저작물에 대한 정확한 이해를 바탕으로 하여야 한다.
3.  인용 또는 참조의 경우 제34조의 규정을 준수하며, 필요한 경우 원저작물과의 관계를 명확히 밝혀 독자의 오해를 방지한다.

**제50조 (긴급 상황 발생 시 정보 전달 언어)**
재난, 감염병 유행 등 공공의 안녕과 관련된 긴급 상황이나 위기 상황에 대한 정보를 대중에게 전달하는 저작물의 경우, 다음 각 호의 원칙을 특히 준수하여야 한다.
1.  정보는 확인된 사실에 기반하여 최대한 정확하고 신속하게 전달한다.
2.  독자가 상황을 명확히 인지하고 필요한 행동을 취할 수 있도록 간결하고 명료한 언어를 사용한다.
3.  불안감을 과도하게 조장하거나 사회적 혼란을 야기할 수 있는 추측성 또는 선정적인 표현을 지양한다.
4.  필요한 경우, 관련 기관의 공식 발표나 지침을 명확히 인용하고 출처를 밝힌다.

제 51조(출력형식)
1. 출력에 있어서 가장 최상위 제목 #를 사용하고 출력하도록 노력한다.
2. 나머지 하위 목차 편성시에는 ##, ### 등을 사용한다.



## 글쓰기 몰입감 유발 지침

**제1조 (목적)**
이 지침은 에세이, 소설, 연설문, 비평문, 기술문, 법률문, 시나리오, 자기소개서, 보도자료, 웹툰/웹소설, 소셜 미디어 콘텐츠, **그리고 교과서와 같이 정보 전달을 주 목적으로 하는 글**에 이르기까지, 다양한 글쓰기 장르의 특성을 면밀히 분석하고 각 장르에 최적화된 몰입감 유발 원칙과 구체적인 방법론을 규정함으로써 글의 메시지 전달 효과를 극대화하고 독자의 깊이 있는 참여를 유도함을 목적으로 한다. 더 나아가, 각 장르의 고유한 한계를 넘어설 수 있는 **창의적이고 융합적인 접근**을 장려한다.

**제2조 (정의)**
이 지침에서 사용하는 용어의 정의는 다음과 같다.
1.  "**몰입감**"이란 독자 또는 청중이 글의 내용에 완전히 동화되어 외부 현실을 인지하지 못하고, 강렬한 감정적, 지적, 또는 실천적 참여를 하는 궁극적인 상태를 말한다. 이는 단순히 정보를 수동적으로 받아들이는 것을 넘어, 능동적인 인지 활동과 정서적 교감을 통해 글 속 세계에 완전히 빠져드는 경험을 의미한다.
2.  "**장르 특수성**"이란 각 글쓰기 장르가 가지는 고유한 목적, 형식, 구조, 전달 방식, 대상 독자층 및 기대 효과 등을 의미한다. 이는 몰입감 유발 전략을 수립하는 데 있어 가장 기본적이면서도 중요한 고려 사항이다.
3.  "**경계 확장**"이란 특정 장르의 전통적인 틀에 갇히지 않고, 다른 장르의 효과적인 요소를 차용하거나 새로운 시도를 통해 몰입감을 증대시키는 **혁신적인 글쓰기 접근 방식**을 의미한다.

**제3조 (적용 범위)**
이 지침은 개인의 창작물부터 전문적인 업무 문서, 공공 정보에 이르기까지, 독자 또는 청중을 대상으로 하는 모든 형태의 글쓰기에 적용되며, 장르 간의 융합적 접근 또한 포괄한다. 본 지침은 특정 장르에 국한되지 않고 글쓰기 전반의 효과적인 몰입 전략을 제시한다.

---

### 제2장 주요 장르별 몰입감 유발 지침

**제4조 (에세이의 몰입감 유발)**
① **원칙**: 에세이는 필자의 내면과 외부 세계의 조우를 통해 독자와 **심리적, 철학적 공감대**를 형성하고, 성찰적 사유의 과정을 공유함으로써 몰입감을 유발한다. 이는 독자로 하여금 자신의 삶을 반추하게 하는 **자기 발견의 여정**으로 이끌며, 필자와 독자 간의 **깊은 신뢰 관계**를 구축한다.
② **방법론**:
    1.  **밀도 높은 개인적 경험**: 단순한 사건 나열을 넘어, 특정 경험이 필자에게 미친 **심리적 변화와 통찰**을 심층적으로 분석하고, 그 과정에서 파생된 감각적 디테일(미세한 떨림, 특정 향, 예상치 못한 소리 등)을 극대화하여 묘사함으로써 독자가 필자의 경험을 간접적으로 체험하며 **정서적으로 동화**되도록 유도한다.
    2.  **질문하는 서술 방식**: 명확한 답을 제시하기보다, 필자의 고민과 사유의 과정을 독자와 함께 나누는 **수사적 질문**이나 **열린 결말의 질문**을 던져 독자로 하여금 글 속으로 깊이 들어와 스스로 답을 찾고 자신만의 의미를 부여하도록 **능동적인 사고를 촉진**한다.
    3.  **일상 속 보편성 발견**: 지극히 개인적인 경험이라 할지라도, 그 안에서 인간 본연의 **보편적 감정이나 철학적 의미**를 추출하고 이를 섬세한 언어로 표현하여 독자 누구나 공감할 수 있는 접점을 찾아 **광범위한 독자의 몰입**을 유도한다.
    4.  **솔직한 취약성 노출**: 필자의 약점, 실수, 실패 등 **인간적인 취약성**을 솔직하게 드러내어 독자로 하여금 필자를 더욱 신뢰하고 친밀감을 느끼게 함으로써 **감정적 몰입**을 심화시킨다. 이는 완벽한 모습이 아닌 인간적인 면모를 통해 독자와의 거리를 좁힌다.
    5.  **문체적 유연성**: 사유의 깊이를 더하기 위해 시적인 은유나 비유를 자유롭게 활용하되, 독자의 이해를 저해하지 않는 선에서 **문체의 다양성**을 추구하여 단조로움을 피하고, 독자의 **지적 흥미를 지속적으로 자극**한다.

**제5조 (소설의 몰입감 유발)**
① **원칙**: 소설은 창조된 세계와 인물을 통해 독자를 **가상의 현실 속으로 완전히 전이**시키고, 복합적인 감정의 동요와 지적 호기심을 유발하여 현실과의 단절을 통한 궁극적인 몰입을 이끌어낸다. 이는 독자로 하여금 이야기 속 인물과 운명을 함께하는 **강렬한 대리 경험**을 제공한다.
② **방법론**:
    1.  **다층적 인물 구축**: 주인공뿐만 아니라 주변 인물들에게도 **뚜렷한 동기와 내면의 갈등, 예측 불가능한 성장 또는 변화 과정**을 부여하여 독자가 여러 인물에게 공감하고 그들의 복잡한 관계망 속으로 깊이 빠져들게 한다. 인물의 미묘한 심리 변화를 섬세하게 묘사한다.
    2.  **치밀한 세계관 구축**: 판타지나 SF 장르뿐만 아니라 현대물에서도 **독자적인 규칙, 역사, 문화, 그리고 분위기를 가진 세계**를 치밀하게 설정하고, 그 세계 속에서 인물들이 겪는 사건이 **필연성과 개연성**을 띠도록 구성하여 독자가 세계를 현실처럼 받아들이게 한다.
    3.  **서스펜스와 예측 불가능성**: 사건의 복선을 치밀하게 깔고, **중요한 정보의 공개를 의도적으로 지연**하며, 예상을 뒤엎는 반전과 치명적인 위기 상황을 반복적으로 제시하여 독자가 다음 장을 넘기지 않고는 견딜 수 없게 만드는 **심리적 압박감**을 조성한다.
    4.  **감각적 디테일의 폭발**: 장면 묘사 시 시각뿐만 아니라 청각, 후각, 미각, 촉각 등 **오감을 넘어선 육감까지 자극하는 구체적이고 생생한 디테일**을 풍부하게 사용하여 독자의 상상력을 총동원하게 한다. (예: 등장인물의 불안감을 표현할 때 땀의 짠맛, 심장 박동 소리, 손에 느껴지는 차가운 금속의 질감, 특정 기억을 불러일으키는 냄새 등)
    5.  **시점과 서술 트릭**: 1인칭, 3인칭 전지적 작가 시점 외에 **제한적 시점(제3자의 시선), 교차 시점, 다중 시점** 등을 능숙하게 활용하여 독자의 시야를 제한하거나 확장시키고, 때로는 **불신할 수 있는 화자(Unreliable Narrator)**를 통해 독자의 추리력을 자극하고 비판적 사고를 유도한다.

**제6조 (연설문의 몰입감 유발)**
① **원칙**: 연설문은 청중에게 **직접적으로 메시지를 전달**하는 글로서, 청중의 감정을 움직이고, 논리적 설득을 통해 **행동 변화를 유도**하며, 현장감을 극대화하여 몰입감을 유발한다. 이는 연설자와 청중 간의 **강력한 감성적 연대감과 공동체 의식** 형성을 포함한다.
② **방법론**:
    1.  **청중 맞춤형 공감대 형성**: 연설 초반에 청중의 **공통적인 경험, 가치관, 고민**을 언급하며 즉각적인 공감대를 형성하고, 연설자가 청중의 입장을 깊이 이해하고 있음을 보여주어 **심리적 장벽을 허문다.**
    2.  **감정의 고저 조절**: 논리적인 주장 중간에 청중의 **감정을 격렬하게 자극하는 극적인 일화, 개인적인 고백, 또는 사회적 약자의 비극적인 이야기**를 삽입하여 감정의 고조를 유도한다. 이때 유머나 풍자를 적절히 활용하여 분위기를 전환하며 청중의 집중력을 유지한다.
    3.  **반복과 리듬의 마법**: 핵심 메시지나 구호를 **전략적으로 반복 제시**하고, 문장의 길이와 구조에 변화를 주어 **리듬감 있는 운율**을 형성한다. 이는 청중의 귀에 메시지가 각인되도록 하며, 일종의 최면적 효과를 통해 몰입을 심화시킨다.
    4.  **수사적 질문과 행동 촉구**: 청중의 생각을 유도하는 **설득력 있는 수사적 질문**을 던지고, 연설의 마지막에는 청중이 즉각적으로 실행할 수 있는 **구체적이고 실현 가능한 행동 방안**을 제시하여 몰입을 행동으로 연결시킨다.
    5.  **비언어적 요소의 반영**: 연설문 작성 시 음성의 강약, 속도, 제스처, 시선 처리 등 **연설자의 비언어적 요소**가 자연스럽게 발현될 수 있도록 구어체적 표현과 구체적인 지시문(예: "잠시 침묵하며 청중을 응시한다")을 포함한다.

---

### 제3장 추가 장르의 몰입감 유발 지침

**제7조 (비평문의 몰입감 유발)**
① **원칙**: 비평문은 특정 대상(문학, 예술, 사회 현상 등)에 대한 **깊이 있는 분석과 독창적인 해석**을 통해 독자의 **지적 호기심을 자극**하고, 새로운 관점을 제시하여 독자의 사고 확장을 유도하는 **비판적 지적 몰입**을 목표로 한다. 이는 독자로 하여금 비판 대상에 대해 새롭게 인식하고, 스스로 판단의 주체가 되도록 이끈다.
② **방법론**:
    1.  **문제 의식의 명확화 및 도발성**: 대상에 대한 기존의 통념을 깨거나, 예상치 못한 질문을 던지는 **도발적인 문제 의식**을 서론에서 명확히 제시하여 독자의 주의를 즉각적으로 사로잡고 **지적 논쟁에 참여하도록 유도**한다.
    2.  **논리적 전개의 서스펜스**: 주장을 펼쳐나가는 과정에서 **탄탄한 논리적 근거와 체계적인 분석**을 제시하되, 중간중간 **반론에 대한 예상과 그에 대한 재반박**을 통해 독자가 논쟁의 흐름을 따라오며 스스로 판단을 내리도록 유도하는 **지적 서스펜스**를 조성한다.
    3.  **예상치 못한 통찰**: 단순히 대상의 내용을 요약하는 것을 넘어, **날카로운 통찰력과 독창적인 해석**을 통해 독자가 "아하!" 하고 무릎을 칠 만한 새로운 관점을 제시하여 **지적 희열**을 선사하고, 기존 사고방식의 전환을 유도한다.
    4.  **비유와 은유의 지적 활용**: 복잡한 개념이나 추상적인 이론을 독자가 쉽게 이해하고 상상할 수 있도록 **적절하고 참신한 비유와 은유**를 활용한다. 이는 지적 난이도를 낮추면서도 깊이를 더하는 효과를 가져온다.
    5.  **결론의 여운과 확장성**: 비평의 결론은 명확한 주장을 다시 한번 강조하되, 대상에 대한 **향후 논의의 가능성**이나 독자 스스로 더 깊이 생각할 수 있는 **열린 질문의 여운**을 남겨 지적 몰입을 글을 마친 후에도 지속시킨다.

**제8조 (기술문/보고서의 몰입감 유발)**
① **원칙**: 기술문이나 보고서는 복잡한 기술 정보, 데이터, 또는 업무 내용을 **정확하고 효율적으로 전달**하여 독자가 핵심 내용을 **신속하고 오류 없이 이해**하고, 나아가 필요한 **행동을 취할 수 있도록** 유도하는 **실용적 몰입**을 목표로 한다. 이는 독자의 시간과 노력을 최소화하며 최대의 이해도를 제공하는 데 집중한다.
② **방법론**:
    1.  **목적 지향적 구성**: 독자가 이 문서를 통해 무엇을 얻을 수 있는지, 어떤 행동을 해야 하는지 **서론에서 명확하고 간결하게 제시**하여 독자가 글을 읽는 목적을 인지하고 집중하도록 **읽기 동기를 부여**한다.
    2.  **시각 자료의 전략적 배치**: 복잡한 데이터나 프로세스는 **도표, 그래프, 플로우차트, 인포그래픽** 등 시각 자료를 활용하여 한눈에 이해되도록 한다. 텍스트와 시각 자료가 상호 보완적인 역할을 수행하도록 **균형 있게 배치**한다.
    3.  **계층적 정보 구조화**: 헤딩, 서브헤딩, 글머리 기호(불릿), 번호 매기기 등을 사용하여 **정보를 계층적으로 구조화**하고, 중요한 내용은 **볼드체, 강조 색상** 등을 활용하여 시각적으로 부각시켜 독자가 필요한 정보를 **빠르게 스캔하고 찾을 수 있도록** 돕는다.
    4.  **용어의 일관성과 명확한 정의**: 전문 용어는 **최초 사용 시 독자가 이해하기 쉽게 명확하게 정의**하고, 문서 전체에서 **일관되게 사용**하여 독자의 혼란을 방지한다. 필요에 따라 용어 해설 섹션을 추가할 수 있다.
    5.  **액션 지향적 문체**: 모호한 표현을 지양하고, **수동태보다 능동태**를 사용하여 주어와 행위를 명확히 하며, 독자가 수행해야 할 **지시사항은 간결하고 구체적**으로 명시한다. (예: "버튼을 클릭하십시오" vs "버튼이 클릭되어야 합니다.")

**제9조 (법률문의 몰입감 유발)**
① **원칙**: 법률문은 복잡한 법적 개념과 사실 관계를 **정확하고 엄격한 논리**에 따라 전달하여 독자가 **법적 효력과 의미를 명확히 파악**하고, 그에 따른 **법률적 판단이나 조치**를 내릴 수 있도록 유도하는 **규범적 몰입**을 목표로 한다. 이는 **오독의 여지를 최소화**하고 법적 안정성을 확보하는 데 주력한다.
② **방법론**:
    1.  **정의 조항의 상세화**: 용어의 혼란을 방지하기 위해 **핵심 법률 용어를 엄격하게 정의**하고, 해당 정의가 문서 전체에서 일관되게 적용되도록 한다. 법률문 내에서 사용되는 모든 용어에 대한 **명확한 기준**을 제시한다.
    2.  **명확한 주어와 술어의 사용 및 문장 간결화**: 문장의 **주어와 술어를 명확히 하고, 불필요한 수식어를 최소화**하여 문장의 중의성을 제거한다. 긴 문장은 가능한 한 짧고 명료하게 분리하며, **단어 선택에 있어 오차를 허용하지 않는 정확성**을 최우선으로 한다.
    3.  **계층적 구조 및 참조 체계의 엄격성**: 법률 조문, 항, 호 등의 **계층적 구조를 명확히 하고, 상호 참조를 정확하고 엄격하게 명시**하여 독자가 법적 관계와 맥락을 오류 없이 파악할 수 있도록 한다. 이는 법률문의 논리적 일관성을 강화한다.
    4.  **조건부 문장의 명확화**: "~할 경우 ~한다"와 같은 **조건부 문장을 사용할 때 조건을 명확히 하고, 그 조건에 따른 결과 또는 의무를 구체적으로 명시**하여 해석의 여지를 줄이고 **법적 효력을 명확히 한다.**
    5.  **예시 및 판례의 보충적 활용**: 본문의 법률적 원칙을 보충하고 이해를 돕기 위해 **관련 예시나 판례를 간결하고 정확하게 인용**할 수 있으나, 이는 본문의 명확성을 해치지 않는 범위 내에서, 그리고 **법적 구속력은 본문에 있음을 명시**한 상태에서 이루어져야 한다.

**제10조 (자기소개서의 몰입감 유발)**
① **원칙**: 자기소개서는 제한된 지면 내에서 필자의 **핵심 역량과 매력을 효과적으로 전달**하여 평가자로 하여금 필자에 대한 **깊은 인상과 긍정적인 기대감**을 갖게 하고, 나아가 **면접 기회로 연결되는 심리적, 실질적 몰입**을 목표로 한다.
② **방법론**:
    1.  **결과 중심의 서술 (STAR 기법 심화)**: 경험 나열에 그치지 않고, 각 경험에서 **필자가 어떤 역할을 했고(Action), 어떤 구체적인 성과를 달성했으며(Result), 그 성과가 측정 가능한 수치로 어떻게 표현될 수 있는지(Metric)**를 명확하고 간결하게 제시한다. (Situation, Task, Action, Result)
    2.  **핵심 역량과 유기적 연결**: 필자의 모든 경험과 강점이 **지원하는 직무 또는 학교에서 요구하는 핵심 역량과 어떻게 유기적으로 연결되는지**를 설득력 있게 보여주어 평가자의 공감을 얻고, 필자가 해당 역할에 **최적화된 인재임**을 각인시킨다.
    3.  **진정성과 개성**: 정형화된 표현이나 클리셰를 지양하고, 필자의 **진솔한 목소리와 고유한 개성**이 드러나도록 하여 다른 지원자들과 차별화된 인상을 남긴다. **필자만의 독특한 스토리**를 통해 공감대를 형성한다.
    4.  **구체적인 스토리텔링**: 추상적인 역량 언급보다는, 특정 상황에서 필자가 겪었던 **도전과 극복 과정, 그리고 거기서 얻은 깨달음이나 성장을 담은 짧고 흡인력 있는 스토리**를 통해 필자의 강점을 생생하게 전달한다.
    5.  **미래 지향적 포부와 기여 방안**: 단순히 과거를 회고하는 것을 넘어, 필자가 지원하는 곳에서 **어떻게 기여하고 성장할 것인지에 대한 명확하고 구체적인 비전**을 제시하여 평가자의 기대를 높이고, **실질적인 가치를 제공할 수 있는 인재**임을 어필한다.

**제11조 (보도자료의 몰입감 유발)**
① **원칙**: 보도자료는 핵심 정보를 **간결하고 명확하게 전달**하여 언론 관계자와 대중이 **짧은 시간 안에 사건의 본질을 파악**하고, 나아가 **기사화하거나 공유하도록** 유도하는 **정보 전달 및 확산 몰입**을 목표로 한다. 이는 정보의 **신속성과 파급력**에 중점을 둔다.
② **방법론**:
    1.  **역피라미드 구조의 극대화**: 가장 중요한 정보(5W1H)를 **제목과 리드 문단에 압축적으로 집중 배치**하고, 점차 세부적인 내용을 뒤에 배치하여 독자가 핵심 내용을 단 1분 안에 파악하고 필요시 더 깊이 읽도록 한다.
    2.  **간결하고 명확하며 행동 유발적인 제목**: 독자의 시선을 즉각적으로 사로잡고 **핵심 내용을 함축적으로 전달**하는 강력한 제목을 사용하며, **클릭 또는 추가 정보 탐색을 유도**하는 요소를 포함할 수 있다.
    3.  **인용문의 전략적 활용**: 관련 인물(주요 관계자, 전문가 등)의 **직접 인용문**을 삽입하여 보도자료에 생동감을 더하고, 메시지에 신뢰성과 권위를 부여하며, **감성적 호소력**을 높인다.
    4.  **사실 기반의 객관적 서술 및 데이터 제시**: 개인적인 의견이나 주관적인 판단을 배제하고, **객관적인 사실과 검증 가능한 데이터를 기반으로 서술**하여 정보의 신뢰도를 높인다. **통계, 수치 등을 명확히 제시**하여 설득력을 강화한다.
    5.  **미래 지향적 메시지와 비전 제시**: 현재의 사실 전달뿐만 아니라, 해당 사건이나 발표가 **향후 미칠 긍정적인 영향이나 미래 비전**을 간결하게 제시하여 독자 및 이해관계자의 관심을 지속시키고 **긍정적인 이미지**를 구축한다.

**제12조 (웹툰/웹소설의 몰입감 유발)**
① **원칙**: 웹툰/웹소설은 **매우 짧은 호흡과 즉각적인 반응**을 전제로 하며, 독자의 **흥미를 즉각적으로 유발**하고, **다음 회차에 대한 강렬한 기대감**을 지속적으로 제공하며, 시각적 또는 서사적 장치를 통해 빠른 속도로 독자를 이야기에 빠져들게 하는 **회차 기반의 중독적 몰입**을 목표로 한다.
② **방법론**:
    1.  **강렬한 프롤로그/도입부**: 첫 화 또는 첫 문단에서 **독자의 시선을 사로잡는 극적인 사건, 충격적인 설정, 또는 매력적인 인물 간의 관계성**을 제시하여 즉각적인 몰입을 유도한다. 독자가 **'찍먹' (맛보기) 후 바로 '정주행' (연속 시청/독서)하게** 만든다.
    2.  **빠른 전개와 템포 조절**: 불필요한 설명이나 배경 묘사를 최소화하고, **사건의 전개를 빠르고 긴장감 있게 진행**하여 독자가 지루할 틈을 주지 않는다. 다만, 감정선이나 핵심 전환점에서는 템포를 조절하여 **극적인 효과를 극대화**한다.
    3.  **회차별 클리프행어(Cliffhanger)의 극대화**: 각 회차의 마지막 부분에 **다음 내용을 궁금하게 만드는 결정적인 위기 상황, 충격적인 반전, 또는 미해결 질문**을 남겨 독자가 **다음 회차를 간절히 기다리게** 만드는 '떡밥'을 던진다.
    4.  **시각적/서사적 장치 활용 (웹툰)**: 인물의 표정, 행동, 배경 묘사를 **극대화된 연출과 구도**로 표현하고, 효과음/말풍선 등 웹툰 특유의 시각적 장치를 활용하여 현장감과 몰입감을 높인다. **캐릭터 디자인의 매력도**가 핵심적인 요소로 작용한다.
    5.  **캐릭터성과 설정의 매력**: 독특하고 매력적인 **캐릭터 디자인(웹툰) 및 입체적인 성격 설정**, 그리고 독창적이고 흥미로운 **세계관/설정**은 독자가 꾸준히 작품을 소비하게 만드는 핵심적인 요소가 된다. **독자들이 '최애' (가장 좋아하는) 캐릭터에 몰입**하도록 유도한다.

**제13조 (소셜 미디어 콘텐츠의 몰입감 유발)**
① **원칙**: 소셜 미디어 콘텐츠는 **극도로 짧은 주의 집중 시간(평균 3초 이내)** 내에 독자의 시선을 사로잡고, **강렬한 인상을 남기거나 즉각적인 반응(좋아요, 댓글, 공유)**을 유도하며, **바이럴(Viral) 확산**을 통해 파급적 몰입을 목표로 한다. 이는 정보의 **휘발성과 즉각적인 소통**에 중점을 둔다.
② **방법론**:
    1.  **핵심 메시지의 즉각적, 시각적 전달**: **첫 문장 또는 첫 이미지/영상**에서 가장 중요한 정보나 가장 흥미로운 요소를 압도적으로 제시하여 스크롤을 멈추게 한다. **썸네일과 첫 1초 영상이 승패를 좌우한다.**
    2.  **시각적 요소의 압도적 활용 및 고품질 콘텐츠**: 텍스트보다 **이미지, 영상, GIF 등 시각적 콘텐츠**가 지배적인 역할을 하도록 구성하며, 시선을 끄는 **고품질의 색감, 구도, 편집, 애니메이션 효과** 등을 활용한다. 짧은 시간 내에 강력한 시각적 임팩트를 준다.
    3.  **간결하고 자극적인 문구**: 복잡한 문장보다는 **핵심을 찌르는 짧고 강렬한 문구, 유행어, 도발적인 질문형 문장, 또는 감성적인 한 문장**을 사용하여 독자의 반응을 유도한다.
    4.  **이모지, 해시태그, 콜투액션(Call to Action)의 전략적 활용**: 감정을 직접적으로 표현하는 **이모지**, 관련성 높고 트렌디한 **해시태그**를 사용하여 검색 유입을 늘리고, **"지금 바로 확인!", "친구 태그!", "의견 남겨주세요!"**와 같은 명확하고 직접적인 콜투액션을 통해 독자의 참여를 유도한다.
    5.  **참여 유도형 콘텐츠 및 양방향 소통**: 설문, 퀴즈, 투표, 댓글 참여 이벤트 등 **독자가 직접 참여할 수 있는 형식**을 제공하여 단순 소비자를 능동적인 참여자로 전환시키고 몰입을 강화한다. **실시간 소통(라이브 방송, Q&A)을 통해 유대감을 형성**한다.

**제14조 (교과서의 몰입감 유발)**
① **원칙**: 교과서는 방대한 정보를 **체계적이고 논리적으로 전달**하여 학습자가 **새로운 지식을 효과적으로 습득**하고, 복잡한 개념을 **명확히 이해**하며, 학습에 대한 **흥미와 동기를 유발**하여 **지속적인 학습 몰입**을 목표로 한다.
② **방법론**:
    1.  **흥미 유발형 도입**: 각 단원 또는 섹션의 시작 부분에 **학습 내용과 관련된 실생활 사례, 흥미로운 질문, 역사적 배경, 또는 시각 자료**를 제시하여 학습자의 호기심을 자극하고 학습 동기를 부여한다.
    2.  **단계적, 시각적 정보 제시**: 복잡한 개념이나 긴 내용은 **단계를 나누어 제시**하고, **흐름도, 도표, 그림, 인포그래픽** 등 다양한 시각 자료를 적극적으로 활용하여 정보를 직관적으로 이해하도록 돕는다. 필요시 3D 모델링이나 AR/VR 콘텐츠와 연동할 수 있다.
    3.  **핵심 개념의 명확한 정의와 강조**: 학습 내용 중 **핵심이 되는 개념이나 용어는 명확하게 정의**하고, **볼드체, 색상, 박스 처리** 등으로 시각적으로 강조하여 학습자가 중요한 내용을 쉽게 파악하고 기억하도록 한다.
    4.  **질문과 활동을 통한 능동적 참여**: 단순히 정보를 나열하는 것을 넘어, 학습자에게 **스스로 생각하고 탐구하도록 유도하는 질문(예: '생각해 봅시다', '토론해 봅시다')**이나 **간단한 실험, 문제 해결 활동** 등을 제시하여 능동적인 학습 몰입을 유도한다.
    5.  **학습 내용의 연계성 강조**: 이전 학습 내용과 현재 학습 내용, 그리고 향후 학습 내용이 **어떻게 연결되는지 명확히 제시**하여 학습자에게 **지식의 전체적인 맥락과 구조**를 이해시키고 학습의 필요성을 인지하도록 한다.
    6.  **학습 성취감 제공**: 각 섹션이나 단원의 끝에 **간단한 점검 문제나 요약 정리**를 제공하여 학습자가 자신의 이해도를 확인하고, **학습 성취감**을 느끼도록 하여 지속적인 학습 동기를 부여한다.

---

### 제4장 경계 확장 및 창의적 접근

**제15조 (장르 간 융합을 통한 몰입도 강화)**
① 각 장르의 고유한 몰입감 유발 요소를 다른 장르에 **전략적으로 차용**하여 예상치 못한 시너지 효과를 창출하고, **글의 목적 달성 효율을 극대화**할 수 있다.
*예시 1: 에세이에서 소설의 **'복선' 기법**을 활용하여 필자의 경험 속에 숨겨진 의미를 점진적으로 드러내 독자의 흥미를 고조시킨다.*
*예시 2: 보고서에서 웹툰의 **'칸 나누기'와 유사한 시각적 흐름**을 적용하여 복잡한 데이터를 단계별로 제시하고, 핵심 내용을 이미지와 함께 효과적으로 전달한다.*
*예시 3: 법률문에서 연설문의 **'반복과 리듬'**을 활용하여 핵심 조항이나 원칙을 강조하고 독자의 기억 속에 각인되도록 한다.*
*예시 4: 교과서에서 웹소설의 **'클리프행어' 기법**을 차용하여 단원 마지막에 다음 단원에서 다룰 흥미로운 질문이나 현상을 제시하여 학습자의 궁금증을 유발한다.*
② 융합 시에는 각 장르의 본질적인 목적과 특성을 훼손하지 않는 범위 내에서 이루어져야 하며, 과도한 혼합은 오히려 글의 메시지를 혼란스럽게 하거나 독자의 이해를 저해할 수 있음에 유의한다. **균형과 목적 달성 여부**를 최우선으로 고려해야 한다.

**제16조 (독자 경험의 확장)**
글은 단순히 텍스트에 머무르지 않고, **QR 코드, 하이퍼링크, 증강 현실(AR) 콘텐츠, 가상현실(VR) 시뮬레이션, 인터랙티브 그래프** 등 디지털 요소를 통합하여 독자가 글 속 세계를 **다차원적으로 경험**하도록 유도할 수 있다. 이는 글의 몰입을 현실 공간 또는 가상 공간으로 확장시키는 역할을 한다. 특히 교과서나 기술문에서 이러한 인터랙티브 요소는 학습 및 이해도를 획기적으로 높일 수 있다.

**제17조 (작가-독자 상호작용의 활용)**
온라인 플랫폼을 통해 작가와 독자 간의 **실시간 소통**을 장려하고, 독자의 피드백을 작품에 반영하거나 Q&A 세션을 통해 궁금증을 해소함으로써 독자가 단순한 소비자를 넘어 **작품 창작의 공동 주체**라는 인식을 갖게 하여 몰입을 심화시킨다. 이는 소설, 웹툰/웹소설, 소셜 미디어 콘텐츠 등에서 특히 강력한 몰입 유발 요소로 작용한다.


</tool_for_writing>
<Final_Instruction>
Now, give me the result which fits on the {{purpose}}, considering the full <Project_Context>.
</Final_Instruction>
`;
        // Expanded and improved DEFAULT_ACTIONS based on feedback #3
        const DEFAULT_ACTIONS = [
            { key: '0_plan', title: 'AI 튜터 페르소나 및 학습 계획 생성', category: '계획', purpose: `
            나의 최종 학습 목표는 '[학습 목표]'이다. 나의 현재 수준은 '[현재 수준]'이다. 이 목표 달성을 위해, [원하는 튜터 특징]을 가진 AI 튜터의 페르소나를 해당 분야의 노벨상 이상의 학식을 가지고 30년의 실무경험을 가진 대가정의하고, 구체적인 학습 모듈과 각 모듈의 핵심 개념, 학습 목표가 포함된 상세한 학습 계획을 아래 JSON 형식으로 구체적이고 유기적이며 구조화되어 있고 필요한 모든 내용이 포함되어야 한다. 강의모듈의 갯수는 강의를 완전히 습득하는 데에 필요한 갯수로, 핵심 개념 25개 이상, 학습목표 10개 이상을 포함하여야 한다. 학습 계획에는 학습 모듈별로 적합한 [추천할 리소스 유형 (예: 교재, 영상, 논문, 웹사이트)]을 추천하는 내용도 포함되어야 한다.\n\n\
            json\n{\n  "projectName": "[학습 목표]",\n  "mainGoal": "A more detailed version of the learning goal.",\n  "tutorPersona": {\n    "name": "AI Tutor Name",\n    "characteristics": ["Characteristic 1", "Characteristic 2"]\n  },\n  "modules": [\n    {\n      "id": "M1",
      "title": "Module 1 Title",
      "keyConcepts": ["Concept A", "Concept B"],
      "learningObjectives": ["Objective 1", "Objective 2"],
      "recommendedResources": ["Resource A", "Resource B"], /* New field for resources */
      "status": "pending",
      "studyPad": "",
      "notes": ""
    }
  ]\n}
  ` },
            { key: '1_generate_material', title: '핵심 개념 학습 자료 생성', category: '이해와 탐구', purpose: `
            제1원칙 사고에 입각하여 현상의 본질을 꿰뚫는 냉철한 분석가로서, 성급한 결론을 내리지 말고, 숨을 한 번 깊게 고른 뒤 충분한 시간을 들여 문제의 모든 측면을 심사숙고한 뒤, 표면적인 분석을 넘어 문제의 복잡성을 그대로 인정하고, 목적 달성에만 집중하여 게으름 부리지 않고 최선을 다해 천천히 그러나 퀄리티를 올리는 방향으로 업무를 수행한다.

자료를 탐색할 때에는 언어의 한계를 벗어나서, 영어, 일본어, 한국어, 중국어, 프랑스어 기타 모든 언어의 자료를 출처로 삼도록 한다. 특정 언어로 검색하는 것이 더 적합하다면 그 언어를 중심으로 검색한다. 한국어에 얽메여서는 안된다.

과업 수행은 반드시 체계적인 단계별 추론에 따라 진행되어야 한다. 먼저 문제 해결을 위한 명확한 논리적 프레임워크를 머릿속으로 설계하고, 그에 따라 차근차근 단계를 밟아가라. 모든 주장에는 명확한 근거와 인과관계를 제시해야 하며, 추측성 발언이나 확인되지 않은 정보를 꾸며내는 행위(환각)는 절대 금물이다. 일반론적인 답변은 피하고, 객관적 사실과 너의 추론을 명확히 분리하여 논리의 비약이나 모순이 없는, 완결성을 갖춘 분석을 전개하라. 정보 출처를 표기할 수 있는 경우 가능한 모든 내용에 대하여 반드시 [^1], [^2]... 형태의 각주를 사용하여 출처를 논문 기준으로 표기하라. 논문 작성할 때만큼 집착적으로 모든 세세한 정보에 대하여 출처표기 작업을 수행한다. 작업에 앞서 관련 내용에 관하여 깊이 있는 리서치를 수행한다.

최종 결과물을 제출하기 직전, 잠시 멈추고 너 스스로가 가장 까다롭고 비판적인 '레드 팀(Red Team)'이 되어 생성된 내용을 검증하라. 완성된 답변에 미세한 편향은 없는지, 더 나은 대안이나 놓친 관점은 없는지, 내가 제시한 요구사항을 100% 충족하는지 최소 세 번 이상 교차 검증해야 한다. 모든 검토를 마친 최종 결과물은 군더더기 없이 명확하고 간결해야 하며, 별도의 가공 없이 즉시 현장에서 활용할 수 있는(Actionable) 완벽한 형태여야 한다. 이러한 검토과정은 명시적으로 드러내지 않고 모두 결과물에 녹아있어야한다. 출력은 오로지 요구한 결과물에 한한다.

현재 학습 모듈 '[모듈 제목]'의 핵심 개념 '[핵심 개념]'에 대해, 비전공자도 이해할 수 있도록 상세하고 체계적인 학습 자료를 생성하라. 다만 지식은 관련 연구자 박사학위자 수준으로 높일 수 있을 정도로 유기적이고 체계적으로 자료를 구성해야 한다. 주요 용어 설명, 핵심 원리, 구체적인 예시를 포함해야 한다. 다만 업계의 핵심 종사자만 알 수 있는 비밀과 경험이 자연스럼게 글에 녹아있어야 한다. 다만 이런 의도가 글에서 그 어떤 일이 있어도 드러나서는 안되며, 단순한 줄글 속에 녹아들어야한다. 글의 전반적인 톤앤메너는 존댓말을 사용하면서 교과서적이어야한다. 특히 한국어 맞춤법과 글의 유기성 구체성 체계성에 주의해야한다.
이제 이 지침을 따르며, 독자의 마음속에 깊이 스며들어 오랫동안 기억될 글을 완성하는 여정을 시작하십시오.

지식은 관련 연구자 박사학위자 수준으로 높일 수 있을 정도로 유기적이고 체계적으로 자료를 구성해야 한다. 주요 용어 설명, 핵심 원리, 구체적인 예시를 포함해야 한다. 다만 업계의 핵심 종사자만 알 수 있는 비밀과 경험이 자연스럼게 글에 녹아있어야 한다. 다만 이런 의도가 글에서 그 어떤 일이 있어도 드러나서는 안되며, 단순한 줄글 속에 녹아들어야한다. 글의 전반적인 톤앤메너는 존댓말을 사용하면서 교과서적이어야한다. 특히 한국어 맞춤법과 글의 유기성 구체성 체계성에 주의해야한다.
            ` },
            { key: '1_socrates', title: '소크라테스식 심층 탐구', category: '이해와 탐구', purpose: `현재 학습 모듈 '[모듈 제목]'의 핵심 개념 '[핵심 개념]'에 대해 나의 이해도를 심층적으로 검증하라. 스터디 패드에 작성된 내용을 바탕으로, 소크라테스식 튜터가 되어 나의 논리적 허점을 파고드는 질문을 통해 스스로 깨닫게 하라.` },
            { key: '1_summarize', title: '스터디 패드 핵심 요약', category: '이해와 탐구', purpose: `현재 학습 모듈 '[모듈 제목]'의 스터디 패드 내용을 바탕으로, 핵심 내용을 3가지 주요 항목으로 요약하라.` },
            { key: '1_analogy', title: '어려운 개념 비유/사례 생성', category: '이해와 탐구', purpose: `현재 학습 모듈 '[모듈 제목]'의 어려운 개념인 '[어려운 개념]'을(를) [대상 청중]도 쉽게 이해할 수 있도록 3가지 이상의 창의적이고 직관적인 비유나 현실 세계의 사례를 들어 설명하라.`},
            { key: '1_mindmap', title: '핵심 개념 마인드맵 생성', category: '이해와 탐구', purpose: `현재 학습 모듈 '[모듈 제목]'의 핵심 개념들을 중심으로, 그들의 관계와 계층 구조를 보여주는 마인드맵을 마크다운 형식으로 생성하라.` },
            { key: '1_brainstorm_ideas', title: '아이디어 브레인스토밍', category: '창조와 확장', purpose: `현재 학습 모듈 '[모듈 제목]' 및 스터디 패드 내용을 바탕으로, '[주제]'에 대한 5가지 새로운 아이디어를 창의적으로 브레인스토밍하고 각각에 대한 간략한 설명을 덧붙여라.` },
            { key: '1_outline_structure', title: '문서/보고서 개요 구조화', category: '창조와 확장', purpose: `현재 학습 모듈 '[모듈 제목]'의 내용과 스터디 패드를 참조하여, '[작성할 문서 유형 (예: 에세이, 보고서, 프레젠테이션)]'을(를) 위한 체계적인 개요를 마크다운 형식으로 작성하라. 필요한 경우, '[초점 키워드]'를 강조하라.` },
            { key: '2_practice_problems', title: '맞춤형 연습문제 생성 및 해설', category: '적용과 연습', purpose: `현재 학습 모듈 '[모듈 제목]'의 내용과 핵심 개념 '[핵심 개념]'에 대해, 나의 이해도를 평가할 수 있는 맞춤형 연습문제를 3개 생성하라. 문제 유형은 단답형, 객관식, 시나리오 기반 주관식을 포함해야 하며, 모든 문제에 상세한 해설을 덧붙여라.` },
            { key: '2_flashcards', title: '핵심 어휘 플래시카드 생성 (어학)', category: '적용과 연습', purpose: `현재 학습 모듈 '[모듈 제목]'의 스터디 패드 내용에서 핵심 어휘와 그 의미를 추출하여, "단어: 의미" 형식의 플래시카드 목록을 10개 생성하라.` },
            { key: '2_case_study', title: '실제 사례 분석 (IRAC/SWOT)', category: '적용과 연습', purpose: `현재 학습 모듈 '[모듈 제목]'의 스터디 패드에 제시된 '[사례명]' 사례를 바탕으로, [분석 프레임워크 (예: IRAC, SWOT)] 원칙에 따라 법률적 또는 경영학적 분석을 수행하라.`},
            { key: '2_problem_solving', title: '공학 문제 해결 절차 분석', category: '적용과 연습', purpose: `현재 학습 모듈 '[모듈 제목]'의 스터디 패드에 제시된 공학적 문제 '[문제 설명]'을(를) 해결하기 위한 단계별 절차를 명확하게 제시하고, 각 단계에서 사용되는 원리나 공식을 설명하라.`},
            { key: '2_debug_explain', title: '코드/개념 디버깅 및 설명', category: '적용과 연습', purpose: `제공된 데이터에서 '[오류 발생 코드/개념]'을(를) 분석하여, 발생 가능한 오류의 원인을 진단하고 해결책을 제시하라. 또한, 해당 코드/개념의 작동 방식을 비전문가도 이해할 수 있도록 명확하게 설명하라.`},
            { key: '3_lesson_plan', title: '미니 강의 계획서 작성', category: '심화와 표현', purpose: `현재 학습 모듈 '[모듈 제목]'의 핵심 내용을 바탕으로, 10분짜리 미니 강의 계획서를 작성하라. 강의 목표, 주요 내용, 예시, 질의응답 시간을 포함해야 한다.`},
            { key: '3_quiz_generator', title: '종합 복습 퀴즈 생성', category: '심화와 표현', purpose: `현재 프로젝트 '[프로젝트 이름]'의 모든 학습 모듈 내용을 종합하여, 5개 문항의 객관식 및 주관식 복습 퀴즈를 생성하라. 각 문항에는 정답과 상세 해설을 포함하라.`},
            { key: '3_essay_prompts', title: '논술형 질문 생성', category: '심화와 표현', purpose: `현재 학습 모듈 '[모듈 제목]'의 스터디 패드 내용을 기반으로, 비판적 사고를 유도하는 3가지 논술형 질문을 생성하라. 각 질문에는 답변에 포함될 핵심 요소에 대한 가이드를 포함하라.`}
        ];

        document.addEventListener('DOMContentLoaded', () => {
            // --- App State ---
            const App = {
                db: { projects: {}, activeProjectId: null, currentUser: null }, // Added currentUser
                bs: {}, 
                dom: {}, 
                state: { saveTimeout: null, currentModuleIndexForViewer: null, scrollPositions: {} }, // Added scrollPositions
            };

            // --- 1. Initialization ---
            function initApp() {
                cacheDOMElements();
                initBootstrap();
                loadDb(); // Load local UI state and activeProjectId
                // Firebase auth state listener will handle loading user projects
                registerEventListeners();
                console.log("ILE App v8.5 Initialized");
            }
            
            function cacheDOMElements() {
                App.dom.sidebar = document.getElementById('sidebar');
                App.dom.overlay = document.getElementById('overlay');
                App.dom.projectList = document.getElementById('project-list');
                App.dom.resourceList = document.getElementById('resource-list');
                App.dom.welcomeScreen = document.getElementById('welcome-screen');
                App.dom.projectWorkspace = document.getElementById('project-workspace');
                App.dom.learningDashboard = document.getElementById('learning-dashboard');
                App.dom.planInput = document.getElementById('plan-input');
                App.dom.projectTitleMain = document.getElementById('project-title-main');
                App.dom.projectTitleMobile = document.getElementById('project-title-mobile');
                App.dom.projectGoal = document.getElementById('project-goal');
                // Added ID for the plan button in cacheDOMElements
                App.dom.planButton = document.getElementById('plan-button'); 
                App.dom.actionListContainer = document.getElementById('action-list-container');
                App.dom.actionSelectorBody = document.getElementById('action-selector-body');
                App.dom.promptModalLabel = document.getElementById('promptModalLabel');
                App.dom.dynamicFormContainer = document.getElementById('dynamic-form-container');
                App.dom.dataSelector = document.getElementById('data-selector');
                App.dom.livePreviewContainer = document.getElementById('live-preview-container');
                App.dom.studyPadViewerModal = document.getElementById('studyPadViewerModal');
                App.dom.studyPadViewerContent = document.getElementById('study-pad-viewer-content');
                App.dom.studyPadEditorContent = document.getElementById('study-pad-editor-content'); // New editor textarea
                App.dom.studyPadViewerTitle = document.getElementById('studyPadViewerTitle');
                App.dom.toggleViewerModeBtn = document.getElementById('toggle-viewer-mode-btn'); // New toggle button
                App.dom.saveViewerContentBtn = document.getElementById('save-viewer-content-btn'); // New save button

                // For learning progress visualization
                App.dom.overallProgressBar = document.getElementById('overall-progress-bar');
                App.dom.completedModulesCount = document.getElementById('completed-modules-count');
                App.dom.inprogressModulesCount = document.getElementById('inprogress-modules-count');
                App.dom.pendingModulesCount = document.getElementById('pending-modules-count');
                App.dom.moduleStatusChart = document.getElementById('module-status-chart');
                App.chart = null; // To hold the Chart.js instance

                // New elements for authentication
                App.dom.authStatus = document.getElementById('auth-status');
                App.dom.googleSigninBtn = document.getElementById('google-signin-btn');
                App.dom.signOutBtn = document.getElementById('signout-btn');

                // New elements for detail viewer modal
                App.dom.detailViewerModal = document.getElementById('detailViewerModal');
                App.dom.detailViewerTitle = document.getElementById('detailViewerTitle');
                App.dom.detailViewerBody = document.getElementById('detailViewerBody');
            }

            function initBootstrap() {
                App.bs.toast = new bootstrap.Toast(document.getElementById('liveToast'));
                App.bs.resourceModal = new bootstrap.Modal(document.getElementById('resourceModal'));
                App.bs.promptModal = new bootstrap.Modal(document.getElementById('promptModal'));
                App.bs.actionManagerModal = new bootstrap.Modal(document.getElementById('actionManagerModal'));
                App.bs.actionEditorModal = new bootstrap.Modal(document.getElementById('actionEditorModal'));
                App.bs.actionSelectorModal = new bootstrap.Modal(document.getElementById('actionSelectorModal'));
                App.bs.newProjectModal = new bootstrap.Modal(document.getElementById('newProjectModal'));
                App.bs.studyPadViewerModal = new bootstrap.Modal(App.dom.studyPadViewerModal); // Initialize new modal
                App.bs.detailViewerModal = new bootstrap.Modal(App.dom.detailViewerModal); // Initialize new detail modal
            }
            
            // --- Firebase Auth Functions ---
            async function signInWithGoogle() {
                const provider = new GoogleAuthProvider();
                try {
                    await signInWithPopup(auth, provider);
                    showToast("환영합니다!", "성공적으로 로그인되었습니다.", "success");
                } catch (error) {
                    console.error("Google 로그인 실패:", error);
                    showToast("로그인 실패", "Google 로그인 중 오류가 발생했습니다: " + error.message, "danger");
                }
            }

            async function signOutUser() {
                try {
                    await signOut(auth);
                    showToast("안녕히 가세요!", "로그아웃되었습니다.", "info");
                } catch (error) {
                    console.error("로그아웃 실패:", error);
                    showToast("로그아웃 실패", "로그아웃 중 오류가 발생했습니다: " + error.message, "danger");
                }
            }

            // Listen for authentication state changes
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    App.dom.authStatus.textContent = `${user.displayName}님 환영합니다!`;
                    App.dom.googleSigninBtn.classList.add('d-none');
                    App.dom.signOutBtn.classList.remove('d-none');
                    App.db.currentUser = {
                        uid: user.uid,
                        displayName: user.displayName,
                        email: user.email
                    };
                    await loadUserProjectsFromFirestore(user.uid); // Load user-specific projects
                    render(); // Render after data is loaded from Firestore
                    showToast("로그인됨", `${user.displayName}님 환영합니다!`, "info");
                } else {
                    App.dom.authStatus.textContent = "로그인이 필요합니다.";
                    App.dom.googleSigninBtn.classList.remove('d-none');
                    App.dom.signOutBtn.classList.add('d-none');
                    App.db.currentUser = null;
                    App.db.activeProjectId = null;
                    App.db.projects = {}; // Clear local projects on logout
                    saveDb(); // Save local UI state (activeProjectId will be null)
                    render(); // Re-render to show welcome screen
                    showToast("로그아웃됨", "로그인하여 프로젝트를 관리하세요.", "info");
                }
            });

            // --- Firestore Data Management Functions ---
            async function loadUserProjectsFromFirestore(userId) {
                App.db.projects = {}; // Clear existing projects
                try {
                    const projectsColRef = collection(db, `users/${userId}/projects`);
                    const q = query(projectsColRef);
                    const querySnapshot = await getDocs(q);

                    querySnapshot.forEach((doc) => {
                        const projectData = doc.data();
                        App.db.projects[doc.id] = { id: doc.id, ...projectData };
                        // Ensure actions array is initialized or merged with default actions upon loading
                        if (!App.db.projects[doc.id].actions || App.db.projects[doc.id].actions.length === 0) {
                            App.db.projects[doc.id].actions = JSON.parse(JSON.stringify(DEFAULT_ACTIONS));
                        } else {
                            DEFAULT_ACTIONS.forEach(defaultAction => {
                                if (!App.db.projects[doc.id].actions.some(a => a.key === defaultAction.key)) {
                                    App.db.projects[doc.id].actions.push(defaultAction);
                                }
                            });
                        }
                    });

                    // Set active project if one existed, or the first one if available
                    if (App.db.activeProjectId && App.db.projects[App.db.activeProjectId]) {
                        // Active project already set, keep it
                    } else if (Object.keys(App.db.projects).length > 0) {
                        App.db.activeProjectId = Object.keys(App.db.projects)[0];
                    } else {
                        App.db.activeProjectId = null;
                    }
                    console.log("Firebase에서 프로젝트 로드 완료");
                } catch (e) {
                    console.error("Firebase에서 프로젝트 로드 실패:", e);
                    showToast("데이터 로드 오류", "프로젝트를 불러오지 못했습니다.", "danger");
                }
            }

            async function saveProjectToFirestore(project) {
                if (!App.db.currentUser?.uid) {
                    showToast("오류", "로그인이 필요합니다.", "danger");
                    return false;
                }
                try {
                    const projectRef = doc(db, `users/${App.db.currentUser.uid}/projects`, project.id);
                    await setDoc(projectRef, project);
                    console.log(`프로젝트 '${project.name}' Firebase에 저장됨`);
                    return true;
                } catch (e) {
                    console.error("Firebase에 프로젝트 저장 실패:", e);
                    showToast("저장 실패", "프로젝트를 저장하지 못했습니다.", "danger");
                    return false;
                }
            }

            async function deleteProjectFromFirestore(projectId) {
                if (!App.db.currentUser?.uid) {
                    showToast("오류", "로그인이 필요합니다.", "danger");
                    return false;
                }
                try {
                    const projectRef = doc(db, `users/${App.db.currentUser.uid}/projects`, projectId);
                    await deleteDoc(projectRef);
                    console.log(`프로젝트 '${projectId}' Firebase에서 삭제됨`);
                    return true;
                } catch (e) {
                    console.error("Firebase에서 프로젝트 삭제 실패:", e);
                    showToast("삭제 실패", "프로젝트를 삭제하지 못했습니다.", "danger");
                    return false;
                }
            }

            // --- 2. Data Management (Local UI State) ---
            function saveDb() {
                try {
                    const localData = {
                        activeProjectId: App.db.activeProjectId,
                        scrollPositions: App.state.scrollPositions // Save scroll positions locally
                    };
                    localStorage.setItem('ile_local_ui_state', JSON.stringify(localData));
                } catch (e) {
                    console.error("로컬 UI 상태 저장 실패:", e);
                    showToast("오류", "로컬 설정 저장에 실패했습니다.", "danger");
                }
            }

            function loadDb() {
                try {
                    const stored = localStorage.getItem('ile_local_ui_state');
                    if (stored) {
                        const localData = JSON.parse(stored);
                        App.db.activeProjectId = localData.activeProjectId || null;
                        App.state.scrollPositions = localData.scrollPositions || {};
                    }
                } catch (e) {
                    console.error("로컬 UI 상태 불러오기 실패:", e);
                    App.db.activeProjectId = null;
                    App.state.scrollPositions = {};
                    showToast("경고", "로컬 설정을 불러오는 중 오류가 발생하여 초기화합니다.", "warning");
                }
            }

            function showToast(title, body, type = 'info') {
                const toastEl = document.getElementById('liveToast');
                if (!toastEl) return;
                toastEl.style.borderColor = `var(--${type}-color, var(--border-color))`;
                document.getElementById('toast-title').textContent = title;
                document.getElementById('toast-body').textContent = body;
                App.bs.toast.show();
            }

            // --- 3. UI Rendering ---
            function render() {
                renderProjectList();
                renderWorkspace();
            }

            function renderProjectList() {
                const listEl = App.dom.projectList;
                if (!listEl) return;
                listEl.innerHTML = ''; // Clear previous content

                if (!App.db.currentUser) {
                    listEl.innerHTML = `<p class="small text-secondary px-2 py-2">로그인 후 프로젝트를 이용할 수 있습니다.</p>`;
                    return;
                }

                const projectIds = Object.keys(App.db.projects);

                if (projectIds.length === 0) {
                    listEl.innerHTML = `<p class="small text-secondary px-2 py-2">프로젝트가 없습니다.</p>`;
                    return;
                }

                projectIds.forEach(id => {
                    const p = App.db.projects[id];
                    const item = document.createElement('a');
                    item.href = '#';
                    item.className = `list-group-item list-group-item-action d-flex justify-content-between align-items-center ${p.id === App.db.activeProjectId ? 'active' : ''}`;
                    item.dataset.projectId = p.id;
                    item.innerHTML = `
                        <span class="text-truncate" style="max-width: 85%;">${p.name}</span>
                        <i class="fa-solid fa-trash-can text-secondary small delete-btn" title="프로젝트 삭제"></i>
                    `;
                    listEl.appendChild(item);
                });
            }
            
            function renderWorkspace() {
                const project = App.db.projects[App.db.activeProjectId];
                if (!project) {
                    App.dom.welcomeScreen?.classList.remove('d-none');
                    App.dom.projectWorkspace?.classList.add('d-none');
                    if (App.dom.projectTitleMobile) App.dom.projectTitleMobile.textContent = "ILE v8.5"; // Updated version
                    return;
                }

                App.dom.welcomeScreen?.classList.add('d-none');
                App.dom.projectWorkspace?.classList.remove('d-none');
                
                App.dom.projectTitleMain.textContent = project.name;
                App.dom.projectTitleMobile.textContent = project.name;
                App.dom.projectGoal.textContent = project.goal;
                App.dom.planInput.value = project.learningPlan ? JSON.stringify(project.learningPlan, null, 2) : '';
                
                renderResourceList();
                renderLearningDashboard();
            }

            function renderResourceList() {
                const listEl = App.dom.resourceList;
                if (!listEl) return;
                listEl.innerHTML = '';
                const project = App.db.projects[App.db.activeProjectId];
                
                if (!project?.resources?.length) {
                    listEl.innerHTML = `<p class="small text-secondary px-2">자원이 없습니다.</p>`;
                    return;
                }

                project.resources.forEach(r => {
                    const item = document.createElement('div');
                    item.className = 'list-group-item d-flex justify-content-between align-items-center';
                    item.dataset.resourceId = r.id;
                    item.style.cursor = 'pointer';
                    item.innerHTML = `
                        <span class="text-truncate" style="max-width: 85%;">${r.name}</span>
                        <i class="fa-solid fa-times text-secondary small delete-btn" title="자원 삭제" style="cursor: pointer;"></i>
                    `;
                    listEl.appendChild(item);
                });
            }
            
            function renderLearningDashboard() {
                const dashboard = App.dom.learningDashboard;
                if (!dashboard) return;
                const project = App.db.projects[App.db.activeProjectId];
                const plan = project?.learningPlan;

                if (!plan?.modules?.length) {
                    dashboard.innerHTML = '<p class="text-secondary text-center small col-12">학습 계획을 먼저 적용해주세요.</p>';
                    return;
                }

                dashboard.innerHTML = '';
                plan.modules.forEach((module, index) => {
                    const card = document.createElement('div');
                    card.className = `module-card status-${module.status || 'pending'}`;
                    card.dataset.moduleIndex = index;

                    // Truncate learning objectives and add a "자세히 보기" button
                    const learningObjectivesText = (module.learningObjectives || []).join(', ');
                    const displayLearningObjectives = `<b>학습 목표:</b> <span class="learning-objectives-preview">${learningObjectivesText || '없음'}</span>`;
                    const viewObjectivesButton = learningObjectivesText.length > 50 ? // Adjust length as needed
                        `<button class="btn btn-link btn-sm p-0 d-block mt-1 view-details-btn" data-detail-type="learning-objectives" data-module-index="${index}">자세히 보기</button>` : '';

                    card.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <h6 class="mb-0 text-truncate">${module.title}</h6>
                            <div class="dropdown">
                                <button class="btn btn-sm btn-outline-secondary dropdown-toggle py-0 px-2" type="button" data-bs-toggle="dropdown">상태</button>
                                <ul class="dropdown-menu">
                                    <li><a class="dropdown-item status-change-btn" href="#" data-status="pending">대기</a></li>
                                    <li><a class="dropdown-item status-change-btn" href="#" data-status="inprogress">진행 중</a></li>
                                    <li><a class="dropdown-item status-change-btn" href="#" data-status="completed">완료</a></li>
                                </ul>
                            </div>
                        </div>
                        <p class="small text-secondary mb-2"><b>핵심 개념:</b> ${(module.keyConcepts || []).join(', ')}</p>
                        <p class="small mb-3">${displayLearningObjectives}${viewObjectivesButton}</p>
                        ${module.recommendedResources && module.recommendedResources.length > 0 ? 
                            `<p class="small text-primary mb-3"><b>추천 리소스:</b> ${module.recommendedResources.join(', ')}</p>` : ''
                        }
                        <div class="mb-2">
                            <label class="form-label small">스터디 패드</label>
                            <textarea class="form-control form-control-sm module-studypad" placeholder="이 모듈에 대한 AI 생성 학습 내용을 여기에 붙여넣으세요...">${module.studyPad || ''}</textarea>
                            <button class="btn btn-sm btn-outline-primary mt-2 view-studypad-btn" data-module-index="${index}"><i class="fa-solid fa-eye me-1"></i> 스터디 패드 보기</button>
                        </div>
                        <div class="mb-3">
                            <label class="form-label small">개인 메모</label>
                            <textarea class="form-control form-control-sm module-notes" placeholder="생각, 질문 등을 자유롭게 메모하세요...">${module.notes || ''}</textarea>
                        </div>
                        <button class="btn btn-sm btn-info w-100 open-action-selector"><i class="fa-solid fa-person-chalkboard me-2"></i>액션 실행</button>
                    `;
                    dashboard.appendChild(card);
                });

                // Calculate progress and update stats
                const totalModules = plan.modules.length;
                const completedModules = plan.modules.filter(m => m.status === 'completed').length;
                const inprogressModules = plan.modules.filter(m => m.status === 'inprogress').length;
                const pendingModules = totalModules - completedModules - inprogressModules;

                const completionPercentage = totalModules > 0 ? Math.round((completedModules / totalModules) * 100) : 0;

                // Update overall progress bar color based on status
                let progressBarColor = 'var(--text-secondary)'; // Default for pending
                if (completionPercentage > 0 && completionPercentage < 100) {
                    progressBarColor = 'var(--warning-color)'; // In progress
                } else if (completionPercentage === 100) {
                    progressBarColor = 'var(--success-color)'; // Completed
                }
                App.dom.overallProgressBar.style.width = `${completionPercentage}%`;
                App.dom.overallProgressBar.setAttribute('aria-valuenow', completionPercentage);
                App.dom.overallProgressBar.textContent = `${completionPercentage}%`;
                App.dom.overallProgressBar.style.backgroundColor = progressBarColor;


                App.dom.completedModulesCount.textContent = completedModules;
                App.dom.inprogressModulesCount.textContent = inprogressModules;
                App.dom.pendingModulesCount.textContent = pendingModules;

                // Chart.js rendering
                if (App.chart) {
                    App.chart.destroy(); // Destroy previous chart instance if exists
                }
                if (totalModules > 0 && App.dom.moduleStatusChart) {
                    const ctx = App.dom.moduleStatusChart.getContext('2d');
                    // Define colors directly using the hex values from :root CSS variables for reliability
                    const successColor = '#34A853';
                    const warningColor = '#FBBC04';
                    const secondaryTextColor = '#5F6368'; // This is --text-secondary
                    const primaryTextColor = '#3C4043'; // This is --text-primary

                    App.chart = new Chart(ctx, {
                        type: 'doughnut', // Pie chart for statuses
                        data: {
                            labels: ['완료', '진행 중', '대기'],
                            datasets: [{
                                data: [completedModules, inprogressModules, pendingModules],
                                backgroundColor: [
                                    successColor,
                                    warningColor,
                                    secondaryTextColor
                                ],
                                hoverOffset: 4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'right',
                                    labels: {
                                        color: primaryTextColor, // Adjust legend color for light theme
                                    }
                                },
                                title: {
                                    display: true,
                                    text: '모듈 상태 분석',
                                    color: primaryTextColor, // Adjust title color
                                }
                            }
                        }
                    });
                }
            }

            function renderActionSelector(moduleIndex) {
                const body = App.dom.actionSelectorBody;
                const project = App.db.projects[App.db.activeProjectId];
                // Ensure DEFAULT_ACTIONS are always included if the project's actions array is empty or undefined
                const actions = project?.actions && project.actions.length > 0 ? project.actions : DEFAULT_ACTIONS;

                const groupedActions = actions.reduce((acc, action) => {
                    if (action.key === '0_plan') return acc;
                    const category = action.category || '기타';
                    if (!acc[category]) acc[category] = [];
                    acc[category].push(action);
                    return acc;
                }, {});

                body.innerHTML = '';
                for (const category of Object.keys(groupedActions).sort()) {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'action-category mb-4';
                    categoryDiv.innerHTML = `<h6 class="mb-3">${category}</h6>`;
                    const actionGrid = document.createElement('div');
                    actionGrid.className = 'd-grid gap-2';
                    groupedActions[category].forEach(action => {
                        const button = document.createElement('button');
                        button.className = 'btn btn-outline-light text-start build-prompt-btn';
                        button.dataset.templateKey = action.key;
                        button.dataset.moduleIndex = moduleIndex;
                        button.textContent = action.title;
                        actionGrid.appendChild(button);
                    });
                    categoryDiv.appendChild(actionGrid);
                    body.appendChild(categoryDiv);
                }
                App.bs.actionSelectorModal.show();
            }

            function renderActionManager() {
                const container = App.dom.actionListContainer;
                if (!container) return;
                const project = App.db.projects[App.db.activeProjectId];
                // Ensure DEFAULT_ACTIONS are always included if the project's actions array is empty or undefined
                const actions = project?.actions && project.actions.length > 0 ? project.actions : DEFAULT_ACTIONS;

                container.innerHTML = actions.map(action => {
                    if(action.key === '0_plan') return ''; 
                    return `
                    <div class="p-3 rounded mb-2 d-flex justify-content-between align-items-center action-list-item">
                        <div>
                            <h6 class="mb-0">${action.title}</h6>
                            <small class="text-secondary">${action.category} / Key: ${action.key}</small>
                        </div>
                        <div>
                            <button class="btn btn-sm btn-outline-light edit-action-btn" data-action-key="${action.key}"><i class="fa-solid fa-pencil"></i></button>
                            <button class="btn btn-sm btn-outline-danger delete-action-btn" data-action-key="${action.key}"><i class="fa-solid fa-trash-can"></i></button>
                        </div>
                    </div>`;
                }).join('');
            }

            // --- 4. Core Logic & Handlers ---
            
            // Helper Functions
            function readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => {
                        reader.abort();
                        reject(new DOMException("파일 읽기 중 문제가 발생했습니다."));
                    };
                    reader.readAsText(file);
                });
            }

            async function copyToClipboard(text) {
                if (navigator.clipboard?.writeText) {
                    try {
                        await navigator.clipboard.writeText(text);
                        showToast("성공", "프롬프트가 클립보드에 복사되었습니다.", "success");
                        return;
                    } catch (err) { console.warn("Clipboard API 실패, 폴백 시도:", err); }
                }
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.opacity = "0";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    showToast("성공", "프롬프트가 클립보드에 복사되었습니다.", "success");
                } catch (err) {
                    showToast("오류", "프롬프트 복사에 실패했습니다.", "danger");
                    console.error("폴백 복사 실패:", err);
                }
                document.body.removeChild(textArea);
            }

            // Project Management
            function switchActiveProject(projectId) {
                App.db.activeProjectId = projectId;
                saveDb();
                render();
                App.dom.sidebar?.classList.remove('is-open');
                App.dom.overlay?.classList.remove('is-visible');
            }

            async function createNewProject(name, goal) {
                if (!App.db.currentUser?.uid) {
                    showToast("오류", "먼저 로그인해주세요.", "danger");
                    return;
                }
                const id = doc(collection(db, `users/${App.db.currentUser.uid}/projects`)).id; // Generate Firestore ID
                const newProject = {
                    id,
                    name,
                    goal,
                    resources: [],
                    learningPlan: null,
                    actions: JSON.parse(JSON.stringify(DEFAULT_ACTIONS)) // Deep copy default actions
                };
                const success = await saveProjectToFirestore(newProject);
                if (success) {
                    App.db.projects[id] = newProject; // Add to local state after successful Firestore save
                    switchActiveProject(id);
                    showToast("성공", `'${name}' 프로젝트가 생성되었습니다.`, "success");
                }
            }
            
            async function deleteProject(projectId) {
                if (!App.db.currentUser?.uid) {
                    showToast("오류", "로그인이 필요합니다.", "danger");
                    return;
                }
                const projectName = App.db.projects[projectId]?.name || "이";
                if (!window.confirm(`'${projectName}' 프로젝트를 정말 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`)) {
                    return;
                }

                const success = await deleteProjectFromFirestore(projectId);
                if (success) {
                    delete App.db.projects[projectId];
                    if (App.db.activeProjectId === projectId) {
                        App.db.activeProjectId = Object.keys(App.db.projects)[0] || null;
                    }
                    saveDb();
                    render();
                    showToast("성공", "프로젝트가 삭제되었습니다.", "success");
                }
            }

            // Module Management
            function updateModuleField(index, field, value) {
                const project = App.db.projects[App.db.activeProjectId];
                if (!project?.learningPlan?.modules[index]) return;

                project.learningPlan.modules[index][field] = value;
                // Debounce Firestore save for module updates
                clearTimeout(App.state.saveTimeout);
                App.state.saveTimeout = setTimeout(() => {
                    saveProjectToFirestore(project);
                    renderLearningDashboard(); // Re-render to update UI (e.g., progress bar)
                }, 1000); // Save after 1 second of inactivity
            }
            
            // Action (Prompt Template) Management
            function openActionEditor(actionKey = null) {
                const form = document.getElementById('action-editor-form');
                if (!form) return;
                form.reset();
                const project = App.db.projects[App.db.activeProjectId];
                const action = actionKey ? project?.actions.find(a => a.key === actionKey) : null;
                
                document.getElementById('actionEditorTitle').textContent = action ? '액션 편집' : '새 액션 추가';
                document.getElementById('action-key-input').value = action ? action.key : `custom_${Date.now()}`;
                if (action) {
                    document.getElementById('action-title-input').value = action.title;
                    document.getElementById('action-category-input').value = action.category;
                    document.getElementById('action-purpose-input').value = action.purpose;
                }
                App.bs.actionEditorModal.show();
            }

            async function saveAction() {
                const project = App.db.projects[App.db.activeProjectId];
                if (!project) return;
                if (!App.db.currentUser?.uid) {
                    showToast("오류", "로그인이 필요합니다.", "danger");
                    return;
                }

                const key = document.getElementById('action-key-input').value;
                const updatedAction = {
                    key: key,
                    title: document.getElementById('action-title-input').value.trim(),
                    category: document.getElementById('action-category-input').value.trim(),
                    purpose: document.getElementById('action-purpose-input').value,
                };
                if (!updatedAction.title || !updatedAction.category || !updatedAction.purpose) {
                    return showToast('오류', '모든 필드를 입력해야 합니다.', 'danger');
                }
                
                if (!project.actions) project.actions = [];
                const existingIndex = project.actions.findIndex(a => a.key === key);
                if (existingIndex > -1) {
                    project.actions[existingIndex] = updatedAction;
                } else {
                    project.actions.push(updatedAction);
                }
                
                const success = await saveProjectToFirestore(project);
                if (success) {
                    renderActionManager();
                    App.bs.actionEditorModal.hide();
                    showToast('성공', '액션이 저장되었습니다.', 'success');
                }
            }

            async function deleteAction(actionKey) {
                if (!App.db.currentUser?.uid) {
                    showToast("오류", "로그인이 필요합니다.", "danger");
                    return;
                }
                if (!window.confirm('이 액션을 정말 삭제하시겠습니까?')) {
                    return;
                }

                const project = App.db.projects[App.db.activeProjectId];
                if (!project?.actions) return;
                project.actions = project.actions.filter(a => a.key !== actionKey);
                
                const success = await saveProjectToFirestore(project);
                if (success) {
                    renderActionManager();
                    showToast('성공', '액션이 삭제되었습니다.', 'success');
                }
            }

            // New Feature: Download All Study Pads (Point 4)
            function downloadAllStudyPads() {
                const project = App.db.projects[App.db.activeProjectId];
                if (!project || !project.learningPlan?.modules?.length) {
                    return showToast("정보", "다운로드할 스터디 패드 내용이 없습니다.", "info");
                }

                let combinedContent = `# ${project.name}\n\n`;
                combinedContent += `## 최종 학습 목표\n${project.goal || '없음'}\n\n`;
                combinedContent += `---\n\n`;

                project.learningPlan.modules.forEach((module, index) => {
                    combinedContent += `## ${index + 1}. ${module.title}\n\n`;
                    combinedContent += `### 핵심 개념: ${(module.keyConcepts || []).join(', ')}\n\n`;
                    combinedContent += `### 학습 목표: ${(module.learningObjectives || []).join(', ')}\n\n`;
                    if (module.recommendedResources && module.recommendedResources.length > 0) {
                        combinedContent += `### 추천 리소스: ${module.recommendedResources.join(', ')}\n\n`;
                    }
                    combinedContent += `### 스터디 패드\n\n`;
                    combinedContent += `${module.studyPad || '작성된 내용 없음.'}\n\n`;
                    if (module.notes) {
                        combinedContent += `### 개인 메모\n\n`;
                        combinedContent += `${module.notes}\n\n`;
                    }
                    combinedContent += `---\n\n`;
                });

                const blob = new Blob([combinedContent], { type: 'text/markdown;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const safeFileName = project.name.replace(/[/\\?%*:|"<>]/g, '-') || 'study-pads';
                a.href = url;
                a.download = `${safeFileName}_study_pads.md`;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 100);
                showToast("성공", "스터디 패드 내용이 다운로드되었습니다.", "success");
            }

            // New Feature: Study Pad Viewer (Markdown Rendering) & In-line Editing
            function openStudyPadViewer(moduleIndex) {
                const project = App.db.projects[App.db.activeProjectId];
                if (!project || !project.learningPlan?.modules[moduleIndex]) {
                    return showToast("오류", "모듈을 찾을 수 없습니다.", "danger");
                }
                const module = project.learningPlan.modules[moduleIndex];
                
                App.state.currentModuleIndexForViewer = moduleIndex; // Store current module index
                
                // Set initial mode to viewer mode
                App.dom.studyPadViewerContent.classList.remove('d-none');
                App.dom.studyPadEditorContent.classList.add('d-none');
                App.dom.toggleViewerModeBtn.textContent = '편집 모드';
                App.dom.saveViewerContentBtn.classList.add('d-none');

                App.dom.studyPadViewerTitle.textContent = `${module.title} 스터디 패드`;
                // Use marked.js to convert Markdown to HTML
                App.dom.studyPadViewerContent.innerHTML = marked.parse(module.studyPad || '내용이 없습니다.');
                App.dom.studyPadEditorContent.value = module.studyPad || ''; // Populate editor with raw content
                
                App.bs.studyPadViewerModal.show();

                // Restore scroll position when modal opens
                App.dom.studyPadViewerModal.addEventListener('shown.bs.modal', function handler() {
                    const savedScroll = App.state.scrollPositions[`module_${moduleIndex}`];
                    if (savedScroll !== undefined) {
                        App.dom.studyPadViewerContent.scrollTop = savedScroll;
                        App.dom.studyPadEditorContent.scrollTop = savedScroll; // Apply to editor too
                    }
                    App.dom.studyPadViewerModal.removeEventListener('shown.bs.modal', handler); // Remove listener after first execution
                });

                // Call MathJax to render equations after content is set
                if (typeof MathJax !== 'undefined') {
                    MathJax.typesetPromise([App.dom.studyPadViewerContent]).catch((err) => console.error('MathJax rendering failed:', err));
                }
            }

            function toggleStudyPadViewerMode() {
                const moduleIndex = App.state.currentModuleIndexForViewer;
                const isEditing = App.dom.studyPadViewerContent.classList.contains('d-none'); // True if editor is currently hidden

                // Save current scroll position before switching modes
                const currentScroll = isEditing ? App.dom.studyPadEditorContent.scrollTop : App.dom.studyPadViewerContent.scrollTop;
                App.state.scrollPositions[`module_${moduleIndex}`] = currentScroll;
                saveDb(); // Save local UI state

                if (!isEditing) { // Currently in viewer mode, switch to editor mode
                    App.dom.studyPadViewerContent.classList.add('d-none');
                    App.dom.studyPadEditorContent.classList.remove('d-none');
                    App.dom.toggleViewerModeBtn.textContent = '뷰어 모드';
                    App.dom.saveViewerContentBtn.classList.remove('d-none');
                    App.dom.studyPadEditorContent.focus();
                    // Restore scroll position for the editor
                    App.dom.studyPadEditorContent.scrollTop = currentScroll;
                } else { // Currently in editor mode, switch to viewer mode
                    App.dom.studyPadViewerContent.innerHTML = marked.parse(App.dom.studyPadEditorContent.value);
                    
                    // Call MathJax to render equations after content is set
                    if (typeof MathJax !== 'undefined') {
                        MathJax.typesetPromise([App.dom.studyPadViewerContent]).catch((err) => console.error('MathJax rendering failed:', err));
                    }

                    App.dom.studyPadViewerContent.classList.remove('d-none');
                    App.dom.studyPadEditorContent.classList.add('d-none');
                    App.dom.toggleViewerModeBtn.textContent = '편집 모드';
                    App.dom.saveViewerContentBtn.classList.add('d-none');
                    // Restore scroll position for the viewer
                    App.dom.studyPadViewerContent.scrollTop = currentScroll;
                }
            }

            function saveStudyPadViewerContent() {
                const moduleIndex = App.state.currentModuleIndexForViewer;
                if (moduleIndex === null) {
                    showToast("오류", "저장할 모듈을 찾을 수 없습니다.", "danger");
                    return;
                }
                const newStudyPadContent = App.dom.studyPadEditorContent.value;
                updateModuleField(moduleIndex, 'studyPad', newStudyPadContent); // This will save to DB
                showToast("성공", "스터디 패드 내용이 저장되었습니다.", "success");
                toggleStudyPadViewerMode(); // Switch back to viewer mode after saving
            }

            // New function to open the detail viewer modal
            function openDetailViewer(moduleIndex, type) {
                const project = App.db.projects[App.db.activeProjectId];
                if (!project || !project.learningPlan?.modules[moduleIndex]) {
                    return showToast("오류", "모듈을 찾을 수 없습니다.", "danger");
                }
                const module = project.learningPlan.modules[moduleIndex];
                let title = '';
                let content = '';

                if (type === 'learning-objectives') {
                    title = `${module.title} 학습 목표`;
                    content = (module.learningObjectives || []).join('\n- ');
                    content = `- ${content}`; // Markdown list for display
                }
                // Add more types if needed, e.g., 'key-concepts'

                App.dom.detailViewerTitle.textContent = title;
                App.dom.detailViewerBody.innerHTML = `<pre class="detail-modal-content">${content}</pre>`; // Use <pre> for plain text
                App.bs.detailViewerModal.show();
            }

            // --- 5. Event Listeners & Handlers ---
            function registerEventListeners() {
                // Static buttons
                App.dom.googleSigninBtn?.addEventListener('click', signInWithGoogle);
                App.dom.signOutBtn?.addEventListener('click', signOutUser);

                document.getElementById('new-project-btn')?.addEventListener('click', handleNewProjectClick);
                document.getElementById('save-project-btn')?.addEventListener('click', handleSaveProjectClick);
                document.getElementById('import-project-btn')?.addEventListener('click', () => document.getElementById('import-file-input')?.click());
                document.getElementById('import-file-input')?.addEventListener('change', handleImportProjectFile);
                document.getElementById('export-project-btn')?.addEventListener('click', handleExportProjectClick);
                document.getElementById('add-resource-btn')?.addEventListener('click', handleAddResourceClick);
                document.getElementById('save-resource-btn')?.addEventListener('click', handleSaveResourceClick);
                document.getElementById('resource-file-input')?.addEventListener('change', handleResourceFileChange);
                document.getElementById('apply-plan-btn')?.addEventListener('click', handleApplyPlanClick);
                document.getElementById('manage-actions-btn')?.addEventListener('click', handleManageActionsClick);
                document.getElementById('add-new-action-btn')?.addEventListener('click', () => openActionEditor());
                document.getElementById('save-action-btn')?.addEventListener('click', saveAction);
                document.getElementById('execute-prompt-btn')?.addEventListener('click', handleExecutePromptClick);
                document.getElementById('download-studypad-btn')?.addEventListener('click', downloadAllStudyPads); // New button event listener
                
                // Added direct event listener for the plan button
                App.dom.planButton?.addEventListener('click', () => handleBuildPrompt('0_plan', null));

                // Event Listeners for new Study Pad Viewer buttons
                App.dom.toggleViewerModeBtn?.addEventListener('click', toggleStudyPadViewerMode);
                App.dom.saveViewerContentBtn?.addEventListener('click', saveStudyPadViewerContent);


                // Event Delegation for dynamic content
                App.dom.projectList?.addEventListener('click', handleProjectListClick);
                App.dom.resourceList?.addEventListener('click', handleResourceListClick);
                App.dom.learningDashboard?.addEventListener('click', handleDashboardClick);
                App.dom.learningDashboard?.addEventListener('input', handleDashboardInput);
                App.dom.actionListContainer?.addEventListener('click', handleActionManagerClick);
                App.dom.actionSelectorBody?.addEventListener('click', handleActionSelectorClick);

                // Mobile UI
                document.getElementById('hamburger-btn')?.addEventListener('click', toggleSidebar);
                App.dom.overlay?.addEventListener('click', toggleSidebar);
            }

            // Specific Click Handlers
            function handleNewProjectClick() {
                document.getElementById('new-project-form').reset();
                App.bs.newProjectModal.show();
            }

            function handleSaveProjectClick() {
                const nameInput = document.getElementById('new-project-name');
                const goalInput = document.getElementById('new-project-goal');
                if (nameInput.value.trim() && goalInput.value.trim()) {
                    createNewProject(nameInput.value, goalInput.value);
                    App.bs.newProjectModal.hide();
                } else {
                    showToast('오류', '프로젝트 이름과 목표를 모두 입력해야 합니다.', 'danger');
                }
            }
            
            async function handleImportProjectFile(e) {
                const file = e.target.files[0];
                if (!file) return;
                if (!App.db.currentUser?.uid) return showToast("오류", "로그인이 필요합니다.", "danger");

                try {
                    const jsonText = await readFileAsText(file);
                    const importedProject = JSON.parse(jsonText);
                    if (importedProject.id && importedProject.name) {
                        // Overwrite local project if exists, otherwise add new
                        App.db.projects[importedProject.id] = importedProject;
                        // Ensure actions array is initialized or merged with default actions
                        if (!importedProject.actions || importedProject.actions.length === 0) {
                            importedProject.actions = JSON.parse(JSON.stringify(DEFAULT_ACTIONS));
                        } else {
                            DEFAULT_ACTIONS.forEach(defaultAction => {
                                if (!importedProject.actions.some(a => a.key === defaultAction.key)) {
                                    importedProject.actions.push(defaultAction);
                                }
                            });
                        }
                        const success = await saveProjectToFirestore(importedProject);
                        if (success) {
                            switchActiveProject(importedProject.id);
                            showToast("성공", "프로젝트를 성공적으로 가져왔습니다.", "success");
                        }
                    } else { throw new Error("파일에 'id'와 'name' 속성이 없습니다."); }
                }
                catch (err) {
                    let errorMessage = "유효하지 않은 프로젝트 파일이거나 파일 읽기에 실패했습니다.";
                    if (err instanceof SyntaxError) {
                        errorMessage = "JSON 형식이 올바르지 않습니다. 파일을 확인해주세요.";
                    } else if (err.message) {
                        errorMessage = err.message;
                    }
                    showToast("오류", errorMessage, "danger");
                }
                e.target.value = '';
            }
            
            function handleExportProjectClick() {
                if (!App.db.activeProjectId) return showToast("오류", "내보낼 프로젝트를 선택하세요.", "danger");
                const project = App.db.projects[App.db.activeProjectId];
                const projectData = JSON.stringify(project, null, 2);
                const blob = new Blob([projectData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const safeFileName = project.name.replace(/[/\\?%*:|"<>]/g, '-') || 'project';
                a.href = url;
                a.download = `${safeFileName}.json`;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 100);
            }
            
            function handleProjectListClick(e) {
                const listItem = e.target.closest('.list-group-item');
                if (!listItem) return;
                const projectId = listItem.dataset.projectId;
                if (e.target.closest('.delete-btn')) {
                    e.preventDefault();
                    deleteProject(projectId);
                } else {
                    switchActiveProject(projectId);
                }
            }

            function handleResourceListClick(e) {
                const listItem = e.target.closest('.list-group-item[data-resource-id]');
                if (!listItem) return;
                const resourceId = listItem.dataset.resourceId;
                const project = App.db.projects[App.db.activeProjectId];
                if (!project) return;
                if (e.target.closest('.delete-btn')) {
                    e.preventDefault();
                    e.stopPropagation();
                    const resourceName = project.resources.find(r => r.id === resourceId)?.name || "이";
                    if (window.confirm(`'${resourceName}' 자원을 삭제하시겠습니까?`)) { // Using window.confirm as a temporary placeholder
                        project.resources = project.resources.filter(r => r.id !== resourceId);
                        saveProjectToFirestore(project).then(success => { // Save to Firestore
                            if (success) {
                                renderResourceList();
                                showToast("성공", "자원이 삭제되었습니다.", "success");
                            }
                        });
                    }
                } else {
                    const resource = project.resources.find(r => r.id === resourceId);
                    if (resource) {
                        document.getElementById('resourceModalTitle').textContent = '자원 편집';
                        document.getElementById('resource-id').value = resource.id;
                        document.getElementById('resource-name').value = resource.name;
                        document.getElementById('resource-content').value = resource.content; // Use resource.content here
                        document.getElementById('resource-file-input').value = '';
                        App.bs.resourceModal.show();
                    }
                }
            }
            
            function handleAddResourceClick() {
                if (!App.db.activeProjectId) return showToast("오류", "먼저 프로젝트를 선택하세요.", "warning");
                document.getElementById('resourceModalTitle').textContent = '새 자원 추가';
                document.getElementById('resource-id').value = '';
                document.getElementById('resource-name').value = '';
                document.getElementById('resource-content').value = '';
                document.getElementById('resource-file-input').value = '';
                App.bs.resourceModal.show();
            }
            
            async function handleResourceFileChange(e) {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    const content = await readFileAsText(file);
                    document.getElementById('resource-content').value = content;
                    const resourceNameInput = document.getElementById('resource-name');
                    if (!resourceNameInput.value) {
                        resourceNameInput.value = file.name.replace(/\.[^/.]+$/, "");
                    }
                } catch(err) { showToast('오류', err.message, 'danger'); }
                e.target.value = '';
            }

            async function handleSaveResourceClick() {
                const id = document.getElementById('resource-id').value;
                const name = document.getElementById('resource-name').value.trim();
                const content = document.getElementById('resource-content').value;
                if (!name || !content) return showToast("오류", "이름과 내용을 모두 입력하세요.", "danger");
                const project = App.db.projects[App.db.activeProjectId];
                if (!project) return;
                if (!project.resources) project.resources = [];
                const existingResource = id ? project.resources.find(r => r.id === id) : null;
                if (existingResource) {
                    existingResource.name = name;
                    existingResource.content = content;
                } else {
                    project.resources.push({ id: `res_${Date.now()}`, name, content });
                }
                
                const success = await saveProjectToFirestore(project);
                if (success) {
                    renderResourceList();
                    App.bs.resourceModal.hide();
                    showToast("성공", `자원이 ${id ? '수정' : '추가'}되었습니다.`, "success");
                }
            }

            async function handleApplyPlanClick() {
                if (!App.db.activeProjectId) return showToast("오류", "먼저 프로젝트를 선택하세요.", "warning");
                if (!App.db.currentUser?.uid) return showToast("오류", "로그인이 필요합니다.", "danger");
                try {
                    const planText = App.dom.planInput.value;
                    const cleanedJsonString = planText.replace(/^```json\s*|```\s*$/g, '').trim();
                    if (!cleanedJsonString) throw new Error("입력된 내용이 없습니다.");
                    const planJSON = JSON.parse(cleanedJsonString);
                    if (!planJSON.modules || !Array.isArray(planJSON.modules)) throw new Error("JSON에 'modules' 배열이 없습니다.");
                    const project = App.db.projects[App.db.activeProjectId];
                    
                    project.learningPlan = planJSON;
                    project.name = planJSON.projectName || project.name;
                    project.goal = planJSON.mainGoal || project.goal;
                    
                    project.learningPlan.modules.forEach(module => {
                        if (module.studyPad === undefined) module.studyPad = "";
                        if (module.notes === undefined) module.notes = "";
                        if (module.recommendedResources === undefined) module.recommendedResources = [];
                    });

                    const success = await saveProjectToFirestore(project);
                    if (success) {
                        render();
                        showToast("성공", "학습 계획이 적용되었습니다.", "success");
                    }
                } catch (e) {
                    showToast("오류", "유효하지 않은 JSON 형식입니다: " + e.message, "danger");
                }
            }
            
            function handleDashboardClick(e) {
                const target = e.target;
                const card = target.closest('.module-card');
                if (!card) return;
                const moduleIndex = card.dataset.moduleIndex;
                if (target.matches('.open-action-selector')) {
                    renderActionSelector(moduleIndex);
                } else if (target.closest('.status-change-btn')) {
                    e.preventDefault();
                    updateModuleField(moduleIndex, 'status', target.closest('.status-change-btn').dataset.status);
                } else if (target.matches('.view-studypad-btn')) { // New handler for view button
                    e.preventDefault();
                    openStudyPadViewer(moduleIndex);
                } else if (target.matches('.view-details-btn')) { // New handler for view details button
                    e.preventDefault();
                    const type = target.dataset.detailType;
                    openDetailViewer(moduleIndex, type);
                }
            }
            
            function handleDashboardInput(e) {
                const target = e.target;
                const card = target.closest('.module-card');
                if (!card) return;
                const index = card.dataset.moduleIndex;
                if (target.matches('.module-studypad')) {
                    updateModuleField(index, 'studyPad', target.value);
                } else if (target.matches('.module-notes')) {
                    updateModuleField(index, 'notes', target.value);
                }
            }

            function handleManageActionsClick() {
                if (!App.db.activeProjectId) return showToast("오류", "프로젝트를 선택하세요.", "warning");
                renderActionManager();
                App.bs.actionManagerModal.show();
            }

            function handleActionManagerClick(e) {
                const editBtn = e.target.closest('.edit-action-btn');
                if(editBtn) openActionEditor(editBtn.dataset.actionKey);
                
                const deleteBtn = e.target.closest('.delete-action-btn');
                if(deleteBtn) deleteAction(deleteBtn.dataset.actionKey);
            }

            function handleActionSelectorClick(e) {
                const buildBtn = e.target.closest('.build-prompt-btn');
                if (buildBtn) {
                    e.preventDefault();
                    const { templateKey, moduleIndex } = buildBtn.dataset;
                    handleBuildPrompt(templateKey, moduleIndex);
                }
            }

            function handleBuildPrompt(templateKey, moduleIndex) {
                App.bs.actionSelectorModal.hide();

                const project = App.db.projects[App.db.activeProjectId];
                if (!project) return;
                
                const template = (project.actions || []).find(a => a.key === templateKey);
                if (!template) return showToast('오류', '액션을 찾을 수 없습니다.', 'danger');

                const module = moduleIndex !== undefined && project.learningPlan ? project.learningPlan.modules[moduleIndex] : null;

                App.dom.promptModalLabel.textContent = template.title;
                App.dom.dynamicFormContainer.innerHTML = '';
                
                App.dom.dataSelector.innerHTML = '<option value="">자원 라이브러리에서 선택</option>';
                (project.resources || []).forEach(r => App.dom.dataSelector.innerHTML += `<option value="${r.id}">${r.name}</option>`);

                let purposeTemplate = template.purpose;
                const context = { '학습 목표': project.goal, '현재 수준': '지식이 필요한 학습자', ...(module || {}) };
                if (module) {
                    context['모듈 제목'] = module.title;
                    context['핵심 개념'] = (module.keyConcepts || []).join(', ');
                    // Add recommended resources to context for template if available
                    if (module.recommendedResources && module.recommendedResources.length > 0) {
                        context['추천 리소스'] = module.recommendedResources.join(', ');
                    }
                }
                
                // Extract variables that are still [VAR_NAME] after initial pre-filling
                const variables = [...new Set([...purposeTemplate.matchAll(/\[(.*?)\]/g)].map(m => m[1]))];
                variables.forEach(varName => {
                    const prefilledValue = context[varName];
                    if (prefilledValue) {
                        purposeTemplate = purposeTemplate.replaceAll(`[${varName}]`, prefilledValue);
                    } else {
                        App.dom.dynamicFormContainer.innerHTML += `<div class="mb-3"><label for="var-${varName}" class="form-label form-label-sm">${varName}</label><input type="text" id="var-${varName}" class="form-control form-control-sm dynamic-var-input" data-var-name="${varName}" placeholder="${varName} 내용 입력..."></div>`;
                    }
                });

                let currentDataSource = 'none';
                if (module?.studyPad && (templateKey.startsWith('1_') || templateKey.startsWith('2_'))) {
                    currentDataSource = 'studypad';
                }
                // Reset radio buttons and then set the correct one
                document.querySelectorAll('input[name="dataSource"]').forEach(radio => radio.checked = false);
                const initialDataSourceRadio = document.getElementById(`source-${currentDataSource}`);
                if (initialDataSourceRadio) {
                    initialDataSourceRadio.checked = true;
                }
                document.getElementById('data-direct-input').value = '';

                const dataSourceContainers = {
                    resource: document.getElementById('data-selector-container'),
                    direct: document.getElementById('data-direct-input-container'),
                };
                
                const updateDataSourceVisibility = () => {
                    const selected = document.querySelector('input[name="dataSource"]:checked').value;
                    Object.values(dataSourceContainers).forEach(c => c.classList.add('d-none'));
                    if (dataSourceContainers[selected]) {
                        dataSourceContainers[selected].classList.remove('d-none');
                    }
                };

                const updatePreview = () => {
                    let previewPurpose = purposeTemplate;
                    App.dom.dynamicFormContainer.querySelectorAll('.dynamic-var-input').forEach(input => {
                        const varName = input.dataset.varName;
                        const value = input.value || `[${varName}]`;
                        previewPurpose = previewPurpose.replaceAll(`[${varName}]`, value);
                    });
                    
                    const selectedDataSource = document.querySelector('input[name="dataSource"]:checked').value;
                    let dataContent = '없음';
                    if (selectedDataSource === 'resource') {
                        const resId = App.dom.dataSelector.value;
                        if (resId) dataContent = (project.resources.find(r => r.id === resId) || {}).content;
                    } else if (selectedDataSource === 'studypad') {
                        if (module?.studyPad) dataContent = module.studyPad;
                    } else if (selectedDataSource === 'direct') {
                        dataContent = document.getElementById('data-direct-input').value;
                    }
                    
                    const contextForAI = {
                        projectName: project.name,
                        mainGoal: project.goal,
                    };
                    if (project.learningPlan) {
                        contextForAI.tutorPersona = project.learningPlan.tutorPersona;
                        contextForAI.fullTableOfContents = project.learningPlan.modules.map(m => ({ id: m.id, title: m.title, status: m.status }));
                    }
                    if (module) {
                        const { studyPad, notes, ...currentModuleContext } = module;
                        contextForAI.currentModule = currentModuleContext;
                    }
                    const projectContext = JSON.stringify(contextForAI, null, 2);
                    let finalPrompt = MASTER_PROMPT_SHELL.replace(/{{purpose}}/g, previewPurpose)
                                                         .replace(/{{data}}/g, dataContent || '내용 없음')
                                                         .replace(/{{projectContext}}/g, projectContext);
                    App.dom.livePreviewContainer.textContent = finalPrompt;
                };

                document.querySelectorAll('input[name="dataSource"]').forEach(radio => radio.onchange = () => {
                    updateDataSourceVisibility();
                    updatePreview();
                });

                App.dom.dynamicFormContainer.addEventListener('input', updatePreview);
                App.dom.dataSelector.addEventListener('change', updatePreview);
                document.getElementById('data-direct-input').addEventListener('input', updatePreview);
                
                updateDataSourceVisibility();
                updatePreview();
                App.bs.promptModal.show();
            }

            function handleExecutePromptClick() {
                const finalPromptText = App.dom.livePreviewContainer.textContent;
                copyToClipboard(finalPromptText);
            }
            
            function toggleSidebar() {
                App.dom.sidebar?.classList.toggle('is-open');
                App.dom.overlay?.classList.toggle('is-visible');
            }

            // --- 6. Initial Execution ---
            initApp();
        });
    </script>
</body>
</html>
